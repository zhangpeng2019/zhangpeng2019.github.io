<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Document on 陈巧倩</title>
    <link>https://www.chenqiaoqian.com/tags/document/</link>
    <description>Recent content in Document on 陈巧倩</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Jul 2023 11:13:34 +0800</lastBuildDate><atom:link href="https://www.chenqiaoqian.com/tags/document/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unity中文版-Unity&#39;s Package Manager(三)(自翻译)</title>
      <link>https://www.chenqiaoqian.com/2023/07/19/2023-07-19-unity-Documents-4/</link>
      <pubDate>Wed, 19 Jul 2023 11:13:34 +0800</pubDate>
      
      <guid>https://www.chenqiaoqian.com/2023/07/19/2023-07-19-unity-Documents-4/</guid>
      <description>&lt;p&gt;翻译Unity中文版的初衷是因为官方提供的中文版存在缺陷，而且翻译的不全。现在基于Unity2023.2版本对官方文档进行翻译。&lt;/p&gt;
&lt;h1 id=&#34;unitys-package-manager三&#34;&gt;Unity’s Package Manager(三) &lt;a href=&#34;#unitys-package-manager%e4%b8%89&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&#34;package-manager-window包管理器窗口&#34;&gt;Package Manager window(包管理器窗口) &lt;a href=&#34;#package-manager-window%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8%e7%aa%97%e5%8f%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;从Unity编辑器的&lt;strong&gt;窗口&lt;/strong&gt;菜单访问包管理器窗口。&lt;/p&gt;
&lt;p&gt;你可以使用包管理器窗口来查看哪些包和功能集可以安装或已在你的项目中安装。你也可以使用此窗口来检查哪些包版本可以使用，以及为每个项目安装、删除、禁用或更新包和功能集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;包管理器窗口显示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(A)&lt;/strong&gt; 实验性包指示器，如果你的项目有实验性的包，会向你发出警告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(B)&lt;/strong&gt; &lt;strong&gt;安装&lt;/strong&gt;按钮，您可以通过输入git的URL、本地路径或包的名称点击它直接在项目中安装包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(C)&lt;/strong&gt; 导航面板，你可以使用它来选择上下文，以改变在列表面板**(H)**中显示的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(D)&lt;/strong&gt; 排序菜单，你可以使用它按照名称或日期对包和功能集列表进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(E)&lt;/strong&gt; 过滤菜单，你可以使用它来缩小在列表面板**(H)&lt;strong&gt;中显示的包的范围。 **过滤**菜单和&lt;/strong&gt;清除过滤&lt;strong&gt;按钮对&lt;/strong&gt;内置&lt;strong&gt;列表不可用。它们也对&lt;/strong&gt;项目中&lt;strong&gt;的上下文不可用 (除非你有基于订阅的包)，因为导航面板中的那个上下文有一个&lt;/strong&gt;更新**的嵌套项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-asset-filters.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(F)&lt;/strong&gt; 搜索框，您可以通过名称查找包和功能集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(G)&lt;/strong&gt; &lt;strong&gt;高级&lt;/strong&gt;菜单，您可以使用它来访问Package Manager的&lt;strong&gt;项目设置&lt;/strong&gt;以及更多。详情请参考高级设置部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(H)&lt;/strong&gt; 列表面板，展示你在导航面板中选定的类型的包，受你设定的任何过滤器和搜索参数的限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(I)&lt;/strong&gt; 详情面板，显示在列表面板中选定的包或功能集特定的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(J)&lt;/strong&gt; 包详细信息标签，显示关于选定包或功能集的更多信息。这些标签是基于选定项变化的。关于这些标签的信息，请参考详情面板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(K)&lt;/strong&gt; 在项目级别执行以下任何操作的按钮：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装或移除功能集&lt;/li&gt;
&lt;li&gt;安装，更新或者移除包&lt;/li&gt;
&lt;li&gt;下载并导入，更新或者移除&lt;strong&gt;Asset Store&lt;/strong&gt;包&lt;/li&gt;
&lt;li&gt;禁用或启用内置包&lt;/li&gt;
&lt;li&gt;安装或移除服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(L)&lt;/strong&gt; 状态栏，当Package Manager加载包和功能集时显示信息。这些信息包括错误和警告信息，可用的Asset Store包的数量，以及加载更多Asset Store包的链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(M)&lt;/strong&gt; &lt;strong&gt;刷新列表&lt;/strong&gt;按钮让您可以刷新显示的包列表。在&lt;strong&gt;我的资源&lt;/strong&gt;上下文中，&lt;strong&gt;刷新列表&lt;/strong&gt;是一个菜单，其中有一个&lt;strong&gt;检查更新&lt;/strong&gt;选项。您可以使用&lt;strong&gt;检查更新&lt;/strong&gt;来检查您电脑上所有包的更新，而不仅仅是在&lt;strong&gt;我的资源&lt;/strong&gt;上下文中可见的那些包的更新。&lt;/p&gt;
&lt;h2 id=&#34;advanced-settings高级设置&#34;&gt;Advanced settings(高级设置) &lt;a href=&#34;#advanced-settings%e9%ab%98%e7%ba%a7%e8%ae%be%e7%bd%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;高级设置菜单允许你执行以下操作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Menu item&lt;/strong&gt;(菜单项)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Action results&lt;/strong&gt;(操作结果)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Project Settings&lt;/strong&gt;(&lt;strong&gt;项目设置&lt;/strong&gt;)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择此项可以打开Package Manager的项目设置，在这里你可以: - 浏览Unity Registry时列出预发布版的包。- 在你的项目中添加，编辑和移除作用域注册。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Preferences(首选项)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择此项来查看和设置Unity编辑器及相关窗口和工具的首选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Manual resolve(手动解决)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择此项可以强制Package Manager解决项目的包问题。如果需要，它会重新安装修改过的或缺失的包，并移除多余的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;status-bar状态栏&#34;&gt;Status bar(状态栏) &lt;a href=&#34;#status-bar%e7%8a%b6%e6%80%81%e6%a0%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Package Manager在其窗口底部的状态栏中显示消息。&lt;/p&gt;
&lt;p&gt;典型的，Package Manager可能会显示四种状态消息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在新项目中首次打开Package Manager窗口时，会短暂出现&lt;strong&gt;刷新列表&lt;/strong&gt;的消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-loading.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当你点击&lt;strong&gt;刷新列表&lt;/strong&gt;时，也会出现这条消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在导航面板中选择&lt;strong&gt;我的资产&lt;/strong&gt;上下文时，加载条会出现在日期上方。它会显示Asset Store包的数量和一个&lt;strong&gt;加载&lt;/strong&gt;链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-assets-loadbar.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大部分时间，状态栏都会显示Package Manager窗口最近一次刷新其信息的日期和时间。但是，如果Package Manager检测到一个问题，例如网络问题，它会提示你登陆：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-errors.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你的网络连接正常，但你没有登录到你的Unity账户，Package Manager不会显示任何Asset Store的包。当你在导航面板中选择&lt;strong&gt;我的资产&lt;/strong&gt;时，Package Manager会提示你登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-unityid.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在列表面板中，点击&lt;strong&gt;登陆&lt;/strong&gt;通过Unity Hub登陆到你的Unity账户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如需获取如何解决这些错误以及更多问题的信息，参考Package Manager的故障排除。&lt;/p&gt;
&lt;h1 id=&#34;access-the-package-manager-window打开package-manager窗口&#34;&gt;Access the Package Manager window(打开Package Manager窗口) &lt;a href=&#34;#access-the-package-manager-window%e6%89%93%e5%bc%80package-manager%e7%aa%97%e5%8f%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;打开Package Manager窗口，导航至Unity的主菜单，然后前往&lt;strong&gt;窗口&lt;/strong&gt; &amp;gt; &lt;strong&gt;Package Manager&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-access.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;navigation-panel导航面板&#34;&gt;Navigation panel(导航面板) &lt;a href=&#34;#navigation-panel%e5%af%bc%e8%88%aa%e9%9d%a2%e6%9d%bf&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;使用Package Manager的导航面板选择你想要查看的程序包子集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-nav.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;导航面板**（A）&lt;strong&gt;，列表面板&lt;/strong&gt;（B）&lt;strong&gt;和详细信息面板&lt;/strong&gt;（C）**&lt;/p&gt;
&lt;p&gt;导航面板**（A）&lt;strong&gt;选择一个上下文，以在列表面板&lt;/strong&gt;（B）**中列出这类包。&lt;/p&gt;
&lt;p&gt;当你从列表面板选择一个包时，其详情会在详细信息视图**（C）**中显示。&lt;/p&gt;
&lt;p&gt;有关导航面板中的上下文信息，请参照包列表上下文。&lt;/p&gt;
&lt;h1 id=&#34;list-panel列表面板&#34;&gt;List panel(列表面板) &lt;a href=&#34;#list-panel%e5%88%97%e8%a1%a8%e9%9d%a2%e6%9d%bf&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Package Manager窗口展示了满足你设定条件的功能集，包，或者&lt;strong&gt;Asset Store&lt;/strong&gt;包。&lt;/p&gt;
&lt;p&gt;你通过在导航面板中选择一个上下文以及可选地设置额外的筛选和搜索条件来设定这些条件。&lt;/p&gt;
&lt;p&gt;有关搜索工作方式的重要信息，请参考搜索框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-list.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(A)&lt;/strong&gt; 当你选择&lt;strong&gt;Unity Registry&lt;/strong&gt;或&lt;strong&gt;In Project&lt;/strong&gt;上下文时，功能集会出现在列表面板的顶部。功能集用功能集图标表示。切换展开图标以展开或收缩功能集列表。当你从列表中选择一个功能集时，其详细信息会显示在右侧。这些详细信息包括简短的描述，所包含包的列表，以及该功能集的&lt;strong&gt;QuickStart&lt;/strong&gt;指南的链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(B)&lt;/strong&gt; Asset Store包会出现在你从&lt;strong&gt;My Assets&lt;/strong&gt;列表导入到项目中的所有包的&lt;strong&gt;In Project&lt;/strong&gt;列表中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(C)&lt;/strong&gt; 注册表组织了已安装到你的项目中或可供安装的包的列表。该列表为来自Unity的注册表和你在项目中安装的其他范围注册表的包分别设立了不同的组。选择左边的展开器以展开或折叠每个注册表的包列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(D)&lt;/strong&gt; 当包被锁定，作为依赖性安装，弃用等情况时，图标会在这一列显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(E)&lt;/strong&gt; 包版本显示已安装的包的版本。如果包尚未安装或导入，显示的版本即为推荐版本。版本号旁边经常出现特殊图标，表示其状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconRel.png&#34; alt=&#34;&#34;&gt; Released 已发布&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://docs.unity3d.com/2023.2/Documentation/uploads/Main/iconRC.png&#34; alt=&#34;&#34;&gt; Release Candidate 发布候选&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconPre.png&#34; alt=&#34;&#34;&gt; Pre-release 预发布&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconExp.png&#34; alt=&#34;&#34;&gt; Experimental 实验性&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconCustom.png&#34; alt=&#34;&#34;&gt; Custom (embedded) 定制（内嵌)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于Asset Store包，显示的版本是你已经下载的版本，或者是在Asset Store中可供下载的版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(F)&lt;/strong&gt; 这些图标显示了包或Asset Store包的状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Icon:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconCheck.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;勾选标记表示包或功能集已经被安装，启用或导入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconUpdate.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;更新图标表示包有可用的更新。要更新你的包，请根据包的类型遵循适当的说明： - 对于Unity包，参考切换到另一个包版本。- 对于Asset Store包，参考更新你的Asset Store包。- 你不能更新功能集版本，因为它们固定于编辑器版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconImport.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;导入图标表示有一个Asset Store包可供导入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconDownload.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;下载图标表示有一个Asset Store包可供下载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconWarning.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;警告图标表示包存在问题，例如弃用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/iconError.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;错误图标表示在安装或加载过程中出了些问题。有关解决错误的信息，参考故障排查。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;(G)&lt;/strong&gt; &amp;ldquo;&lt;strong&gt;我的资源&lt;/strong&gt;&amp;ldquo;上下文显示一个计数器，显示可用但未在列表中显示的Asset Store包的数量。要加载更多Asset Store包，点击&lt;strong&gt;加载&lt;/strong&gt;链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你选择了“我的资源”上下文，但是包管理器窗口没有列出任何包，请参考包管理器窗口中的错误消息以获取解释和解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(H)&lt;/strong&gt; 状态栏显示关于包加载状态和网络警告的消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(I)&lt;/strong&gt; 点击&lt;strong&gt;重新加载&lt;/strong&gt;按钮，强制包管理器重新加载你的包和功能集。&lt;/p&gt;
&lt;p&gt;默认情况下，包管理器窗口显示选定上下文中所有可用的包和功能集的列表，但你可以过滤列表，以显示满足你标准的包和功能集。&lt;/p&gt;
&lt;p&gt;你也可以在列表中包含预发布的包，并通过名称（ID）或显示名称搜索特定的包或功能集。&lt;/p&gt;
&lt;h1 id=&#34;details-panel详情面板&#34;&gt;Details panel(详情面板) &lt;a href=&#34;#details-panel%e8%af%a6%e6%83%85%e9%9d%a2%e6%9d%bf&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器窗口的右侧面板显示了所选包的详细信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-details.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这些详情包括以下信息：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(A)&lt;/strong&gt; 显示名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(B)&lt;/strong&gt; 包版本，包发布到仓库或Asset Store的日期，以及任何资源或资产标签。如果适用，可能会显示其他信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本之前可能还会出现一个信息提示。你可以点击提示获取更多关于包的信息。例如，如果你请求的包版本与已安装的版本不匹配，这个提示就可能出现。&lt;/li&gt;
&lt;li&gt;对于Unity包，当已安装的&lt;strong&gt;功能集&lt;/strong&gt;需要所选的包时，版本号之前会出现一个锁定图标。锁定包可以防止你无意中更改包版本，以使功能集继续有效地工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(C)&lt;/strong&gt; 主机包的仓库和包作者（仅限Unity包），或者包发布商（Asset Store）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(D)&lt;/strong&gt; 包名称（仅限Unity包）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(E)&lt;/strong&gt; 链接到附加资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于Unity包：链接打开包文档页，包更新日志（如果有）和许可信息。&lt;/li&gt;
&lt;li&gt;对于Asset Store包：链接打开Asset Store上Asset Store包的官方页面，以及链接到发布商的支持页面和他们的网站（如果有）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(F)&lt;/strong&gt; 包详细信息选项卡，根据包类型不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于Unity包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：包的简短描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本历史&lt;/strong&gt;：包管理器始终列出已安装或推荐的包版本，并提供安装、更新或删除的操作按钮。如果有其他支持的版本可用，并且与你的Unity编辑器版本兼容，包管理器也会列出这些版本。展开每个条目以检查发布日期，该版本的更新日志，以及指向完整更新日志的链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依赖性: 包的依赖信息。此部分两个方向列出依赖项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正在使用&lt;/strong&gt;：此包是否依赖于另一个包，如果是，哪个版本。已安装的包在版本号后显示依赖项的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;被使用&lt;/strong&gt;：是否有另一个包依赖于此包，如果是，哪个版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;样本&lt;/strong&gt;：只有当包作者提供了样本时，此选项卡才会显示。选项卡旁边显示一个描述和&lt;strong&gt;导入&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于Asset Store包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概览 : 关于包的信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你分配给此Asset Store包的任何自定义标签。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持的Unity版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所需的磁盘空间。&lt;/li&gt;
&lt;li&gt;你获取Asset Store包的日期。&lt;/li&gt;
&lt;li&gt;包的简短描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;发布&lt;/strong&gt;：发布信息，包括原始包的发布日期和当前包的发布日期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;导入的资源&lt;/strong&gt;：列出了你从Asset Store包导入到你的项目中的项。只有下载了包并将其导入到你的项目后，此选项卡才会出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;：市场推广图片、音频和视频在Asset Store上的缩略图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(G)&lt;/strong&gt; 解锁、安装、更新、删除或禁用Unity包的按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(H)&lt;/strong&gt; 下载、导入或删除Asset Store包的控件，以及下载和导入包更新的控件。有时是按钮，有时是菜单，最常见的操作显示在最前面。当你的项目和缓存与Asset Store包的最新版本保持同步时，&lt;strong&gt;包管理器&lt;/strong&gt;窗口会显示&lt;strong&gt;在项目中&lt;/strong&gt;（和一个勾选标记）。具体来说，这意味着该包的至少一个项目是最新的。然而，即使显示&lt;strong&gt;在项目中&lt;/strong&gt;，你仍然可以从菜单中选择其他操作。&lt;/p&gt;
&lt;h2 id=&#34;labels标签&#34;&gt;Labels标签 &lt;a href=&#34;#labels%e6%a0%87%e7%ad%be&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一些包和 Asset Store 包在包名称或版本号旁边显示标签。这些标签提供关于包的源或状态的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源标签类型表示包的来源（例如，它是来自本地文件夹，还是你从包注册表下载的）。&lt;/li&gt;
&lt;li&gt;状态标签类型表示包的开发周期阶段。例如，它是一个实验包，还是在特定Unity版本的发布轨道上。&lt;/li&gt;
&lt;li&gt;Asset Store 标签表明该包起源于Asset Store。这些标签也可能表示一种特殊状态（例如，已弃用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些源标签暗示状态标签，反之亦然。例如，如果你将一个包嵌入到你的项目中，则Unity自动假定它是一个正在开发的自定义包，所以在详情面板中只显示&lt;strong&gt;自定义&lt;/strong&gt;标签。&lt;/p&gt;
&lt;p&gt;包管理器窗口显示以下值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Label&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Type&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Meaning&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Released(发布)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity官方已经发布并全面支持这个包。质量保证团队已经测试过这个版本的包，并保证它与特定版本的编辑器以及为该编辑器版本发布的所有其他包兼容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Release Candidate(发布候选)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个版本的包将在下一个Tech Stream的当前发布周期内完全发布。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Pre-Release(预发布)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个版本的包处于开发的早期阶段，但Unity保证在长期支持（LTS）发布周期结束时将其发布。它可能还没有完整的文档，或者没有完全通过开发团队或Unity的质量保证团队的验证。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Experimental()实验版&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这些包是新包，或者包含实验性的修改。Unity不支持Experimental包，因为它们处于开发的早期阶段。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Deprecated(已弃用)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这些包在该Unity编辑器版本中不再开发，或者一个特定版本的包有严重问题。Unity不支持已弃用的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Custom(自定义)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state, source&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个包嵌入在你的项目中。大多数自定义包开发者开始时会在他们的项目中嵌入一个新包，这就是为什么显示&lt;strong&gt;自定义&lt;/strong&gt;标签。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;local(本地)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;source&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包管理器从你本地磁盘上的一个文件夹或tarball文件，而非你的Unity项目文件夹，安装了这个包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;git&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;source&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包管理器直接从Git仓库在你的项目中安装了这个包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;asset store&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;asset&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这是一个你从Asset Store购买或下载的Asset Store包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;deprecated(已弃用)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;asset&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;除非你之前已经下载或购买过这个包，否则这个包在Asset Store上不再可用。换句话说，新的客户无法再发现它。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;features-details-panel特性详情面板&#34;&gt;Features (details panel)(特性（详情面板）) &lt;a href=&#34;#features-details-panel%e7%89%b9%e6%80%a7%e8%af%a6%e6%83%85%e9%9d%a2%e6%9d%bf&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;在包管理器窗口中，当你从列表面板中选择一个特性集后，右侧的详情面板会显示选中的特性集的详细信息。详情面板会以一种微型包管理器窗口的形式展现特性集的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/fs-details.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(A)&lt;/strong&gt; 当你从列表面板选择一个特性集时，其信息将在详情面板中显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(B)&lt;/strong&gt; 特性集的显示名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(C)&lt;/strong&gt; 特性集的名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(D)&lt;/strong&gt; 一个&lt;strong&gt;安装&lt;/strong&gt;或&lt;strong&gt;移除&lt;/strong&gt;特性集的按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(E)&lt;/strong&gt; 链接到这个特性集的&lt;strong&gt;快速入门&lt;/strong&gt;指南，包含了如何一起使用这个包集的详细信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(F)&lt;/strong&gt; 特性集详情选项卡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：对特性集的简介。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含的包 这个选项卡显示以下信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含的包的列表。&lt;/li&gt;
&lt;li&gt;选中的包的详细信息。显示的信息包括包的显示名称，特性集推荐或已安装的版本，以及其描述。&lt;/li&gt;
&lt;li&gt;一个将选中的包加载到包管理器窗口的快捷方式。选择这个快捷方式会替换列表面板和详情面板中的特性集。当你直接从包中访问详情时，包管理器窗口提供的信息比你从特性集内部访问时更多。例如，包详情视图显示依赖信息和包含的任何示例。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;package-version-overrides包版本覆盖&#34;&gt;Package version overrides(包版本覆盖) &lt;a href=&#34;#package-version-overrides%e5%8c%85%e7%89%88%e6%9c%ac%e8%a6%86%e7%9b%96&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;特性集是一组针对特定版本的Unity良好协同工作的包的集合，这意味着包管理器会安装你的特性集所需的特定包版本。然而，包管理器实际上可能会安装一个不同的版本（覆盖请求的版本）的原因有几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;另一个包或特性集需要相同包的不同版本，包管理器通过覆盖来解决包版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你请求了一个不同的包版本，它与特性集所需的版本没有冲突。在这种情况下，一个重置按钮会显示，你可以点击它，返回到特性集所需（推荐）的版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：当包版本中的主要或次要数字改变时，&lt;strong&gt;重置&lt;/strong&gt;按钮才会显示。当包版本中的补丁号改变时，&lt;strong&gt;重置&lt;/strong&gt;按钮不会显示。关于语义版本方案的更多信息，请参考版本控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果包管理器安装的版本并非你请求的版本，信息提示会解释更改的原因。&lt;/p&gt;
&lt;h1 id=&#34;finding-packages-and-feature-sets查找包和特性集&#34;&gt;Finding packages and feature sets(查找包和特性集) &lt;a href=&#34;#finding-packages-and-feature-sets%e6%9f%a5%e6%89%be%e5%8c%85%e5%92%8c%e7%89%b9%e6%80%a7%e9%9b%86&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器窗口提供了几种方法帮助你找到特定的包或&lt;strong&gt;特性集&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-find.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;(A)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Packages list context(包列表上下文)&lt;/td&gt;
&lt;td&gt;从导航面板选择一个“上下文”，以确定显示哪个包列表。上下文可能是包的来源，如注册服务器，资源商店，或Unity编辑器本身（内置包）。然而，&lt;strong&gt;项目中&lt;/strong&gt; 上下文只显示那些已经安装在当前项目中的包和特性集，无论它们的来源是什么。例如，你可以选择 &lt;strong&gt;我的资源&lt;/strong&gt; 上下文，只在列表中显示你可用的资源商店包，或者选择 &lt;strong&gt;项目中&lt;/strong&gt; 上下文，显示资源商店包，Unity包，以及已经安装在你的项目中的特性集。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;(B)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Sort(排序)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;以名称，发布日期（&lt;strong&gt;Unity注册表&lt;/strong&gt;，&lt;strong&gt;我的注册表&lt;/strong&gt;，&lt;strong&gt;项目中&lt;/strong&gt;），购买日期（仅限资源商店包），或最近更新日期（仅限&lt;strong&gt;我的资产&lt;/strong&gt;）的升序或降序排列列表。例如，如果你想找到一个最近更新的资源商店包，但你记不住它的名称，可以选择 &lt;strong&gt;我的资产&lt;/strong&gt;，然后按 &lt;strong&gt;最近更新&lt;/strong&gt; 排序，浏览列表找到它。排序影响每个可折叠区域下的项，但保持区域的位置不变。如果你从Z到A排序，包管理器将在 &lt;strong&gt;特性&lt;/strong&gt; 部分内将所有的特性集重新排序为Z到A，以及每个区域下的所有包，但不会在列表中混淆内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;(C)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Filters(过滤)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;选择选项来缩小列出的包。在 &lt;strong&gt;我的资产&lt;/strong&gt; 中列出的包有增强的过滤选项：&lt;strong&gt;状态&lt;/strong&gt; （已下载，已导入，有可用更新，未标记，隐藏，已弃用）;&lt;strong&gt;类别&lt;/strong&gt; （3D，附加组件，2D，音频等）;&lt;strong&gt;标签&lt;/strong&gt; （你在资源商店中定义的自定义标签）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;(D)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Search(搜索)&lt;/td&gt;
&lt;td&gt;使用搜索框按名称查找Unity包或 &lt;strong&gt;资源商店&lt;/strong&gt; 包。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用这些控制可以缩小在列表面板中显示的包和特性集，以及它们的显示顺序。这使得更容易找到你正在查找的内容，或者在你不确切知道你想要什么的时候帮助你浏览。&lt;/p&gt;
&lt;p&gt;当你一起使用多个这些控制时，你可以缩小在列表中出现的匹配集。&lt;/p&gt;
&lt;p&gt;当你从注册表（非资产商店）找到一个包后，你可以选择它，然后可能在详情面板中找到一个特定的版本。对于特性集，总是只有一个版本可用，所以你可以安装它或移除它。&lt;/p&gt;
&lt;h2 id=&#34;finding-a-specific-version寻找特定版本&#34;&gt;Finding a specific version(寻找特定版本) &lt;a href=&#34;#finding-a-specific-version%e5%af%bb%e6%89%be%e7%89%b9%e5%ae%9a%e7%89%88%e6%9c%ac&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要找到特定的包版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Unity中，通过打开&lt;strong&gt;窗口&lt;/strong&gt;菜单并选择&lt;strong&gt;包管理器&lt;/strong&gt;来打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你正在寻找一个预发布的包，按照以下步骤进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在高级菜单下选择&lt;strong&gt;项目设置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-settings.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;高级设置&lt;/strong&gt;组中，选择&lt;strong&gt;启用预发布包&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭项目设置窗口。任何预发布包现在都会带有指示器显示在列表中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以浏览包列表，或者用以下方法之一找到特定的包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过名称或关键字搜索包。&lt;strong&gt;注意：&lt;strong&gt;你在导航面板中选择的上下文限制了搜索范围。例如，如果你正在搜索一个资源商店的包，确保在开始搜索之前选择了&lt;/strong&gt;我的资源&lt;/strong&gt;上下文。当你切换上下文时，包管理器窗口会清空搜索框。但如果你返回到之前的上下文，包管理器窗口会恢复你的搜索词。&lt;/li&gt;
&lt;li&gt;对列表进行排序（例如，按&lt;strong&gt;最近更新&lt;/strong&gt;，以找到最近更新的包）。&lt;/li&gt;
&lt;li&gt;对列表应用过滤器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择一个包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于来自Unity注册表的包，在详细信息面板中选择&lt;strong&gt;版本历史&lt;/strong&gt;选项卡。如果有多个版本可用，展开条目以显示每个版本的特定信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-update.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;strong&gt;版本历史&lt;/strong&gt;选项卡显示时，你可以在展开特定版本时执行各种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以查看该版本的更新日志，并点击&lt;strong&gt;更新日志&lt;/strong&gt;以查看跨版本的所有更改列表。&lt;/li&gt;
&lt;li&gt;如果你还没有在你的项目中安装这个包，你可以安装这个版本。&lt;/li&gt;
&lt;li&gt;如果你的项目中已经安装了这个包的另一个版本，你可以将包更新到这个版本。&lt;/li&gt;
&lt;li&gt;如果你在项目中安装了这个包，但不再需要它，你可以从项目中移除这个包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;packages-list-context包列表上下文&#34;&gt;Packages list context(包列表上下文) &lt;a href=&#34;#packages-list-context%e5%8c%85%e5%88%97%e8%a1%a8%e4%b8%8a%e4%b8%8b%e6%96%87&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;要改变在包管理器窗口的列表面板中显示哪些包，从导航面板中选择你想要的上下文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-unityregistry.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;你可以从以下选项中选择：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;In Project(项目中)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示安装在项目中的所有特性集和包，包括本地、git和嵌入的包，以及从任何注册表安装的包。列表还包括你从&lt;strong&gt;我的资源&lt;/strong&gt;上下文导入的任何资源商店的包。&lt;strong&gt;项目中&lt;/strong&gt;有一个嵌套条目，&lt;strong&gt;更新&lt;/strong&gt;，列出了你的项目中可以更新的所有包，包括资源商店的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Unity Registry(Unity注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示Unity包注册表上的所有&lt;strong&gt;特性集&lt;/strong&gt;和包，无论它们是否已经在你的项目中安装。这不包括从任何其他位置或从任何作用域注册表安装的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Assets(我的资源)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示你用当前登录的Unity ID购买的所有资源商店的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Built-in(内置)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只显示内置的Unity包，这些包代表Unity的核心功能。你可以用这些包来开启和关闭Unity模块。 &lt;strong&gt;提示&lt;/strong&gt;：你可以在Unity脚本API中了解更多关于每个内置包（模块）实现的内容。每个模块程序集页面都列出了内置包实现的哪些API。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Services(服务)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示集成服务，帮助你吸引、保留和变现用户。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Registries(我的注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示这个项目中安装的任何作用域注册表中可用的包。这个上下文只有在你在这个项目中安装了一个作用域注册表时才会出现。如果你安装了一个作用域注册表但它没有在&lt;strong&gt;我的注册表&lt;/strong&gt;上下文中列出，或者&lt;strong&gt;我的注册表&lt;/strong&gt;上下文根本无法使用，那可能是因为你添加的包注册表服务器没有实现&lt;code&gt;/-/v1/search&lt;/code&gt;或&lt;code&gt;/-/all&lt;/code&gt;端点，这意味着它不兼容Unity的包管理器。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当你在导航面板中选择一个上下文时，列表面板会显示符合你选择的特性集和包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你在搜索框中输入了任何文本或设定了任何过滤器，列表面板只会显示符合上下文、搜索条件和活动过滤器的特性集和包。&lt;/p&gt;
&lt;h1 id=&#34;sorting-the-list排序列表&#34;&gt;Sorting the list(排序列表) &lt;a href=&#34;#sorting-the-list%e6%8e%92%e5%ba%8f%e5%88%97%e8%a1%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;你可以根据&lt;strong&gt;特性集&lt;/strong&gt;或包的名字进行升序或降序排序。根据列表上下文，你也可能有一个或多个日期可以排序。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Menu options&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;In Project(项目中)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-inproj.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称 - 创建者将这个特性集或包发布到Unity注册表、资源商店或作用域注册表的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Unity Registry(Unity注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-unity.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称 - 创建者将这个特性集或包发布到Unity注册表的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Assets(我的资源)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-assets.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称 - 你从资源商店获得这个包的日期 - 这个资源商店包的最后更新日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Built-in(内置)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-core.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称是唯一的排序选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Services(服务)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-services.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称 - 最后一次发布此服务包的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Registries(我的注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-sort-myreg.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;- 名称 - 创建者将此包发布到作用域注册表的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;filtering-the-list过滤列表&#34;&gt;Filtering the list(过滤列表) &lt;a href=&#34;#filtering-the-list%e8%bf%87%e6%bb%a4%e5%88%97%e8%a1%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;要缩小在列表面板中出现的包的范围，从&lt;strong&gt;包管理器&lt;/strong&gt;窗口选择&lt;strong&gt;过滤器&lt;/strong&gt;菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-filter2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;strong&gt;当你在导航面板中选择&lt;/strong&gt;项目中&lt;/strong&gt;时，过滤控制被禁用，因为&lt;strong&gt;项目中&lt;/strong&gt;有一个嵌套视图来列出有更新的包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-filter2b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;我的资源&lt;/strong&gt;列表为例，你可以使用以下类型的过滤选项来缩小显示的&lt;strong&gt;资产商店&lt;/strong&gt;包列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;状态&lt;/strong&gt;组让你选择一个&lt;strong&gt;状态&lt;/strong&gt;，列出具有该状态的包。例如，如果你选择&lt;strong&gt;未标记&lt;/strong&gt;，那么只有那些你从未分配标签的资产商店包将出现在列表中。&lt;/li&gt;
&lt;li&gt;选择一个或多个&lt;strong&gt;类别&lt;/strong&gt;，列出与你的选择匹配的资产商店包。&lt;/li&gt;
&lt;li&gt;选择一个或多个你在资产商店为你的包创建的自定义&lt;strong&gt;标签&lt;/strong&gt;。如果你选择了多于一个的标签，那么只有那些匹配任何一个标签的包会保留在列表中。关于如何创建和管理标签，请参考使用标签组织我的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你需要重新开始，点击&lt;strong&gt;过滤器&lt;/strong&gt;菜单旁的&lt;strong&gt;清除过滤器&lt;/strong&gt;，将所有过滤选项重置为默认值。&lt;/p&gt;
&lt;h1 id=&#34;search-box搜索框&#34;&gt;Search box(搜索框) &lt;a href=&#34;#search-box%e6%90%9c%e7%b4%a2%e6%a1%86&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;你可以在包管理器窗口的列表面板顶部的搜索框，用来查找任何与你输入的文本匹配的包或&lt;strong&gt;功能集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;随着你输入搜索文字，包管理器窗口更新列表，显示你在导航面板中选中的上下文每个匹配的包或功能集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以搜索Unity包和功能集或者&lt;strong&gt;资产商店&lt;/strong&gt;包。你选择的列表上下文定义了包管理器搜索的位置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;List context&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Where the Package Manager searches&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;In Project(项目中)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包缓存和你当前项目下的&lt;code&gt;Packages&lt;/code&gt;文件夹。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Unity Registry(Unity注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity注册表上的包和功能集列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Assets(我的资源)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;和你的Unity帐户可用的资产商店包列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Built-in(内置)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity注册表上的内置包列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Services(服务)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;你可以安装的集成服务列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;My Registries(我的注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;为你的项目定义的任何有限定范围的注册表。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：包管理器窗口会根据每个上下文记住你的搜索词。例如，如果你在&lt;strong&gt;项目中&lt;/strong&gt;设置了一个搜索词，包管理器窗口会过滤该列表。如果你选择了任何其他上下文，包管理器窗口会重置搜索并列出该上下文的所有包。但是，如果你返回到&lt;strong&gt;项目中&lt;/strong&gt;，包管理器窗口会恢复你的搜索词并再次过滤&lt;strong&gt;项目中&lt;/strong&gt;的列表。&lt;/p&gt;
&lt;p&gt;为了进一步说明这种每个上下文的搜索范围，如果你在不同的上下文中输入相同的搜索词，你将得到不同的结果。例如，如果你选择&lt;strong&gt;Unity注册表&lt;/strong&gt;上下文，然后在搜索框中输入&lt;code&gt;web&lt;/code&gt;，结果会与你选择&lt;strong&gt;内置&lt;/strong&gt;上下文并搜索同一词语时不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-search.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;你可以通过以下方式搜索包或功能集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其显示名称（如详细信息面板顶部所示）。&lt;/li&gt;
&lt;li&gt;其名称（ID）（仅限Unity包和功能集），这是以&lt;strong&gt;com.unity&lt;/strong&gt; 开头的注册包名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的搜索文本可以匹配名称的开头、中间或结尾。包管理器窗口会动态更新列表。&lt;/p&gt;
&lt;h1 id=&#34;install-a-feature-set-from-the-unity-registry从unity注册表安装功能集&#34;&gt;Install a feature set from the Unity registry(从Unity注册表安装功能集) &lt;a href=&#34;#install-a-feature-set-from-the-unity-registry%e4%bb%8eunity%e6%b3%a8%e5%86%8c%e8%a1%a8%e5%ae%89%e8%a3%85%e5%8a%9f%e8%83%bd%e9%9b%86&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;安装&lt;strong&gt;功能集&lt;/strong&gt; 与从Unity注册表安装包相似，只不过你在&lt;strong&gt;功能&lt;/strong&gt;扩展器下面而不是&lt;strong&gt;包&lt;/strong&gt;扩展器下面查找功能集。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口，从导航面板中选择&lt;strong&gt;Unity注册表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-unityregistry-1713439592232-69.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想要安装的功能集。功能集信息会在详情面板中显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选：在详情面板中点击&lt;strong&gt;快速启动&lt;/strong&gt;链接，了解更多关于这个功能集以及你如何共同使用其包的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在详情面板中，选择&lt;strong&gt;安装&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/fs-install.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注释:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你需要移除功能集，点击详情面板中的&lt;strong&gt;删除&lt;/strong&gt;按钮。&lt;/li&gt;
&lt;li&gt;你可以使用多选功能一键安装多个功能集。欲了解更多信息，请参考在多个包或功能集上执行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;install-a-package-from-a-registry从注册表安装包&#34;&gt;Install a package from a registry(从注册表安装包) &lt;a href=&#34;#install-a-package-from-a-registry%e4%bb%8e%e6%b3%a8%e5%86%8c%e8%a1%a8%e5%ae%89%e8%a3%85%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当你使用包管理器安装包时，包管理器会评估其他包及其依赖关系，以确定你选择的版本是否与其他版本有冲突。如果检测到任何冲突或限制，它将安装解决这些问题的版本。欲了解更多信息，请参考依赖关系与解析。&lt;/p&gt;
&lt;p&gt;从Unity注册表或你的项目中定义的任何作用域注册表安装包的过程是相同的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口，从导航面板中选择&lt;strong&gt;Unity注册表&lt;/strong&gt;。如果你设置了作用域注册表，并且想从作用域注册表安装包，请选择&lt;strong&gt;我的注册表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你没有为这个项目定义任何作用域注册表，那么导航面板中将不会显示&lt;strong&gt;我的注册表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-unityregistry-1713439596313-74.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想要安装的包。包信息将在详情面板中显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果包管理器没有在包列表中列出你想要安装的包，那可能是一个不可被发现的包，例如实验性质的或预发布的包。包管理器不会显示实验性质的包，除非它们已经被安装，但是在你启用预发布包项目设置后，预发布的包会在包管理器中显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择要安装的版本。如果你想要了解更多关于可用版本的信息，可以参考查找特定版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击&lt;strong&gt;安装&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-install.png&#34; alt=&#34;Install button in the corner of the details panel&#34;&gt;&lt;/p&gt;
&lt;p&gt;当进度条完成时，新的包就已经准备好可以使用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以使用多选功能一键安装多个包。欲了解更多信息，请参考在多个包或功能集上执行操作。&lt;/p&gt;
&lt;h1 id=&#34;install-a-package-from-a-local-folder从本地文件夹安装包&#34;&gt;Install a package from a local folder(从本地文件夹安装包) &lt;a href=&#34;#install-a-package-from-a-local-folder%e4%bb%8e%e6%9c%ac%e5%9c%b0%e6%96%87%e4%bb%b6%e5%a4%b9%e5%ae%89%e8%a3%85%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器可以从你电脑的任何位置加载包，即使你把它保存在你的Unity项目文件夹外面（例如，如果你有一个名为&lt;strong&gt;com.unity.my-local-package&lt;/strong&gt;的包，并且你把它保存在&lt;code&gt;桌面&lt;/code&gt;上，但你的Unity项目存放在&lt;code&gt;文档&lt;/code&gt;文件夹中）。&lt;/p&gt;
&lt;p&gt;你也可以使用你项目文件夹内的一个文件夹，只要它不是预留的项目子文件夹之一。&lt;/p&gt;
&lt;p&gt;要从本地磁盘安装包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开包管理器窗口，如果它还未打开的话。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击工具栏中的&lt;strong&gt;安装&lt;/strong&gt;按钮。安装包的选项将会出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-local.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从安装菜单中选择&lt;strong&gt;从磁盘安装包&lt;/strong&gt;，将会弹出一个文件浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导航到你的&lt;strong&gt;本地包&lt;/strong&gt;的文件夹根目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文件浏览器中双击 &lt;code&gt;package.json&lt;/code&gt; 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文件浏览器关闭，且该包现在会在包列表中出现，并带有标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-local-ver.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;请记住，如果你已经更新至注册表版本，但你在本地项目上做过更改，那么注册表版本将会覆盖你的本地更改。&lt;/p&gt;
&lt;h2 id=&#34;local-packages-inside-your-project项目内的本地包&#34;&gt;Local packages inside your project(项目内的本地包) &lt;a href=&#34;#local-packages-inside-your-project%e9%a1%b9%e7%9b%ae%e5%86%85%e7%9a%84%e6%9c%ac%e5%9c%b0%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你可以将本地包放置在项目内的任何地方，除了以下文件夹：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Project folder:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;Assets&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果你在这个文件夹内放置一个包，Asset Database会将这个文件夹下的任何资源导入两次：一次作为资源，一次作为包内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;Library&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要修改这个文件夹的内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;ProjectSettings&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个文件夹只用于存放设置资产。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;Packages&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果你在这个文件夹下放置一个包，不论&lt;strong&gt;项目清单&lt;/strong&gt;中的引用如何，包管理器会自动把它解释为&lt;strong&gt;嵌入包&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;install-a-package-from-a-local-tarball-file从本地tarball文件安装包&#34;&gt;Install a package from a local tarball file(从本地tarball文件安装包) &lt;a href=&#34;#install-a-package-from-a-local-tarball-file%e4%bb%8e%e6%9c%ac%e5%9c%b0tarball%e6%96%87%e4%bb%b6%e5%ae%89%e8%a3%85%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器可以从本地存储的tarball文件加载包。这适用于高级场景，其中你可以将包发布工作流分解成多部分，你的用户可以使用其中部分的中间产品。&lt;/p&gt;
&lt;p&gt;例如，如果你在你的自定义包仓库上设置了持续集成（CI），那么你可以从包文件夹创建一个Gzip tarball文件。你可以通过使用npm pack CLI或者Unity包管理器的Pack API来创建一个&lt;code&gt;Gzip&lt;/code&gt; tarball文件。如果你创建了一个&lt;code&gt;Gzip&lt;/code&gt; tarball文件，在你将其发布到自定义注册表之前进行测试。&lt;/p&gt;
&lt;p&gt;从本地tarball文件安装包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开包管理器窗口，如果它还未开启的话。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击工具栏中的&lt;strong&gt;安装&lt;/strong&gt;按钮。安装包的选项就会出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-tarball.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在安装菜单中选择 &lt;strong&gt;从tarball安装包&lt;/strong&gt; 以打开文件浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转到你保存tarball的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：只有具有&lt;code&gt;.tgz&lt;/code&gt;扩展名的tarballs，包管理器的文件选择对话框才能识别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文件选择对话框中双击tarball文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文件选择对话框将会关闭，现在包会带有标签出现在列表面板中。&lt;/p&gt;
&lt;h1 id=&#34;install-a-package-from-a-git-url从git-url安装包&#34;&gt;Install a package from a Git URL(从Git URL安装包) &lt;a href=&#34;#install-a-package-from-a-git-url%e4%bb%8egit-url%e5%ae%89%e8%a3%85%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器可以从远程服务器上的Git仓库加载包。&lt;/p&gt;
&lt;h2 id=&#34;prerequisites先决条件&#34;&gt;Prerequisites(先决条件) &lt;a href=&#34;#prerequisites%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在你的电脑上安装Git客户端（最低版本为2.14.0）。&lt;/li&gt;
&lt;li&gt;在Windows上，将Git可执行路径添加到&lt;code&gt;PATH&lt;/code&gt;系统环境变量。&lt;/li&gt;
&lt;li&gt;如果目标仓库使用Git LFS跟踪文件，需要在你的电脑上安装Git LFS客户端。&lt;/li&gt;
&lt;li&gt;阅读关于在项目中使用Git依赖项的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;procedure流程&#34;&gt;Procedure(流程) &lt;a href=&#34;#procedure%e6%b5%81%e7%a8%8b&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如需从Git URL安装包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开包管理器窗口，如果它还未开启的话。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在包管理器的工具栏中打开&lt;strong&gt;安装&lt;/strong&gt;菜单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装包的选项就会出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-giturl.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在安装菜单中选择 &lt;strong&gt;从git URL安装包&lt;/strong&gt;。文本框和&lt;strong&gt;安装&lt;/strong&gt;按钮将会出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文本框中输入一个有效的Git URL。关于如何构造有效的Git URL的信息，请参考以下内容：&lt;/p&gt;
&lt;p&gt;Git URLs和扩展语法&lt;/p&gt;
&lt;p&gt;. 有效的Git URL示例包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;https://github.example.com/myuser/myrepo.git&lt;/code&gt; （如果你的包在仓库的根目录中）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https://github.example.com/myuser/myrepo.git?path=/subfolder&lt;/code&gt; （如果你的包在仓库内的子文件夹中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;strong&gt;安装&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果Unity能够成功安装包，该包现在将会带有标签出现在包列表中。如果Unity无法安装包，Unity控制台将显示错误消息，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有找到‘Git’可执行程序&lt;/li&gt;
&lt;li&gt;Git-lfs：未找到命令&lt;/li&gt;
&lt;li&gt;未找到仓库&lt;/li&gt;
&lt;li&gt;无法读取用户名：终端提示被禁用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;点击错误消息链接在解决问题页面获取一些帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：如果你想检查更新并从仓库更新你的Git依赖项到最新版本，点击&lt;strong&gt;更新&lt;/strong&gt;。你也可以使用从git URL安装包菜单项来更新你的Git依赖项。关于Git依赖项的信息，请参阅已锁定的Git依赖项。&lt;/p&gt;
&lt;h1 id=&#34;install-a-package-from-a-registry-by-name通过名字从注册表中安装包&#34;&gt;Install a package from a registry by name(通过名字从注册表中安装包) &lt;a href=&#34;#install-a-package-from-a-registry-by-name%e9%80%9a%e8%bf%87%e5%90%8d%e5%ad%97%e4%bb%8e%e6%b3%a8%e5%86%8c%e8%a1%a8%e4%b8%ad%e5%ae%89%e8%a3%85%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果你知道你想安装的包的确切名称，你可以使用 &lt;strong&gt;按名称安装包&lt;/strong&gt; 选项进行安装。这是从注册表中安装包的一种快速方式。&lt;/p&gt;
&lt;p&gt;指定版本是可选的。如果你不知道要安装哪个版本，或者想安装最新的兼容版本，只需输入包的名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：最新的兼容版本可能不是最新发布的包。如果有一个已发布的包版本和一个更新的预发行或实验版本，包管理器会选择已发布的包版本，除非你在可选的 &lt;strong&gt;版本&lt;/strong&gt; 字段中明确输入一个值。&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin开始之前&#34;&gt;Before you begin(开始之前) &lt;a href=&#34;#before-you-begin%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;确保你知道包的名称。包的名字是一个唯一的标识符，而不是用户界面和文档上使用的显示名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-name-v-dname.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于Unity注册表中的包，名称的唯一标识符使用反向域名表示法，格式为 &lt;code&gt;com.unity.example&lt;/code&gt;。对于在范围内注册表中的包，名称可能不会遵循同样的模式。&lt;/p&gt;
&lt;p&gt;对于Unity注册表和你已添加的任何范围内注册表，如果你在包管理器中可以看到包，选择它并在&lt;strong&gt;检查器&lt;/strong&gt;窗口中查看其详细信息。&lt;strong&gt;名字&lt;/strong&gt;值就是包的名称。&lt;/p&gt;
&lt;p&gt;确定包名的其他方法因托管它的注册表的不同而不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于Unity注册表中的包:
&lt;ul&gt;
&lt;li&gt;使用已发布包和预发布包中的列表，通过其显示名称（如 &lt;code&gt;2D Animation&lt;/code&gt;）识别包。超链接值就是那个包的名称；在这个例子中，是&lt;code&gt;com.unity.2d.animation&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;包的文档可能有明确提供&lt;code&gt;名字&lt;/code&gt;值的安装说明。&lt;/li&gt;
&lt;li&gt;常常会在包文档URL的地址中嵌套包名。以&lt;strong&gt;AR&lt;/strong&gt;基础包为例，其包文档的URL是&lt;code&gt;https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html&lt;/code&gt;；&lt;code&gt;com.unity.xr.arfoundation&lt;/code&gt;这一部分就是该包的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于范围注册表中的包，如果你无法使用包管理器和检查器窗口确定其名称，联系包的创建者，请求包名。包的创建者在包的清单文件（&lt;code&gt;package.json&lt;/code&gt;）中将此值记录为必填属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;procedure流程-1&#34;&gt;Procedure(流程) &lt;a href=&#34;#procedure%e6%b5%81%e7%a8%8b-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;按名称安装注册表包，请按照以下步骤操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开包管理器窗口，如果它还未打开的话。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击工具栏中的 &lt;strong&gt;安装&lt;/strong&gt; 按钮。安装包的选项会出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-quick.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在安装菜单中选择 &lt;strong&gt;按名称安装包&lt;/strong&gt;。两个文本框和一个 &lt;strong&gt;安装&lt;/strong&gt; 按钮就会出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&amp;quot;开始前&amp;quot;部分确定的基础上，输入包的 &lt;strong&gt;名称&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-quick-add.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你输入了一个无效的包名或版本，包管理器会警告你找不到那个名称或版本。确认包的名称和版本是否正确，然后再试一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（可选）如果你知道要安装的版本，可以在 &lt;strong&gt;版本（可选）&lt;/strong&gt; 框中输入完整的包版本，例如 &lt;code&gt;1.3.0-pre.2&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;strong&gt;安装&lt;/strong&gt;。如果Unity能够成功安装包，该包现在就像任何其他从注册表安装的包一样出现在包列表中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此方法适用于当前托管在Unity包注册表或任何你已为当前项目设置的范围包注册表上的任何包和版本。&lt;/p&gt;
&lt;h1 id=&#34;removing-an-installed-package-from-a-project从项目中移除已安装的包&#34;&gt;Removing an installed package from a project(从项目中移除已安装的包) &lt;a href=&#34;#removing-an-installed-package-from-a-project%e4%bb%8e%e9%a1%b9%e7%9b%ae%e4%b8%ad%e7%a7%bb%e9%99%a4%e5%b7%b2%e5%ae%89%e8%a3%85%e7%9a%84%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你从项目中&amp;quot;移除&amp;quot;一个Unity注册表包或范围注册表包时，包管理器实际上是在移除你的project manifest中的项目&lt;strong&gt;直接依赖项&lt;/strong&gt;。移除直接依赖项的结果根据你要移除的包的依赖项而变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有其他的包或&lt;strong&gt;功能集&lt;/strong&gt;对此包有依赖，它实现的任何编辑器或运行时功能在你的项目中将不再可用。关于直接和&lt;strong&gt;间接依赖项&lt;/strong&gt;的更多信息，请参考依赖和解析。&lt;/li&gt;
&lt;li&gt;如果另一个已安装的包或一个已安装的功能集依赖于你试图移除的包，此操作只移除你的项目清单中的依赖项。包本身及其所有功能仍然在你的项目中安装，并在列表面板中显示依赖项图标。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;before-you-begin开始之前-1&#34;&gt;Before you begin(开始之前) &lt;a href=&#34;#before-you-begin%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在你开始之前，确保你了解这些重要的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只在你&lt;em&gt;安装&lt;/em&gt; 包到当前项目中时使用此程序来移除包，比如（但不限于）安装功能集，从注册表安装，和安装自定义包。不要试图使用此程序来：
&lt;ul&gt;
&lt;li&gt;移除你&lt;em&gt;下载&lt;/em&gt; &lt;em&gt;和&lt;/em&gt; &lt;em&gt;导入&lt;/em&gt; 到你的项目中的 &lt;strong&gt;Asset Store&lt;/strong&gt;包。关于移除你下载和导入的Asset Store包的信息，请参阅从项目中移除导入的资源。&lt;/li&gt;
&lt;li&gt;移除你&lt;em&gt;导入&lt;/em&gt; 到你的项目的本地 &lt;strong&gt;资源包&lt;/strong&gt;。关于移除你导入的本地资源包的信息，请参考移除本地资源包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果你使用此程序来移除你从注册表中安装的包，操作会从当前项目中移除包。它不会移除可能存在于其他项目中的同一包。它也不会从全局缓存中移除包；关于包管理器，不支持这个操作，手动操控全局缓存是不被鼓励的。&lt;/li&gt;
&lt;li&gt;如果你用这个程序来移除一个嵌入到你的项目中的包，包管理器会从你的电脑中删除整个包文件夹。然而，从任何其他来源（包括本地包）安装的包只移除清单中对包的引用，但是保持包本身及其内容完整。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;procedure流程-2&#34;&gt;Procedure(流程) &lt;a href=&#34;#procedure%e6%b5%81%e7%a8%8b-2&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要移除已安装的包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口，并从导航面板中选择 &lt;strong&gt;在项目中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-inproject.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想要移除的包。详细信息面板现在显示该包的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;strong&gt;移除&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果没有显示此按钮，你可能查看的是 &lt;strong&gt;我的资产&lt;/strong&gt; 列表。请参阅开始前。&lt;/p&gt;
&lt;p&gt;如果此按钮已禁用，你不能移除该包。更多信息，请参考锁定和不可移除的包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-remove.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想恢复已移除的包，按照安装包的说明进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以使用多选功能一次性移除多个包。更多信息，请参考在多个包或功能集上执行操作。&lt;/p&gt;
&lt;h2 id=&#34;locked-and-non-removable-packages锁定和无法移除的包&#34;&gt;Locked and non-removable packages(锁定和无法移除的包) &lt;a href=&#34;#locked-and-non-removable-packages%e9%94%81%e5%ae%9a%e5%92%8c%e6%97%a0%e6%b3%95%e7%a7%bb%e9%99%a4%e7%9a%84%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你只能移除那些未被其他的包或功能集要求的包。包管理器通过禁用所有被要求包的&lt;strong&gt;移除&lt;/strong&gt;按钮来强制执行此规定。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Required by&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A feature set(功能集)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果功能集需要此包，那么在列表面板和详细信息面板中都会显示一个锁定图标。详细信息面板还会在该面板的锁定图标下方显示需要此包的功能集的名称。然而，即使你点击了&lt;strong&gt;解锁&lt;/strong&gt;按钮，只有在你移除所有需要它的功能集之后，你才能从项目中移除这个包。解锁包使你可以为你的项目请求一个不同的版本，但它仍然不允许你移除它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Another package(另一个包)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果一个或多个包需要选中的包，&lt;strong&gt;移除&lt;/strong&gt;按钮就会被禁用。你可以从详细信息面板中的&lt;strong&gt;依赖项&lt;/strong&gt;选项卡中找到有依赖关系的包的名称。如果你不需要其他包，你可以移除它们，包管理器会自动同时移除这个包。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以使用多选功能一次性解锁多个包。更多信息，请参阅在多个包或功能集上执行操作。&lt;/p&gt;
&lt;h1 id=&#34;disabling-a-built-in-package禁用内置包&#34;&gt;Disabling a built-in package(禁用内置包) &lt;a href=&#34;#disabling-a-built-in-package%e7%a6%81%e7%94%a8%e5%86%85%e7%bd%ae%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果你不需要某些模块，想节省资源，你可以禁用&lt;strong&gt;内建包&lt;/strong&gt;。然而，当你禁用内建包时，相应的Unity功能将不再可用。&lt;/p&gt;
&lt;p&gt;禁用内建包将导致以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你使用了一个被禁用的包实现的脚本API，你会得到编译错误。&lt;/li&gt;
&lt;li&gt;被禁用的内建包实现的组件也会被禁用，这意味着你不能把它们添加到任何游戏对象上。如果你有一个&lt;strong&gt;游戏对象&lt;/strong&gt;已经有了这些组件中的一个，Unity会在播放模式中忽略它们。你可以在&lt;strong&gt;检查器&lt;/strong&gt;窗口中查看它们，但它们会显示为灰色，表示它们不可用。&lt;/li&gt;
&lt;li&gt;在构建游戏时，Unity会剔除所有禁用的组件。对于支持引擎代码剔除的构建目标（像Web，iOS，和Android），Unity不会添加任何来自被禁用的内建包的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要禁用内置包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口，从导航面板中选择 &lt;strong&gt;内置包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-builtin.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择你想要禁用的内置包。它的信息会显示在详细信息面板中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;strong&gt;禁用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-disable.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想要重新启用一个被禁用的内置包，点击 &lt;strong&gt;启用&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以使用多选功能一次点击禁用多个内置包。更多信息，请参阅在多个包或功能集上执行操作。&lt;/p&gt;
&lt;h1 id=&#34;switching-to-another-package-version切换至另一个包版本&#34;&gt;Switching to another package version(切换至另一个包版本) &lt;a href=&#34;#switching-to-another-package-version%e5%88%87%e6%8d%a2%e8%87%b3%e5%8f%a6%e4%b8%80%e4%b8%aa%e5%8c%85%e7%89%88%e6%9c%ac&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;使用此页面的信息来更新你从Unity注册表、范围注册表或本地源安装的包。&lt;/p&gt;
&lt;p&gt;如果你想要安装包的特定版本，参考按名称安装包，并按照其可选步骤指定版本。&lt;/p&gt;
&lt;p&gt;如果你想要更新从Git URL安装的包，你可以使用以下任意一种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口中定位到包，选择它，然后点击 &lt;strong&gt;更新&lt;/strong&gt; 按钮。&lt;/li&gt;
&lt;li&gt;使用新的修订版将包重新安装为Git依赖项。关于如何用 &lt;strong&gt;Git依赖项&lt;/strong&gt; 指定修订版的更多信息，参照定向至特定修订版。&lt;/li&gt;
&lt;li&gt;从Unity注册表重新安装包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要更新包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口，并从导航面板选择 &lt;strong&gt;在项目中&lt;/strong&gt;， &lt;strong&gt;Unity注册表&lt;/strong&gt;，或 &lt;strong&gt;我的注册表&lt;/strong&gt;。你也可以选择 &lt;strong&gt;更新&lt;/strong&gt; 条目，它列出了你的项目中所有有可用更新的包。箭头图标出现在有可用更新的包旁边。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想要更新的已安装的包。包信息显示在详细信息面板中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁定图标表示这个包和版本被锁定到已安装的 &lt;strong&gt;功能集&lt;/strong&gt;。要解锁包并选择另一个版本，点击 &lt;strong&gt;解锁&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：包暂时被解开。如果你在导航面板中选择了不同的上下文，或者关闭了 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口或Unity编辑器，包会恢复为锁定状态。然而，如果在包解锁时你更改了版本（例如，通过按名称从注册表安装包的方法），包保持解锁状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在包列表中选择一个包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-update-list.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在详细信息面板中，选择 &lt;strong&gt;版本历史&lt;/strong&gt; 标签。如果有多个版本可用，展开条目查看特定于每个版本的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-update-1713439625941-103.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;strong&gt;更新至#.#&lt;/strong&gt; 按钮，或者点击在 &lt;strong&gt;版本历史&lt;/strong&gt; 标签中列出的版本旁边的 &lt;strong&gt;更新&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;进度条完成时，任何新功能立即可用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你切换到包的旧版本，可能需要在包内容上运行API更新器。&lt;/li&gt;
&lt;li&gt;你可以使用多选功能一次点击切换多个包的版本。更多信息，请参考在多个包或功能集上执行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;importing-an-asset-store-package导入资源商店包&#34;&gt;Importing an Asset Store package(导入资源商店包) &lt;a href=&#34;#importing-an-asset-store-package%e5%af%bc%e5%85%a5%e8%b5%84%e6%ba%90%e5%95%86%e5%ba%97%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;你可以使用 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口将 &lt;strong&gt;资源商店&lt;/strong&gt; 包导入到你的项目中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 遵循此任务导入尚未在你的项目中的资源商店包。关于更新已经在你的项目中的资源商店包的信息，参阅更新资源商店包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 &lt;strong&gt;包管理器&lt;/strong&gt; 窗口，从导航面板中选择 &lt;strong&gt;我的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-myassets.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;列表面板显示你使用当前登录的Unity ID从资源商店获取的任何包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;strong&gt;我的资源&lt;/strong&gt; 列表中出现了很多资源商店的包，你可以通过名称搜索特定的资源商店包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想要导入的资源商店包。资源商店包的信息会显示在详细信息面板中。&lt;/p&gt;
&lt;p&gt;如果你之前没有在这台电脑或设备上下载过资源商店包， &lt;strong&gt;下载&lt;/strong&gt; 按钮会出现。否则，&lt;strong&gt;导入#.#到项目&lt;/strong&gt; 按钮会出现，你可以跳到步骤5立即导入资源商店包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在详细信息面板中出现 &lt;strong&gt;下载&lt;/strong&gt; 按钮，点击它以下载资源商店包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-import.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果下载按钮显示为 &lt;strong&gt;下载更新&lt;/strong&gt;，星号 (*) 表示在你的包缓存中有一个同版本号的旧版包。发布者随后发布了不改变版本号的包的更新版本。点击那个下载按钮获取包的最新版本。&lt;/p&gt;
&lt;p&gt;当资源商店包下载到你的电脑时，会出现一个进度条，&lt;strong&gt;暂停&lt;/strong&gt; 和 &lt;strong&gt;取消&lt;/strong&gt; 按钮会替换你点击的 &lt;strong&gt;下载&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这些按钮让你可以控制下载进度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击 &lt;strong&gt;暂停&lt;/strong&gt; 按钮以暂停下载。你可以点击 &lt;strong&gt;播放&lt;/strong&gt; 按钮以继续。&lt;/li&gt;
&lt;li&gt;点击 &lt;strong&gt;取消&lt;/strong&gt; 按钮以完全停止下载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载完成后，包管理器将 &lt;strong&gt;下载&lt;/strong&gt; 替换为一个包含 &lt;strong&gt;导入到项目&lt;/strong&gt; 和 &lt;strong&gt;重新下载&lt;/strong&gt; 操作的菜单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;strong&gt;导入到项目&lt;/strong&gt; 以导入所选资源商店包。&lt;/p&gt;
&lt;p&gt;如果资源商店包是一个完整的项目，会出现一个确认对话框。参考从资源商店导入完整项目。&lt;/p&gt;
&lt;p&gt;对于所有其他资源商店包，&lt;strong&gt;导入Unity包&lt;/strong&gt; 窗口会显示出来，所有项目都已选中且准备好导入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-import-assets.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除你不想导入的任何项目，然后点击 &lt;strong&gt;导入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;包管理器会把导入的资源商店包的内容放入 &lt;code&gt;Assets&lt;/code&gt; 文件夹，以便你可以从 &lt;strong&gt;项目&lt;/strong&gt; 窗口中访问它们。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当导入操作完成后，导入的包仍然在 &lt;strong&gt;我的资源&lt;/strong&gt; 列表中，但你也可以在 &lt;strong&gt;项目中&lt;/strong&gt; 列表中查看它。每当包有更新可用时，你可以在同样的列表中查看它，以及 &lt;strong&gt;更新&lt;/strong&gt; 列表中，它就在 &lt;strong&gt;项目中&lt;/strong&gt; 下面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：你可以通过使用多选功能一键下载多个包。有关更多信息，请参考执行多个包的操作。&lt;/p&gt;
&lt;h2 id=&#34;viewing-imported-assets查看导入的资源&#34;&gt;Viewing imported assets(查看导入的资源) &lt;a href=&#34;#viewing-imported-assets%e6%9f%a5%e7%9c%8b%e5%af%bc%e5%85%a5%e7%9a%84%e8%b5%84%e6%ba%90&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你导入资源商店包，或从资源商店包中的一部分资源后，你可以查看已导入资源的列表。&lt;/p&gt;
&lt;p&gt;查看已导入的资源有以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在导航面板中选择 &lt;strong&gt;我的资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在列表面板中选择包。&lt;/li&gt;
&lt;li&gt;在详细信息面板中选择 &lt;strong&gt;已导入资源&lt;/strong&gt; 标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;importing-a-complete-project-from-the-asset-store从资源商店导入完整的项目&#34;&gt;Importing a complete project from the Asset Store(从资源商店导入完整的项目) &lt;a href=&#34;#importing-a-complete-project-from-the-asset-store%e4%bb%8e%e8%b5%84%e6%ba%90%e5%95%86%e5%ba%97%e5%af%bc%e5%85%a5%e5%ae%8c%e6%95%b4%e7%9a%84%e9%a1%b9%e7%9b%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;完整的项目具有资源和&lt;strong&gt;项目设置&lt;/strong&gt;。导入完整项目的过程与其他资源商店包相似，除了多了关于项目设置的步骤。&lt;/p&gt;
&lt;p&gt;完整项目中的项目设置可能与你的项目设置冲突，所以当你从资源商店导入一个完整的项目时，包管理器会打开一个对话框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-import-project.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你确定要将包的资源添加到你的项目中，选择&lt;strong&gt;导入&lt;/strong&gt;。一个&lt;strong&gt;导入Unity包&lt;/strong&gt;窗口会出现，像下面的图片显示的那样。清除你不想导入的任何资产内容，然后点击&lt;strong&gt;下一步&lt;/strong&gt;。窗口的第二步列出了包的项目设置。如果你的项目中有任何这些项目设置，包管理器会用&lt;strong&gt;覆盖&lt;/strong&gt;标志来标识它们。除非你清除选择，否则这些设置将被包中的项目设置覆盖。清除你不想导入的任何项目设置，然后点击&lt;strong&gt;导入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你想在一个安全的环境中探索包的资源和项目设置，选择&lt;strong&gt;切换项目&lt;/strong&gt;。选择&lt;strong&gt;切换项目&lt;/strong&gt;将创建一个新的、临时的项目，只有该包的资源和项目设置。探索临时项目后，你可以不保存它然后关闭。如果你想在主项目中继续使用该包，则返回到主项目并再次导入包。在出现的警告对话框上选择&lt;strong&gt;导入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-import-assets2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;updating-an-asset-store-package更新资源商店的包&#34;&gt;Updating an Asset Store package(更新资源商店的包) &lt;a href=&#34;#updating-an-asset-store-package%e6%9b%b4%e6%96%b0%e8%b5%84%e6%ba%90%e5%95%86%e5%ba%97%e7%9a%84%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;你可以通过使用&lt;strong&gt;包管理器&lt;/strong&gt;窗口来更新&lt;strong&gt;资源商店&lt;/strong&gt;的包。&lt;/p&gt;
&lt;p&gt;**注意：**按照此任务来更新已经在你的项目中的资源商店包。如果你想了解关于导入还没有在你的项目中的资源商店包的信息，请参考导入资源商店包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口，并从导航面板选择&lt;strong&gt;我的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-myassets-1713439638777-118.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;任何有可用更新的资源商店包旁边都会出现一个向上指的箭头指示器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选：要以最近更新的资源商店包为主的列表，按照&lt;strong&gt;最近更新&lt;/strong&gt;排列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-update2-sort.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从包列表中选择你想更新的资源商店包。资源商店包的信息会在详细面板中显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选：选择&lt;strong&gt;发布&lt;/strong&gt;标签以查看包最新版本的变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-update-rel.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击&lt;strong&gt;下载更新&lt;/strong&gt;按钮。&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果下载按钮显示为&lt;strong&gt;下载更新&lt;/strong&gt;，星号(*)意味着你的包缓存中有一个相同版本号的旧版本包。发布者随后发布了新版本的包，但没有改变其版本号。点击下载按钮可以获取包的最新版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你下载的包的版本与你的Unity编辑器版本不兼容，详细面板中会出现一条消息，附带有一个&lt;strong&gt;更新&lt;/strong&gt;按钮，让你下载包的兼容版本。&lt;/p&gt;
&lt;p&gt;不兼容版本的&lt;strong&gt;更新&lt;/strong&gt;按钮&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要使用前一步中下载的包来更新你的项目，选择&lt;strong&gt;导入更新至项目&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;remove-imported-assets-from-a-project从项目中移除已导入的资产&#34;&gt;Remove imported assets from a project(从项目中移除已导入的资产) &lt;a href=&#34;#remove-imported-assets-from-a-project%e4%bb%8e%e9%a1%b9%e7%9b%ae%e4%b8%ad%e7%a7%bb%e9%99%a4%e5%b7%b2%e5%af%bc%e5%85%a5%e7%9a%84%e8%b5%84%e4%ba%a7&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你导入&lt;strong&gt;资产商店&lt;/strong&gt;中的资产时，Unity包管理器会将它们放在你的项目的&lt;code&gt;Assets&lt;/code&gt;目录中。&lt;/p&gt;
&lt;p&gt;如果你知道某些资产没有被使用，你可以从项目中移除这些资产。你可能会考虑这样做是为了减少项目目录的混乱或释放你的本地硬盘空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：确保你的项目不再使用任何你要移除的资产。&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin开始之前-2&#34;&gt;Before you begin(开始之前) &lt;a href=&#34;#before-you-begin%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d-2&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在开始之前，请确保你明白以下重要注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只有当你按照“导入资产商店包”的步骤导入了这些资产到当前项目时，才按照此流程去移除资产。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要试图使用此流程来移除你从注册表中&lt;em&gt;安装&lt;/em&gt;的包。关于从项目中移除你从注册表中安装的包的信息，请参考“从项目中移除已安装的包”。&lt;/li&gt;
&lt;li&gt;不要试图使用此流程来移除你从本地资产包中&lt;em&gt;导入&lt;/em&gt;后的资产。关于删除你从本地资产包中导入的资产的信息，请参考“删除本地资产包”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此流程将资产从当前项目中移除。它不会移除可能存在于其他项目中的同样的资产。它也不会从资产商店缓存中移除包。为了完全从你的电脑中移除资产商店包和其资产，你必须从多个位置移除它们：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用下列流程将每个使用这些资产的项目中的资产移除。&lt;/li&gt;
&lt;li&gt;从你的资产商店缓存中删除此包。请参考“从资产商店缓存中删除一个包”。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;procedure流程-3&#34;&gt;Procedure(流程) &lt;a href=&#34;#procedure%e6%b5%81%e7%a8%8b-3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要从你的项目中移除已导入的资产：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开你的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口，并从导航面板中选择&lt;strong&gt;我的资源&lt;/strong&gt;或&lt;strong&gt;项目中的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择你想要从你的项目中移除的资源商店包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开详细面板右上角的菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-details-menu.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;strong&gt;从项目中移除资产&lt;/strong&gt;来打开&lt;strong&gt;移除&lt;/strong&gt;对话框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-remove-assets.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择要移除的资产。你可以用&lt;strong&gt;全部&lt;/strong&gt;来移除所有资产，或者你可以使用复选框来选择一部分资产。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;strong&gt;移除&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖于已删除资产的&lt;strong&gt;场景&lt;/strong&gt;在&lt;strong&gt;控制台&lt;/strong&gt;窗口中不会报告为错误。如果你怀疑移除操作造成问题，请重新导入包。参考导入资源商店包。&lt;/li&gt;
&lt;li&gt;从你的项目中移除的资产仍会保留在我的资产列表中。要从&lt;strong&gt;我的资产&lt;/strong&gt;中移除这些资产，请参考从资源商店缓存中删除包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你删除了一部分资产，你可以通过在详细面板中选择&lt;strong&gt;已导入的资产&lt;/strong&gt;标签来查看剩余资产的列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-ui-imported-assets.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;delete-a-package-from-the-asset-store-cache从资产商店缓存中删除包&#34;&gt;Delete a package from the Asset Store cache(从资产商店缓存中删除包) &lt;a href=&#34;#delete-a-package-from-the-asset-store-cache%e4%bb%8e%e8%b5%84%e4%ba%a7%e5%95%86%e5%ba%97%e7%bc%93%e5%ad%98%e4%b8%ad%e5%88%a0%e9%99%a4%e5%8c%85&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你下载一个&lt;code&gt;.unitypackage&lt;/code&gt;文件时，Unity包管理器会将其存储在&lt;strong&gt;资产商店&lt;/strong&gt;缓存中。每次你导入一个下载的包或自定义包时，Unity包管理器都会将其存储在你项目的&lt;code&gt;Assets&lt;/code&gt;目录中。&lt;/p&gt;
&lt;p&gt;你可能想要从资产商店缓存中删除包以释放你本地硬盘的空间。如果硬盘空间是你从资产商店缓存中删除包的主要原因，可以考虑改变资产商店缓存的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：从资产商店缓存中删除包并不会从使用该包的任何项目中移除同一包。如果你也想从一个项目中移除同一的包，参考从项目中移除已导入的资产。&lt;/p&gt;
&lt;p&gt;要从资产商店缓存中删除包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开&lt;strong&gt;包管理器&lt;/strong&gt;窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在导航面板中选择&lt;strong&gt;我的资产&lt;/strong&gt;上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在列表面板中选择你想要删除的包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意两个重要的值，你在后续步骤中需要它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发行商的名字，位于&lt;strong&gt;包管理器&lt;/strong&gt;窗口详细面板下的显示名字下方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;显示名字&lt;/strong&gt;值，位于&lt;em&gt;&lt;strong&gt;检视器&lt;/strong&gt;&lt;/em&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-details-and-inspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转到资产商店缓存目录的根目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于Unity编辑器2022.1或更高版本：&lt;/p&gt;
&lt;p&gt;a) 打开Unity编辑器的首选项窗口。&lt;/p&gt;
&lt;p&gt;b) 选择&lt;strong&gt;包管理器&lt;/strong&gt;类别。&lt;/p&gt;
&lt;p&gt;c)  点击&lt;strong&gt;My Assets&lt;/strong&gt; &amp;gt; &lt;strong&gt;Cache Location&lt;/strong&gt;图标.&lt;/p&gt;
&lt;p&gt;d) 选择&lt;strong&gt;在Explorer中显示&lt;/strong&gt;（Windows）或&lt;strong&gt;在Finder中显示&lt;/strong&gt;（macOS）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于Unity编辑器2021.3或更早版本：&lt;/p&gt;
&lt;p&gt;a) 参考下载的资产文件的位置，确定你的操作系统的缓存位置。&lt;/p&gt;
&lt;p&gt;b) 使用你的操作系统的文件管理器应用程序转到该目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择与发行商名称相对应的子目录，这是你在前面的步骤中记录的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-as-cache.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发行商的目录有一个或多个子目录。发行商决定这些子目录的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有一个子目录，进入它。&lt;/li&gt;
&lt;li&gt;如果有多个子目录，浏览子目录，直到你找到包含要删除的包的子目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;code&gt;&amp;lt;name&amp;gt;.unitypackage&lt;/code&gt;文件，其中&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;对应于你在前面的步骤中确定的&lt;strong&gt;检视器&lt;/strong&gt;窗口的&lt;strong&gt;显示名字&lt;/strong&gt;值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个包现在已经从资产商店缓存中移除，但任何已导入的资产仍在使用它们的项目中保留。&lt;/p&gt;
&lt;h2 id=&#34;adding-the-deleted-package-back-to-your-asset-store-cache将删除的包重新添加到你的资产商店缓存中&#34;&gt;Adding the deleted package back to your Asset Store cache(将删除的包重新添加到你的资产商店缓存中) &lt;a href=&#34;#adding-the-deleted-package-back-to-your-asset-store-cache%e5%b0%86%e5%88%a0%e9%99%a4%e7%9a%84%e5%8c%85%e9%87%8d%e6%96%b0%e6%b7%bb%e5%8a%a0%e5%88%b0%e4%bd%a0%e7%9a%84%e8%b5%84%e4%ba%a7%e5%95%86%e5%ba%97%e7%bc%93%e5%ad%98%e4%b8%ad&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如果你删除的包是一个资产商店的包，并且你想要将此包重新添加到资产商店的缓存中，参见导入资产商店包。&lt;/p&gt;
&lt;h1 id=&#34;perform-an-action-on-multiple-packages对多个包执行操作&#34;&gt;Perform an action on multiple packages(对多个包执行操作) &lt;a href=&#34;#perform-an-action-on-multiple-packages%e5%af%b9%e5%a4%9a%e4%b8%aa%e5%8c%85%e6%89%a7%e8%a1%8c%e6%93%8d%e4%bd%9c&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;你可以在包管理器的列表面板中选择多个包或&lt;strong&gt;特性集&lt;/strong&gt;，并一次性对所有选定的项目执行操作。&lt;/p&gt;
&lt;p&gt;例如，你可以使用此功能一次性更新多个包至其最新版本。&lt;/p&gt;
&lt;p&gt;以下表格列出了你可以用来选择多个项目的快捷方式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Selection type&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Keyboard shortcut&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择列表中的所有项目&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Command + a (macOS) 或 Ctrl + a (Windows和Linux).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用键盘和鼠标选择一个范围&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择范围内的第一项，按住Shift键，然后选择范围内的最后一项.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用箭头键选择一个范围&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择范围内的第一项，按住Shift键，然后使用向上箭头键或向下箭头键扩大范围.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择不是一起分组的多个项目&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择一项，按住Command(macOS)或Ctrl（Windows或Linux），然后选择其他项目.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如需对多个包或特性集执行操作，请按照以下步骤操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开Package Manager窗口，从导航面板中选择一个上下文.&lt;/li&gt;
&lt;li&gt;可选：使用过滤控件来缩小列表.&lt;/li&gt;
&lt;li&gt;可选：使用排序控件对列表进行排序.&lt;/li&gt;
&lt;li&gt;使用上面表格中的其中一种快捷方式从列表中选择多个包或特性集.&lt;/li&gt;
&lt;li&gt;可选：在详细信息面板中打开展开器，查看有关所选项的更多信息，例如包的版本号.&lt;/li&gt;
&lt;li&gt;点击详细信息面板中的操作按钮，在所选项目上执行该操作.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/package-manager-multi-select.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：如果你在 &lt;strong&gt;我的资产&lt;/strong&gt; 列表中选择了多个包，以下操作将无法执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入到项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将更新导入到项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重新下载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下载更新&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;finding-package-documentation寻找包文档&#34;&gt;Finding package documentation(寻找包文档) &lt;a href=&#34;#finding-package-documentation%e5%af%bb%e6%89%be%e5%8c%85%e6%96%87%e6%a1%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Unity手册为特定版本的Unity提供文档。对于包文档，每个包都有自己的版本，因此每个包都为该包的特定版本提供文档。因此，包文档不是主要的Unity手册文档的一部分。相反，每个包的文档都在Unity的文档服务器上的自己的网站上。&lt;/p&gt;
&lt;p&gt;要访问特定包的文档，你有两个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取最新版本的文档。&lt;/li&gt;
&lt;li&gt;获取特定包版本的文档（从包管理器窗口）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当包页面打开时，页面顶部有四个链接**(A)&lt;strong&gt;，以及一个下拉菜单&lt;/strong&gt;(B)**，你可以在其中选择不同的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-docs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用页面顶部的链接查看包的核心使用（&lt;strong&gt;手册&lt;/strong&gt;），包的&lt;strong&gt;脚本API&lt;/strong&gt;文档，包的&lt;strong&gt;变更日志&lt;/strong&gt;，以及包的&lt;strong&gt;许可&lt;/strong&gt;信息。&lt;/p&gt;
&lt;h2 id=&#34;getting-documentation-for-the-latest-version获取最新版本的文档&#34;&gt;Getting documentation for the latest version(获取最新版本的文档) &lt;a href=&#34;#getting-documentation-for-the-latest-version%e8%8e%b7%e5%8f%96%e6%9c%80%e6%96%b0%e7%89%88%e6%9c%ac%e7%9a%84%e6%96%87%e6%a1%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;每个版本的Unity手册文档都提供了已发布和预发布包的列表，内置包的列表，以及按关键字列出的包的列表。每个列表都有链接到与该版本的Unity匹配的包文档。&lt;strong&gt;注意&lt;/strong&gt;：只有与文档匹配的Unity版本兼容的包才会出现在这些列表中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-4/upm-docs-list.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;你可以展开侧边栏导航**(A)&lt;strong&gt;中的条目以获取每个包的特定信息。包括兼容版本列表，包的简短说明，和任何相关的关键字。或者，你可以点击列表页&lt;/strong&gt;(B)**上的链接，直接打开与文档版本匹配的最兼容的包文档版本。&lt;/p&gt;
&lt;p&gt;如果你在此列表中找不到你想要的包，可能有几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它与这个版本的Unity不兼容。&lt;/li&gt;
&lt;li&gt;它是一个实验性的或私有的包。有些包由Unity以外的人开发，或者它们在特殊许可证下，不能对所有人开放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于在另一个Unity版本中发布的包，你可能可以通过包管理器窗口访问文档。对于私有包，请尝试直接联系开发者请求访问。&lt;/p&gt;
&lt;h2 id=&#34;getting-documentation-for-a-specific-package-version获取特定包版本的文档&#34;&gt;Getting documentation for a specific package version(获取特定包版本的文档) &lt;a href=&#34;#getting-documentation-for-a-specific-package-version%e8%8e%b7%e5%8f%96%e7%89%b9%e5%ae%9a%e5%8c%85%e7%89%88%e6%9c%ac%e7%9a%84%e6%96%87%e6%a1%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你可以通过查看其文档，变更日志或许可信息，了解更多来自注册表（非资产商店）的包的信息。&lt;/p&gt;
&lt;p&gt;要访问任何这些页面，你可以点击包管理器窗口内的&lt;strong&gt;文档&lt;/strong&gt;，&lt;strong&gt;变更日志&lt;/strong&gt;，或&lt;strong&gt;许可&lt;/strong&gt;链接。&lt;/p&gt;
&lt;p&gt;要访问特定包版本的文档：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Unity中打开包管理器窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遵循在寻找包中的指南，定位你想要的特定包和版本号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击&lt;strong&gt;文档&lt;/strong&gt;链接，打开所选版本包的文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果已安装包，你可以右键点击&lt;strong&gt;文档&lt;/strong&gt;，&lt;strong&gt;变更日志&lt;/strong&gt;或&lt;strong&gt;许可&lt;/strong&gt;链接，并选择&lt;strong&gt;本地打开&lt;/strong&gt;。包管理器会在适当的文件夹打开你的文件浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以按照这个流程查找来自注册表（非资产商店）的任何版本的包。请注意，对于每个包版本的发布，文档并不一定是不同的，因为有些版本更新（补丁）只涉及到错误修复或微小的更改。&lt;/p&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论 &lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;搬砖愉快！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity中文版-Unity&#39;s Package Manager(二)(自翻译)</title>
      <link>https://www.chenqiaoqian.com/2023/07/19/2023-07-19-unity-Documents-3/</link>
      <pubDate>Wed, 19 Jul 2023 11:13:34 +0800</pubDate>
      
      <guid>https://www.chenqiaoqian.com/2023/07/19/2023-07-19-unity-Documents-3/</guid>
      <description>&lt;p&gt;翻译Unity中文版的初衷是因为官方提供的中文版存在缺陷，而且翻译的不全。现在基于Unity2023.2版本对官方文档进行翻译。&lt;/p&gt;
&lt;h1 id=&#34;unitys-package-manager二&#34;&gt;Unity’s Package Manager(二) &lt;a href=&#34;#unitys-package-manager%e4%ba%8c&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&#34;configuration配置&#34;&gt;Configuration(配置) &lt;a href=&#34;#configuration%e9%85%8d%e7%bd%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;本节将向您展示如何针对PackageManager进行以下配置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络配置：绕过防火墙并设置代理服务器&lt;/li&gt;
&lt;li&gt;有范围的注册表身份验证：为需要此项的任何范围内的程序包注册表服务器创建并提供身份验证令牌&lt;/li&gt;
&lt;li&gt;定制全局缓存：更改全局缓存文件夹的位置以及注册表数据缓存的最大大小&lt;/li&gt;
&lt;li&gt;定制资产商店缓存位置：更改&lt;strong&gt;Asset Store&lt;/strong&gt;程序包缓存文件夹的位置&lt;/li&gt;
&lt;li&gt;使用HTTPS Git URLs的私有仓库：使用Git凭证助手访问通过HTTPS进行的私有仓库&lt;/li&gt;
&lt;li&gt;使用SSH Git URLs的有密码保护的SSH密钥：使用认证代理访问通过SSH进行的私有仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，您可以在配置文件下找到PackageManager配置文件的位置。&lt;/p&gt;
&lt;h2 id=&#34;configuration-files配置文件&#34;&gt;Configuration files(配置文件) &lt;a href=&#34;#configuration-files%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;PackageManager支持两种配置文件：全局配置文件和用户配置文件。这两种文件都使用TOML格式，并且它们出现在不同的位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局&lt;/strong&gt;配置文件适用于机器上的所有用户。例如，当为整个机器设置代理服务器时，您可以定义额外的SSL证书机构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt;配置文件适用于单个用户。例如，您可以设置用于使用有范围的注册表访问的自定义包注册服务器的认证令牌。这些令牌验证了特定的用户账户。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;global-configuration-file-location全局配置文件位置&#34;&gt;Global configuration file location(全局配置文件位置) &lt;a href=&#34;#global-configuration-file-location%e5%85%a8%e5%b1%80%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e4%bd%8d%e7%bd%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;PackageManager使用名为&lt;code&gt;upmconfig.toml&lt;/code&gt;的全局配置文件。安装Unity Hub或Editor时，此文件不会被创建，但如果你需要自定义你的配置，你可以在以下位置创建它：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Environment:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Location:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Windows&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;%ALLUSERSPROFILE%\Unity\config\upmconfig.toml&lt;/code&gt; (for example, &lt;code&gt;C:\ProgramData\Unity\config\upmconfig.toml&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;macOS and Linux&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;/etc/upmconfig.toml&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;你可以定义一个自定义位置来覆盖你的配置文件的默认位置。要做到这一点，创建一个&lt;code&gt;UPM_GLOBAL_CONFIG_FILE&lt;/code&gt;环境变量，并将其值设置为你的配置文件的绝对路径，包括文件名。&lt;/p&gt;
&lt;h3 id=&#34;user-configuration-file-location用户配置文件位置&#34;&gt;User configuration file location(用户配置文件位置) &lt;a href=&#34;#user-configuration-file-location%e7%94%a8%e6%88%b7%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e4%bd%8d%e7%bd%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;PackageManager使用名为&lt;code&gt;.upmconfig.toml&lt;/code&gt;的用户配置文件。当你安装Unity Hub或Editor时，该文件并不被创建，但如果你需要自定义你的配置，你可以在下列位置创建它：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Environment:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Location:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Windows (user account)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;%USERPROFILE%\.upmconfig.toml&lt;/code&gt; (for example, &lt;code&gt;C:\Users\myusername\.upmconfig.toml&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Windows (system user account)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;%ALLUSERSPROFILE%\Unity\config\ServiceAccounts\.upmconfig.toml&lt;/code&gt; (for example, &lt;code&gt;C:\Users\Public\Unity\config\ServiceAccounts\.upmconfig.toml&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;macOS and Linux&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~/.upmconfig.toml&lt;/code&gt; (for example, &lt;code&gt;/Users/myusername/.upmconfig.toml&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;你可以定义一个自定义位置来覆盖你的配置文件的默认位置。要做到这一点，创建一个&lt;code&gt;UPM_USER_CONFIG_FILE&lt;/code&gt;环境变量，并将其值设置为你的配置文件的绝对路径，包括文件名。&lt;/p&gt;
&lt;h1 id=&#34;solving-network-issues解决网络问题&#34;&gt;Solving network issues(解决网络问题) &lt;a href=&#34;#solving-network-issues%e8%a7%a3%e5%86%b3%e7%bd%91%e7%bb%9c%e9%97%ae%e9%a2%98&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;使用以下步骤来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置你的防火墙设置，使Unity可以访问PackageManager注册服务器。&lt;/li&gt;
&lt;li&gt;配置代理服务器，可以通过设置环境变量或添加自定义证书颁发机构(CA)证书来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;configuring-your-firewall配置你的防火墙&#34;&gt;Configuring your firewall(配置你的防火墙) &lt;a href=&#34;#configuring-your-firewall%e9%85%8d%e7%bd%ae%e4%bd%a0%e7%9a%84%e9%98%b2%e7%81%ab%e5%a2%99&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;为确保Unity的PackageManager可以访问其使用的域名，你必须将这些域名添加到防火墙的安全列表。&lt;/p&gt;
&lt;p&gt;关于这些域名的完整列表，以及Unity编辑器所需的所有域名，请参考Unity应用程序可以访问的终端点。你可以使用列表添加整个域名，或使用表格选择性地添加子域名。&lt;/p&gt;
&lt;p&gt;请参考你的操作系统的帮助，了解如何将域名添加到防火墙的安全列表。&lt;/p&gt;
&lt;h2 id=&#34;configuring-your-proxy-server配置你的代理服务器&#34;&gt;Configuring your proxy server(配置你的代理服务器) &lt;a href=&#34;#configuring-your-proxy-server%e9%85%8d%e7%bd%ae%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;当使用代理服务器时，配置&lt;code&gt;HTTP_PROXY&lt;/code&gt;和&lt;code&gt;HTTPS_PROXY&lt;/code&gt;环境变量，供Unity的PackageManager在对Unity包注册表执行请求时使用。更多信息，请参考使用环境变量来识别你的代理服务器。&lt;/p&gt;
&lt;p&gt;你可以根据你的操作系统，全局设置这些变量（系统变量或用户变量）。或者，你也可以创建一个命令文件来设置这些环境变量并启动Hub。&lt;/p&gt;
&lt;p&gt;对于你在一个使用PackageManager不识别的证书的代理服务器后面的环境，你可以配置一个自定义证书颁发机构。&lt;/p&gt;
&lt;h3 id=&#34;custom-certificate-authority自定义证书颁发机构&#34;&gt;Custom certificate authority(自定义证书颁发机构) &lt;a href=&#34;#custom-certificate-authority%e8%87%aa%e5%ae%9a%e4%b9%89%e8%af%81%e4%b9%a6%e9%a2%81%e5%8f%91%e6%9c%ba%e6%9e%84&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在一些组织中，用户只能通过代理服务器访问互联网。一些代理会解开HTTPS内容，然后用他们自己的SSL证书重新打包。Unity包管理器的底层HTTPS层有时会拒绝这些证书，因为它不认可发出这些证书的证书颁发机构。当这种情况发生时，PackageManager会将连接视为可能的中间人攻击(MITM)。这意味着，除非你配置额外的SSL证书颁发机构来允许这些证书，否则你无法使用Unity中的许多功能，包括PackageManager。&lt;/p&gt;
&lt;p&gt;要配置额外的SSL证书颁发机构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定位&lt;code&gt;upmconfig.toml&lt;/code&gt;全局配置文件。如果文件不存在，创建一个空的文本文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个包含一个或多个自定义证书颁发机构的证书的文本文件。文件必须由一个或多个受信任的证书组成，证书格式为Privacy-Enhanced Mail (PEM)。例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-pem&#34; data-lang=&#34;pem&#34;&gt;-----BEGIN CERTIFICATE-----
MIIC+zCCAeOgAwIBAgIJAO0U6hVJnbvjMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV
BAMMCWxvY2FsaG9zdDAeFw0xOTAzMTIwMTIxMzRaFw0yOTAzMDkwMTIxMzRaMBQx
(additional lines omitted for conciseness)
LFwHSUdqk0lJK4b0mCwyTHNvYO1IDziE5EKwfuaKVgOa62iCHVahgIVa+een4EfS
hCCr3M3cq11Mi+mnRi1scxxrOno4OEEChWg2szZLlxBrkVJllrrq620XJ6RLB/8=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBl
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
(additional lines omitted for conciseness)
H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe
+o0bJW1sj6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果可能的话，将此文件保存到与全局配置文件相同的文件夹中，虽然Unity支持在文件系统的任何位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在全局配置文件中，添加&lt;strong&gt;caFile&lt;/strong&gt;键，并将其值设置为你的PEM文件的绝对文件路径。&lt;strong&gt;重要提示&lt;/strong&gt;：在TOML文件中设置Windows路径时，使用正斜杠(&lt;code&gt;/&lt;/code&gt;)或双反斜杠(&lt;code&gt;\\&lt;/code&gt;)。不要使用单反斜杠(&lt;code&gt;\&lt;/code&gt;)，因为它们是标记转义序列的特殊字符，可能会导致TOML解析错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows example&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;caFile&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\\ProgramData\\Unity\\config\\cert.pem&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;macOS and Linux example&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;caFile&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/etc/cert.pem&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;scoped-registry-authentication限定范围的注册表身份验证&#34;&gt;Scoped registry authentication(限定范围的注册表身份验证) &lt;a href=&#34;#scoped-registry-authentication%e9%99%90%e5%ae%9a%e8%8c%83%e5%9b%b4%e7%9a%84%e6%b3%a8%e5%86%8c%e8%a1%a8%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;一些组织在需要身份验证才能访问的私有包注册表上托管他们自己的包。如果你是这些组织的员工或客户，你必须配置一个带有npm身份验证的限定范围的注册表。为了建立这个，获取一个npm身份验证令牌，然后将该令牌添加到你的用户配置文件中。&lt;/p&gt;
&lt;h2 id=&#34;1-fetch-the-npm-authentication-token获取npm身份验证令牌&#34;&gt;1) Fetch the npm authentication token(获取npm身份验证令牌) &lt;a href=&#34;#1-fetch-the-npm-authentication-token%e8%8e%b7%e5%8f%96npm%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e4%bb%a4%e7%89%8c&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;创建和访问npm身份验证令牌的过程因每个注册表提供商而异。例如，JFrog的Artifactory仓库管理器生成身份验证令牌的程序与npm不同。这是一个典型程序的例子，但你需要遵循特定包注册表供应商为你的限定范围的注册表推荐的过程。&lt;/p&gt;
&lt;p&gt;要从npm获取身份验证令牌：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在你的计算机上本地安装npm。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从终端，输入以下命令来登录注册表：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ npm login --registry &amp;lt;registry url&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位并打开生成的.npmrc文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位&lt;code&gt;_authToken&lt;/code&gt;或&lt;code&gt;_auth&lt;/code&gt;条目，并复制其值（参阅下面的例子）。&lt;/p&gt;
&lt;p&gt;根据注册表，令牌字符串可以是全局唯一标识符（GUID）、令牌，或者是专有格式的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;examples-of-npmrc-filesnpmrc文件的示例&#34;&gt;Examples of .npmrc files(.npmrc文件的示例) &lt;a href=&#34;#examples-of-npmrc-filesnpmrc%e6%96%87%e4%bb%b6%e7%9a%84%e7%a4%ba%e4%be%8b&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这是一个包含&lt;code&gt;_authToken&lt;/code&gt;属性的&lt;code&gt;.npmrc&lt;/code&gt;文件的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;registry&lt;/span&gt;=&lt;span style=&#34;color:#a6e22e&#34;&gt;https&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;://&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mylocation&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mylocation&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/:&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_authToken&lt;/span&gt;=&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;AUTH&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TOKEN&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一个包含&lt;code&gt;_auth&lt;/code&gt;属性的&lt;code&gt;.npmrc&lt;/code&gt;文件的示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;registry&lt;/span&gt;=&lt;span style=&#34;color:#a6e22e&#34;&gt;https&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;://&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mylocation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_auth&lt;/span&gt;=&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;AUTH&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TOKEN&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt;=&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;EMAIL&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;always-auth&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-configure-authentication-information配置身份验证信息&#34;&gt;2) Configure authentication information(配置身份验证信息) &lt;a href=&#34;#2-configure-authentication-information%e9%85%8d%e7%bd%ae%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e4%bf%a1%e6%81%af&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;npmAuth&lt;/code&gt;配置模式在&lt;code&gt;.upmconfig.toml&lt;/code&gt;用户配置文件中存储每个需要身份验证的限定范围的注册表的令牌信息。当你把这个信息保存到配置文件后，包管理器会在向文件中的每个注册表发起的每个请求上提供你的身份验证信息。&lt;/p&gt;
&lt;p&gt;遵循这些指示将你的身份验证信息添加到用户配置文件中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定位&lt;code&gt;.upmconfig.toml&lt;/code&gt;用户配置文件。如果文件不存在，创建一个空的文本文件。&lt;/li&gt;
&lt;li&gt;根据你是否使用Bearer（基于令牌）或Basic（Base64加密）的身份验证机制，使用模式格式化你的身份验证信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;npmAuth&lt;/span&gt;.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;REGISTRY URL&amp;gt;&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TOKEN-PROPERTY&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;TOKEN-VALUE&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;EMAIL&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;alwaysAuth&lt;/span&gt; = &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;BOOLEAN&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下表中的信息解释了如何指定配置文件的值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Entry&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;[npmAuth.&amp;quot;&amp;lt;REGISTRY-URL&amp;gt;&amp;quot;]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要。注册表的URL。例如，&lt;code&gt;[npmAuth.&amp;quot;https://example.com:8081/mylocation&amp;quot;]&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;TOKEN-PROPERTY&amp;gt; = &amp;quot;&amp;lt;TOKEN-VALUE&amp;gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要。从npm注册表生成的身份验证令牌。这可以是GUID、令牌，或者是专有格式的字符串。例如，可以是&lt;code&gt;token = &amp;quot;&amp;lt;AUTH TOKEN&amp;gt;&amp;quot;&lt;/code&gt;（Bearer）或&lt;code&gt;_auth = &amp;quot;&amp;lt;BASE64 TOKEN&amp;gt;&amp;quot;&lt;/code&gt;（Basic）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;email&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可选。与注册表上用户邮箱地址匹配的用户邮箱地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;alwaysAuth&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可选。如果包元数据和压缩包不在同一服务器上，设置为&lt;code&gt;true&lt;/code&gt;。通常，你可以从你生成的.npmrc文件中复制这个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;example-using-bearer-authentication使用bearer身份验证的例子&#34;&gt;Example using bearer authentication(使用Bearer身份验证的例子) &lt;a href=&#34;#example-using-bearer-authentication%e4%bd%bf%e7%94%a8bearer%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e7%9a%84%e4%be%8b%e5%ad%90&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;npmAuth&lt;/span&gt;.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:8081/myrepository/mylocation&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NpmToken.2348c7ea-6f86-3dbe-86b6-f257e86569a8&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;alwaysAuth&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;npmAuth&lt;/span&gt;.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:4873&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eaJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyZWFsX2dyb3VwcyI6WyJwYXNjYWxsIl0sIm5hbWUiOiJwYXNjYWxsIiwiZ3JvdXBzIjpbIn&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;npmAuth&lt;/span&gt;.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://api.bintray.example/npm/mycompany/myregistry&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aGFzY2FsbDo4ZWIwNTM5NzBjNTI3OTIwYjQ4MDVkYzY2YWEzNmQxOTkyNDYzZjky&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;alwaysAuth&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;configure-basic-authentication-information配置基本身份验证信息&#34;&gt;Configure basic authentication information(配置基本身份验证信息) &lt;a href=&#34;#configure-basic-authentication-information%e9%85%8d%e7%bd%ae%e5%9f%ba%e6%9c%ac%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e4%bf%a1%e6%81%af&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这些步骤以Azure DevOps为例，但是对于任何使用个人访问令牌（PAT）的平台，流程都是类似的。&lt;/p&gt;
&lt;p&gt;开始前，如果还未安装Node.js，请进行安装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取你的Azure DevOps个人访问令牌（PAT），准备在后续步骤中使用。如果你需要重新生成PAT，请登录Azure DevOps &lt;a href=&#34;https://dev.azure.com/&#34;&gt;https://dev.azure.com&lt;/a&gt; 并前往 &lt;strong&gt;用户设置&lt;/strong&gt; &amp;gt; &lt;strong&gt;个人访问令牌&lt;/strong&gt;。关于如何使用PAT的信息，可以参考Microsoft的文章，使用个人访问令牌。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从命令行，运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;node -e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;require(&amp;#39;readline&amp;#39;).createInterface({input:process.stdin,output:process.stdout,historySize:0}).question(&amp;#39;Enter PAT&amp;gt; &amp;#39;,p =&amp;gt; {b64=Buffer.from(p.trim()).toString(&amp;#39;base64&amp;#39;);console.log(b64);process.exit();})&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;Enter PAT&lt;/code&gt;提示时，输入&lt;code&gt;email:PAT&lt;/code&gt;，将其替换为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;email&lt;/code&gt;替换为与你的Azure DevOps帐户关联的电子邮件和&lt;code&gt;.upmconfig.toml&lt;/code&gt;文件中指定的电子邮件&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;PAT&lt;/code&gt;替换为你在早期步骤中获得的PAT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令将返回一个Base64加密的字符串。复制该字符串并将其赋值为&lt;code&gt;.upmconfig.toml&lt;/code&gt;文件中的&lt;code&gt;_auth&lt;/code&gt;键的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;example-using-basic-authentication&#34;&gt;Example using basic authentication &lt;a href=&#34;#example-using-basic-authentication&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;npmAuth&lt;/span&gt;.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:8081/myrepository/mylocation&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_auth&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c19kaW5pcm9AaG90bWFpbC4jb206d3FzdzVhemU9Q==&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;email&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;alwaysAuth&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;customize-the-global-cache自定义全局缓存&#34;&gt;Customize the global cache(自定义全局缓存) &lt;a href=&#34;#customize-the-global-cache%e8%87%aa%e5%ae%9a%e4%b9%89%e5%85%a8%e5%b1%80%e7%bc%93%e5%ad%98&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器维护一个用于注册表数据和未压缩包的全局缓存。&lt;/p&gt;
&lt;p&gt;全局缓存与包管理器为 &lt;strong&gt;资源商店&lt;/strong&gt; 包维护的缓存是分开的。关于资源商店缓存的信息，请参考自定义资源商店缓存位置。&lt;/p&gt;
&lt;p&gt;默认情况下，包管理器的全局缓存根目录有以下子目录，每个子缓存有不同的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;db&lt;/code&gt;子目录存储注册表数据（包元数据和tarballs）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;packages&lt;/code&gt;子目录存储未压缩的包tarballs的内容。&lt;/li&gt;
&lt;li&gt;如果你已启用Git LFS，&lt;code&gt;git-lfs&lt;/code&gt;子目录会存储下载的Git大文件存储（LFS）文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包管理器将全局缓存存储在默认位置，你可以覆盖它。关于全局缓存根目录的默认位置的信息，请参考全局缓存。&lt;/p&gt;
&lt;p&gt;你可能出于以下几个原因想要覆盖全局缓存位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你想在你的内部驱动器上节省空间。&lt;/li&gt;
&lt;li&gt;你想在共享驱动器上存储缓存，以便其他人可以访问它。&lt;/li&gt;
&lt;li&gt;你想在非系统目录的文件夹中存储缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从2023.2.0f1开始，&lt;code&gt;db&lt;/code&gt;子目录的最大大小默认为10千兆字节（GB），你可以覆盖它。你可能出于以下几个原因想要覆盖&lt;code&gt;db&lt;/code&gt;子目录的最大大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的可用磁盘空间很小，你可以降低限制以节省空间。&lt;/li&gt;
&lt;li&gt;如果你有大量可用的磁盘空间，你可以增加限制。这允许包管理器在缓存中存储更多数据，这样它可以从缓存中获取包，而不是再次下载它们。缓存的包安装更快，减少了网络使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下表格列出了你可以用来覆盖默认属性的不同方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Method&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Global cache location&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;&lt;code&gt;db&lt;/code&gt; subdirectory max size&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Additional notes(额外说明)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Preferences window(偏好设置窗口)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Yes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;No&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这种方法因其易用性和持久性被推荐。当你使用这种方法更改包缓存位置时，Unity会为当前和未来的Unity编辑器会话存储偏好设置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;User configuration file(用户配置文件)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Yes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Yes&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用户配置文件中的包缓存属性覆盖会持续到当前Unity编辑器会话之后。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Environment variables(环境变量)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Yes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Yes&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;默认情况下，此方法为当前的命令提示符（或终端）会话设置配置，但你可以在你的操作系统设置中使其永久化。高级用户可能在特定用例下更喜欢基于会话的变量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：使用&lt;strong&gt;偏好设置&lt;/strong&gt;窗口设置全局缓存位置也会在用户配置文件中设置&lt;code&gt;cacheRoot&lt;/code&gt;属性。如果你想手动设置用户配置文件，请参考使用用户配置文件。&lt;/p&gt;
&lt;h2 id=&#34;important-notes-before-you-begin开始前的重要声明&#34;&gt;Important notes before you begin(开始前的重要声明) &lt;a href=&#34;#important-notes-before-you-begin%e5%bc%80%e5%a7%8b%e5%89%8d%e7%9a%84%e9%87%8d%e8%a6%81%e5%a3%b0%e6%98%8e&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无论你选择哪种方法，更改缓存位置都会告诉包管理器从此时开始使用该位置。包管理器在原始位置存储的现有包会保留在那个文件夹结构中。&lt;/li&gt;
&lt;li&gt;如果你设置了&lt;code&gt;db&lt;/code&gt;子目录的最大大小，且新大小小于该子目录的当前大小，包管理器会从缓存中逐出内容，直到达到新的限制。包管理器会按照最近最少使用的内容进行驱逐（基于安装到项目中的日期）。&lt;/li&gt;
&lt;li&gt;当你使用用户配置文件时，你的更改应用于当前的用户帐户。尽管存在全局配置文件，但你不能在全局配置文件中设置缓存覆盖。&lt;/li&gt;
&lt;li&gt;有一些因素会影响如何设置多个值与使用不同方法一起工作：
&lt;ul&gt;
&lt;li&gt;如果你使用了环境变量方法来更改缓存位置，那么你不能使用&lt;strong&gt;偏好设置&lt;/strong&gt;窗口来更改位置。&lt;/li&gt;
&lt;li&gt;设置环境变量优先于在用户配置文件或&lt;strong&gt;偏好设置&lt;/strong&gt;窗口中应用相同的设置。&lt;/li&gt;
&lt;li&gt;如果你为注册表数据缓存(&lt;code&gt;UPM_NPM_CACHE_PATH&lt;/code&gt;)、未压缩的包缓存(&lt;code&gt;UPM_CACHE_PATH&lt;/code&gt;)或Git LFS缓存(&lt;code&gt;UPM_GIT_LFS_CACHE_PATH&lt;/code&gt;)设置了环境变量，包管理器将使用环境变量设置的位置，而不管全局缓存根位置在哪里。&lt;/li&gt;
&lt;li&gt;如果你启用了Git LFS缓存(&lt;code&gt;UPM_ENABLE_GIT_LFS_CACHE&lt;/code&gt;)但没有明确设置其路径(&lt;code&gt;UPM_GIT_LFS_CACHE_PATH&lt;/code&gt;)，包管理器会使用全局缓存根下的&lt;code&gt;git-lfs&lt;/code&gt;目录作为其位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;using-the-preferences-window偏好设置窗口&#34;&gt;Using the Preferences window(偏好设置窗口) &lt;a href=&#34;#using-the-preferences-window%e5%81%8f%e5%a5%bd%e8%ae%be%e7%bd%ae%e7%aa%97%e5%8f%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;若要使用&lt;strong&gt;偏好设置&lt;/strong&gt;窗口来覆盖全局缓存的默认位置，请按照以下步骤操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用以下方法之一打开&lt;strong&gt;偏好设置&lt;/strong&gt;窗口：
&lt;ul&gt;
&lt;li&gt;使用Unity编辑器的菜单，如偏好设置中所述。&lt;/li&gt;
&lt;li&gt;打开包管理器窗口，打开&lt;strong&gt;高级&lt;/strong&gt; &lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/iconSettings.png&#34; alt=&#34;img&#34;&gt; 菜单，并选择&lt;strong&gt;偏好设置&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择&lt;strong&gt;包管理器&lt;/strong&gt;分类。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;包&lt;/strong&gt;下，打开&lt;strong&gt;缓存位置&lt;/strong&gt;旁边的菜单 &lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/package-manager-folder.png&#34; alt=&#34;img&#34;&gt;.&lt;/li&gt;
&lt;li&gt;选择&lt;strong&gt;更改位置&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为全局缓存选择一个新位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/preferences-package-manager.png&#34; alt=&#34;The Preferences window with the Package Manager category selected&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择了包管理器类别的偏好设定窗口&lt;/p&gt;
&lt;h2 id=&#34;using-the-user-configuration-file使用用户配置文件&#34;&gt;Using the user configuration file(使用用户配置文件) &lt;a href=&#34;#using-the-user-configuration-file%e4%bd%bf%e7%94%a8%e7%94%a8%e6%88%b7%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你可以手动编辑用户配置文件，以覆盖全局缓存根的位置，或&lt;code&gt;db&lt;/code&gt;子目录的最大大小，或两者都覆盖。&lt;/p&gt;
&lt;p&gt;按照以下步骤编辑用户配置文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定位&lt;code&gt;.upmconfig.toml&lt;/code&gt;用户配置文件。要找到文件位置，请参阅配置文件。如果文件不存在，则创建一个空文本文件。&lt;/li&gt;
&lt;li&gt;要覆盖全局缓存根的位置，添加&lt;code&gt;cacheRoot&lt;/code&gt;键，并将其值设置为自定义位置的绝对路径。&lt;strong&gt;重要提示&lt;/strong&gt;：在TOML文件中设置Windows路径时，使用正斜杠(&lt;code&gt;/&lt;/code&gt;)或双反斜杠(&lt;code&gt;\\&lt;/code&gt;)。不要使用单个反斜杠(&lt;code&gt;\&lt;/code&gt;)，因为它们是标记转义序列的特殊字符，可能导致TOML解析错误。&lt;/li&gt;
&lt;li&gt;要覆盖&lt;code&gt;db&lt;/code&gt;子目录的最大大小，添加&lt;code&gt;maxCacheSize&lt;/code&gt;键，并将其值设置为表示字节数的正整数。例如，要将大小设置为5GB，请赋值&lt;code&gt;5000000000&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在设置任一属性后，你无需重新启动Unity编辑器或Hub，更改即可生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows example&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cacheRoot&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;E:\\Unity\\cache&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maxCacheSize&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;5000000000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;macOS and Linux example&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cacheRoot&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/dev/external/shared/Unity/cache&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maxCacheSize&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;5000000000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;using-environment-variables使用环境变量&#34;&gt;Using environment variables(使用环境变量) &lt;a href=&#34;#using-environment-variables%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在涉及自动化或持续集成的场景中，在用户配置文件或&lt;strong&gt;偏好设置&lt;/strong&gt;窗口中配置设置可能不太实际，而且更容易出错。在这种情况下，你可能会考虑使用环境变量来配置全局缓存及其附属缓存的设置。下列环境变量可供使用：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Environment variable&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_CACHE_ROOT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定全局缓存的位置（包含注册表数据和未压缩包缓存的根文件夹）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_NPM_CACHE_PATH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定您希望包管理器用作其注册表数据缓存的位置的绝对路径。默认情况下，这是全局缓存根目录下的&lt;code&gt;db&lt;/code&gt;子目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_CACHE_PATH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定您希望包管理器存储包 tarball 的未压缩内容的位置的绝对路径。默认情况下，这是全局缓存根目录下的&lt;code&gt;packages&lt;/code&gt;子目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_ENABLE_GIT_LFS_CACHE&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定任何非空（&amp;quot;&amp;quot;）的值以启用 Git LFS 缓存。默认情况下，包管理器使用全局缓存根目录下的&lt;code&gt;git-lfs&lt;/code&gt;子目录，除非您使用&lt;code&gt;UPM_GIT_LFS_CACHE_PATH&lt;/code&gt;环境变量指定了不同的路径。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_GIT_LFS_CACHE_PATH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定您希望包管理器存储 Git LFS 缓存的位置的绝对路径。通过设置此路径，您自动启用 Git LFS 缓存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;UPM_MAX_CACHE_SIZE&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以字节为单位，以正整数指定注册表数据缓存（&lt;code&gt;db&lt;/code&gt;子目录）的最大大小。例如，要将大小设置为5GB，分配一个值为&lt;code&gt;5000000000&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;：当你使用此方法时，请遵循以下指导原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在设置环境变量之前，如果Unity编辑器和Unity Hub已经在运行，请关闭它们。&lt;/li&gt;
&lt;li&gt;在设置环境变量的同一个命令提示符或终端会话中启动Unity编辑器或Unity Hub。&lt;/li&gt;
&lt;li&gt;如果你在前述表格中设置了任何环境变量，每次启动Unity时都必须设置它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关设置环境变量的信息，请参阅你的操作系统的文档。要了解环境变量的介绍，请参考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Environment_variable&#34;&gt;https://en.wikipedia.org/wiki/Environment_variable&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;customize-the-asset-store-cache-location自定义资源商店缓存位置&#34;&gt;Customize the Asset Store cache location(自定义资源商店缓存位置) &lt;a href=&#34;#customize-the-asset-store-cache-location%e8%87%aa%e5%ae%9a%e4%b9%89%e8%b5%84%e6%ba%90%e5%95%86%e5%ba%97%e7%bc%93%e5%ad%98%e4%bd%8d%e7%bd%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包管理器为你从&lt;strong&gt;资源商店&lt;/strong&gt;获取的包维护一个缓存。包管理器将此缓存存储在一个默认位置，你可以覆盖这个位置。&lt;/p&gt;
&lt;p&gt;你可能有多种原因想要覆盖资源商店缓存的位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你想节省内部驱动器的空间。&lt;/li&gt;
&lt;li&gt;你想将缓存存储在一个共享驱动器上，其他人可以访问。&lt;/li&gt;
&lt;li&gt;你想将缓存存储在不在系统目录中的文件夹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，包管理器对其资源商店包缓存使用以下文件夹结构：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;asset-store-cache-root&amp;gt;
  └── Asset Store-5.x
      └── &amp;lt;subfolders for Asset Store vendors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于资源商店包缓存根的默认位置的信息，请参考已下载资产文件的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：包管理器为注册表包和资源商店包维护独立的缓存。关于覆盖全局缓存的默认位置的信息，请参考自定义全局缓存。&lt;/p&gt;
&lt;p&gt;要覆盖包管理器对资源商店包的缓存的默认位置，你可以使用以下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐使用首选项窗口方法，因为它既简单又持久。当你使用该方法更改包缓存位置时，Unity会为当前会话和未来的会话存储偏好设置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ASSETSTORE_CACHE_PATH&lt;/code&gt;环境变量方法不是永久性的，但高级用户在特定的使用情况下可能会发现它更可取。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;important-notes-before-you-begin开始前的重要提示&#34;&gt;Important notes before you begin(开始前的重要提示) &lt;a href=&#34;#important-notes-before-you-begin%e5%bc%80%e5%a7%8b%e5%89%8d%e7%9a%84%e9%87%8d%e8%a6%81%e6%8f%90%e7%a4%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无论你选择哪种方法，改变缓存位置都会告诉包管理器往后使用那个位置。包管理器在原始位置存储的现有包仍会保留在那个文件夹结构中。&lt;/li&gt;
&lt;li&gt;如果你使用环境变量方法更改了缓存位置，那么你就不能使用首选项窗口来更改位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;using-the-preferences-window使用首选项窗口&#34;&gt;Using the Preferences window(使用首选项窗口) &lt;a href=&#34;#using-the-preferences-window%e4%bd%bf%e7%94%a8%e9%a6%96%e9%80%89%e9%a1%b9%e7%aa%97%e5%8f%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要使用首选项窗口覆盖资源商店包缓存的默认位置，请按照以下步骤操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用以下方法之一打开首选项窗口：
&lt;ul&gt;
&lt;li&gt;使用Unity编辑器的菜单，如首选项中所述。&lt;/li&gt;
&lt;li&gt;打开包管理器窗口，点击设置图标 &lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/iconSettings-1712903391407-7.png&#34; alt=&#34;img&#34;&gt;，然后选择 &lt;strong&gt;首选项&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择 &lt;strong&gt;包管理器&lt;/strong&gt; 类别。&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;我的资源&lt;/strong&gt; 下，打开 &lt;strong&gt;缓存位置&lt;/strong&gt; 旁边的菜单 &lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/package-manager-folder-1712903396270-10.png&#34; alt=&#34;img&#34;&gt;.&lt;/li&gt;
&lt;li&gt;选择 &lt;strong&gt;更改位置&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为资源商店包缓存选择一个新的位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/preferences-package-manager-1712903398996-13.png&#34; alt=&#34;The Preferences window with the Package Manager category selected&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择首选项窗口的包管理器类别&lt;/p&gt;
&lt;h2 id=&#34;using-the-environment-variable使用环境变量&#34;&gt;Using the environment variable(使用环境变量) &lt;a href=&#34;#using-the-environment-variable%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在涉及自动化或持续集成的场景中，通过配置文件或首选项窗口配置设置的方式显得不够实用，而且更容易出错。在这样的场景下，你可能会考虑设置&lt;code&gt;ASSETSTORE_CACHE_PATH&lt;/code&gt;环境变量，以覆盖资源商店包缓存的默认位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在使用此方法时，请遵循以下指南：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在设置环境变量之前，如果Unity编辑器和Unity Hub已经在运行，则关闭它们。&lt;/li&gt;
&lt;li&gt;从设置环境变量的同一命令提示符或终端会话中启动Unity编辑器或Unity Hub。&lt;/li&gt;
&lt;li&gt;每次启动Unity时，你都必须设置&lt;code&gt;ASSETSTORE_CACHE_PATH&lt;/code&gt;环境变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于设置环境变量的信息，请参照你的操作系统的文档。关于环境变量的入门介绍，请参考https://en.wikipedia.org/wiki/Environment_variable&lt;/p&gt;
&lt;h1 id=&#34;using-private-repositories-with-https-git-urls使用https-git-url访问私有仓库&#34;&gt;Using private repositories with HTTPS Git URLs(使用HTTPS Git URL访问私有仓库) &lt;a href=&#34;#using-private-repositories-with-https-git-urls%e4%bd%bf%e7%94%a8https-git-url%e8%ae%bf%e9%97%ae%e7%a7%81%e6%9c%89%e4%bb%93%e5%ba%93&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你在终端中使用Git通过HTTPS访问私有仓库时，Git会提示你输入用户名和密码。然后，Git将这些凭证提交给服务器，如果服务器接受这些凭证并允许访问仓库，Git就会继续执行命令。&lt;/p&gt;
&lt;p&gt;当Unity包管理器使用Git URL获取包时，没有终端供用户输入凭证。因此，当服务器向Git请求凭证时，Git不会发出提示，而是向Unity包管理器报告错误。为了解决这个问题，你必须为Git配置一个Git凭证助手，而且该助手必须已经为该仓库加载了所需的凭证。如果凭证有效，Git可以成功执行Unity包管理器发出的命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：使用SSH协议的Git URL，包括SCP样式的语法时，Git凭证助手无效。&lt;/p&gt;
&lt;h2 id=&#34;git-credential-managergit凭证管理器&#34;&gt;Git Credential ManagerGit(凭证管理器) &lt;a href=&#34;#git-credential-managergit%e5%87%ad%e8%af%81%e7%ae%a1%e7%90%86%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;尽管Git支持多个凭证助手来存储凭证，但Git凭证管理器（GCM）仍是推荐的凭证助手。GCM灵活，易于安装，并得到了积极的支持。它基于.NET构建，这意味着它可以在支持.NET的Windows、macOS和Linux发行版上运行。&lt;/p&gt;
&lt;p&gt;默认情况下，GCM使用Windows凭证管理器（在Windows上）和macOS钥匙串（在macOS上）作为配置的凭证存储。GCM没有为Linux配置默认的存储库。关于GCM支持的不同凭证存储配置的更多信息，请参考GCM凭证存储文档。&lt;/p&gt;
&lt;h2 id=&#34;prerequisites先决条件&#34;&gt;Prerequisites(先决条件) &lt;a href=&#34;#prerequisites%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在你可以使用HTTPS URL从私有Git仓库获取包之前，确保你已经安装了GCM。&lt;/p&gt;
&lt;p&gt;Git for Windows安装程序包含一个步骤，可以自动安装和配置GCM。如果你在以下情况下，你也可以单独安装GCM：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Windows上用其他方法安装Git。&lt;/li&gt;
&lt;li&gt;使用macOS或Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于安装GCM的更多信息，请参考GCM安装指南。&lt;/p&gt;
&lt;h2 id=&#34;procedure操作步骤&#34;&gt;Procedure(操作步骤) &lt;a href=&#34;#procedure%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;遵循以下步骤来访问使用HTTPS Git URL的私有仓库中的包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在终端中运行以下命令，配置Git使用GCM：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config --global credential.helper manager
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过终端一次性访问仓库。例如，运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git ls-remote --heads https://&amp;lt;url-to-repository&amp;gt; HEAD
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当Git提示你时，输入你的凭证。如果你的用户账户可以访问远程Git服务器，且服务器接受你的凭证，那么Git凭证助手将会安全地存储你的凭证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Unity包管理器。当需要时，它将使用你存储的凭证，从你有权限访问的基于HTTPS的仓库获取包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;using-passphrase-protected-ssh-keys-with-ssh-git-urls使用口令保护的ssh密钥与ssh-git-url配合使用&#34;&gt;Using passphrase-protected SSH keys with SSH Git URLs(使用口令保护的SSH密钥与SSH Git URL配合使用) &lt;a href=&#34;#using-passphrase-protected-ssh-keys-with-ssh-git-urls%e4%bd%bf%e7%94%a8%e5%8f%a3%e4%bb%a4%e4%bf%9d%e6%8a%a4%e7%9a%84ssh%e5%af%86%e9%92%a5%e4%b8%8essh-git-url%e9%85%8d%e5%90%88%e4%bd%bf%e7%94%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你使用Git通过SSH访问私有仓库时，Git用SSH客户端和服务器建立了一个安全连接。在建立连接时，Git在SSH握手阶段使用了你配置的SSH密钥。在此阶段，SSH客户端需要能够读取你的密钥。然而，如果你用口令对你的密钥进行了加密，SSH客户端就无法直接使用这个密钥。在这种情况下，终端会提示你输入口令。在你输入正确的口令后，SSH连接就完成了，Git命令会使用这个连接进行运行。&lt;/p&gt;
&lt;p&gt;当Unity包管理器使用Git URL获取包时，没有界面供你输入SSH客户端请求的凭证。因此，如果你用口令保护了你的SSH密钥文件，SSH客户端就无法建立连接，Git就会报告错误。为了解决这个问题，必须有一个SSH认证代理正在运行，并已加载SSH密钥，这样SSH客户端就可以在不需要口令的情况下使用它。&lt;/p&gt;
&lt;p&gt;具体方法根据你的操作系统和你使用的SSH客户端而异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你使用Windows 10或更高版本及其内置的OpenSSH客户端，请参考在Windows（OpenSSH）上自动加载SSH密钥。&lt;/li&gt;
&lt;li&gt;如果你使用Windows和PuTTY及其认证代理（Pageant），请参考在Windows（PuTTY）上自动加载SSH密钥。&lt;/li&gt;
&lt;li&gt;如果你使用macOS，请参考在macOS上自动加载SSH密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;loading-ssh-keys-automatically-on-windows-openssh在windows上自动加载ssh密钥openssh&#34;&gt;Loading SSH keys automatically on Windows (OpenSSH)在Windows上自动加载SSH密钥（OpenSSH) &lt;a href=&#34;#loading-ssh-keys-automatically-on-windows-openssh%e5%9c%a8windows%e4%b8%8a%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bdssh%e5%af%86%e9%92%a5openssh&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果你使用Windows及其内置的OpenSSH客户端，按照以下的步骤配置OpenSSH客户端，这样你就可以在不提示口令的情况下使用你的SSH密钥。&lt;/p&gt;
&lt;h2 id=&#34;prerequisites前提条件&#34;&gt;Prerequisites(前提条件) &lt;a href=&#34;#prerequisites%e5%89%8d%e6%8f%90%e6%9d%a1%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Windows 10或更晚的版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;before-you-begin在你开始之前&#34;&gt;Before you begin(在你开始之前) &lt;a href=&#34;#before-you-begin%e5%9c%a8%e4%bd%a0%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;检查是否有任何已存在的SSH密钥。请参考GitHub Docs文章，检查现有的SSH密钥。&lt;/p&gt;
&lt;p&gt;如果你还没有SSH密钥：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照GitHub Docs文章，生成新的SSH密钥来创建一个。&lt;/li&gt;
&lt;li&gt;按照GitHub Docs文章，将新的SSH密钥添加到你的GitHub账户，添加新的SSH密钥到你的GitHub账户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;procedure步骤&#34;&gt;Procedure(步骤) &lt;a href=&#34;#procedure%e6%ad%a5%e9%aa%a4&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查&lt;code&gt;C:\Users\&amp;lt;YourUserName&amp;gt;\.ssh\config&lt;/code&gt;是否存在。&lt;strong&gt;注意&lt;/strong&gt;：在一些应用程序中，如Git Bash，&lt;code&gt;.ssh&lt;/code&gt;是一个隐藏的子目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;code&gt;C:\Users\&amp;lt;YourUserName&amp;gt;\.ssh\config&lt;/code&gt;不存在，则创建它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向&lt;code&gt;C:\Users\&amp;lt;YourUserName&amp;gt;\.ssh\config&lt;/code&gt;中添加以下内容，来在认证代理中设置要加载的密钥，并指定目标服务器的使用。确保你在标记为&lt;code&gt;Host *&lt;/code&gt;的任何全局设置之前添加这个条目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Host&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SERVER_NAME&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentitiesOnly&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentityFile&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FILE_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;是使用&lt;code&gt;IdentityFile&lt;/code&gt;指定文件的服务器。一个示例值是&lt;code&gt;github.com&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FILE_PATH&lt;/code&gt;是你创建的SSH文件的完全限定路径。一个示例值是&lt;code&gt;C:\Users\&amp;lt;YourUserName&amp;gt;\.ssh\&amp;lt;FILE&amp;gt;&lt;/code&gt;，其中&lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt;可能是&lt;code&gt;id_rsa&lt;/code&gt;，&lt;code&gt;id_ecdsa&lt;/code&gt;，&lt;code&gt;id_ed25519&lt;/code&gt;，或一个自定义名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Host&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;github&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentitiesOnly&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentityFile&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;user1&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ssh&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id_ed25519&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开Windows PowerShell，确保你选择&lt;strong&gt;以管理员身份运行&lt;/strong&gt;来打开它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过运行以下命令，配置SSH认证代理服务，以便它每次你重启电脑时启动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get-Service ssh-agent | Set-Service -StartupType Automatic
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行以下命令以启动服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Start-Service ssh-agent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行以下命令以检查服务是否运行，并确认&lt;code&gt;Status&lt;/code&gt;的值为&lt;code&gt;Running&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get-Service ssh-agent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将你的密钥文件加载到&lt;code&gt;ssh-agent&lt;/code&gt;中，将&lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt;替换为你的密钥实际的文件名，然后在提示时输入你的密码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-add $env:USERPROFILE\.ssh\&amp;lt;FILE&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-add $env:USERPROFILE\.ssh\id_ed25519
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确保Git使用Windows OpenSSH客户端，而不是Git附带的SSH客户端，可以使用以下任一方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于系统范围的配置，创建一个名为&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;的环境变量，其值为&lt;code&gt;C:/Windows/System32/OpenSSH/ssh.exe&lt;/code&gt;。&lt;strong&gt;重要提示&lt;/strong&gt;：确保你在路径中使用正斜杠。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要设置特定范围的配置，可以在终端中运行以下&lt;code&gt;git config&lt;/code&gt;命令。可以参考git config文档了解详细信息。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config --global core.sshCommand C:/Windows/System32/OpenSSH/ssh.exe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重要&lt;/strong&gt;: 确保你在路径中使用正斜杠。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在，你可以使用Unity包管理器通过使用带有密码保护的SSH密钥从该Git仓库中获取包了。&lt;/p&gt;
&lt;h1 id=&#34;loading-ssh-keys-automatically-on-windows-putty在windows上自动加载ssh密钥putty&#34;&gt;Loading SSH keys automatically on Windows (PuTTY)在Windows上自动加载SSH密钥（PuTTY） &lt;a href=&#34;#loading-ssh-keys-automatically-on-windows-putty%e5%9c%a8windows%e4%b8%8a%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bdssh%e5%af%86%e9%92%a5putty&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果你使用PuTTY及其身份验证代理（Pageant）而非Windows内置的OpenSSH客户端，请按照以下步骤操作。例如，如果你使用SourceTree作为你的Git客户端，它会自带PuTTY（和Pageant）供你使用。&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin开始之前&#34;&gt;Before you begin(开始之前) &lt;a href=&#34;#before-you-begin%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;确保你已安装了包含Pageant的PuTTY套件。如果没有安装，可以在https://www.putty.org/ 下载。&lt;/p&gt;
&lt;p&gt;检查你是否有任何现有的SSH密钥。参考GitHub文档文章，检查现有的SSH密钥。&lt;/p&gt;
&lt;p&gt;如果你没有SSH密钥：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;PuTTYgen&lt;/strong&gt;应用生成一个私钥/公钥对，将其保存为私钥。参考PuTTY用户手册中的使用PuTTYgen，PuTTY密钥生成器。&lt;/li&gt;
&lt;li&gt;按照GitHub文档文章，将新的SSH密钥添加到你的GitHub账户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;procedure操作步骤-1&#34;&gt;Procedure(操作步骤) &lt;a href=&#34;#procedure%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;按照以下步骤在Windows上自动加载密钥和口令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从PuTTY文件夹启动Pageant：&lt;strong&gt;开始菜单&lt;/strong&gt; &amp;gt; &lt;strong&gt;所有程序&lt;/strong&gt; &amp;gt; &lt;strong&gt;PuTTY&lt;/strong&gt; &amp;gt; &lt;strong&gt;Pageant&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在系统托盘中找到Pageant图标. &lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-19-unity-document-3/upm-pageant.png&#34; alt=&#34;img&#34;&gt;&lt;/li&gt;
&lt;li&gt;在系统托盘中右键点击Pageant图标并选择&lt;strong&gt;查看密钥&lt;/strong&gt;。&lt;strong&gt;Pageant密钥列表&lt;/strong&gt;窗口会打开。&lt;/li&gt;
&lt;li&gt;点击&lt;strong&gt;添加密钥&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;文件资源管理器&lt;/strong&gt;窗口来选择你要加载的SSH密钥文件。确保选择的文件是&lt;code&gt;.ppk&lt;/code&gt;扩展名，然后点击&lt;strong&gt;打开&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果该密钥受到口令保护，输入你的口令。&lt;/li&gt;
&lt;li&gt;确保你选择的密钥现在已经在&lt;strong&gt;Pageant密钥列表&lt;/strong&gt;窗口中列出。现在可在任何你的PuTTY会话中连接到任何服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可能已将Git配置为使用PuTTY的&lt;code&gt;plink.exe&lt;/code&gt;程序。检查当使用SSH密钥时Git是否使用Pageant：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查是否存在&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;环境变量。如果没有，创建它。&lt;/li&gt;
&lt;li&gt;将其值设置为PuTTY的&lt;code&gt;plink.exe&lt;/code&gt;文件的完全限定路径。默认位置为&lt;code&gt;&amp;quot;C:\Program Files\PuTTY\plink.exe&amp;quot;&lt;/code&gt;。&lt;strong&gt;重要&lt;/strong&gt;: 如果路径包含空格，确保你使用引号将值括起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要在启动时自动加载私钥：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开开始菜单并右键点击&lt;strong&gt;Pageant&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;strong&gt;更多&lt;/strong&gt; &amp;gt; &lt;strong&gt;打开文件位置&lt;/strong&gt;。&lt;strong&gt;文件资源管理器&lt;/strong&gt;窗口会打开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键点击&lt;strong&gt;Pageant&lt;/strong&gt;并选择&lt;strong&gt;属性&lt;/strong&gt;。&lt;strong&gt;Pageant属性&lt;/strong&gt;窗口会打开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新&lt;strong&gt;目标&lt;/strong&gt;字段，通过添加你想在启动时加载的私钥的完全路径。每个密钥之间用空格分隔。例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\Program Files\PuTTY\pageant.exe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\Users\user1\myKeys\privatekey.ppk&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;strong&gt;应用&lt;/strong&gt;然后选择&lt;strong&gt;确定&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过打开命令行并在你的仓库中运行&lt;code&gt;git&lt;/code&gt;命令来测试你的配置，以确保无需输入口令就可以完成操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当Pageant运行且你输入了口令后，你可以使用Unity包管理器通过使用口令保护的SSH密钥从那个Git仓库中获取包。&lt;/p&gt;
&lt;p&gt;下次当Pageant启动时，如果它受到口令保护，它会提示你输入口令。&lt;/p&gt;
&lt;p&gt;要在Windows启动时自动加载Pageant，参考微软支持文章，将应用添加到Windows 10启动时自动运行。&lt;/p&gt;
&lt;h1 id=&#34;loading-ssh-keys-automatically-on-macos在macos上自动加载ssh密钥&#34;&gt;Loading SSH keys automatically on macOS(在macOS上自动加载SSH密钥) &lt;a href=&#34;#loading-ssh-keys-automatically-on-macos%e5%9c%a8macos%e4%b8%8a%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bdssh%e5%af%86%e9%92%a5&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果你使用macOS，按照以下步骤配置OpenSSH客户端，这样你就可以在不出现提示的情况下使用受口令保护的SSH密钥。&lt;/p&gt;
&lt;h2 id=&#34;prerequisites前提条件-1&#34;&gt;Prerequisites(前提条件) &lt;a href=&#34;#prerequisites%e5%89%8d%e6%8f%90%e6%9d%a1%e4%bb%b6-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;macOS 10.13或更高版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;before-you-begin开始之前-1&#34;&gt;Before you begin(开始之前) &lt;a href=&#34;#before-you-begin%e5%bc%80%e5%a7%8b%e4%b9%8b%e5%89%8d-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;检查是否有任何现有的SSH密钥。参考GitHub文档文章，检查现有的SSH密钥。&lt;/p&gt;
&lt;p&gt;如果你没有SSH密钥：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照GitHub文档文章，生成一个新的SSH密钥来创建一个。&lt;/li&gt;
&lt;li&gt;按照GitHub文档文章，将新的SSH密钥添加到你的GitHub账户中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;procedure操作步骤-2&#34;&gt;Procedure(操作步骤) &lt;a href=&#34;#procedure%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4-2&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查你的家目录&lt;code&gt;.ssh&lt;/code&gt;子目录是否包含一个&lt;code&gt;config&lt;/code&gt;文件。&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;.ssh&lt;/code&gt;是一个隐藏子目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;code&gt;~/.ssh/config&lt;/code&gt;文件不存在，创建它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将以下内容添加到&lt;code&gt;~/.ssh/config&lt;/code&gt;，以指定在认证代理中加载的密钥，并指明目标服务器的使用。确保你在标记为&lt;code&gt;Host *&lt;/code&gt;的全局设置之前添加此条目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Host&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SERVER_NAME&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;UseKeychain&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentitiesOnly&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentityFile&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FILE_PATH&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;是使用&lt;code&gt;IdentityFile&lt;/code&gt;指定文件的服务器。一个示例值是&lt;code&gt;github.com&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FILE_PATH&lt;/code&gt;是你创建的SSH文件的路径。一个示例值是&lt;code&gt;~/.ssh/&amp;lt;FILE&amp;gt;&lt;/code&gt;，其中&lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt;可能是&lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_ecdsa&lt;/code&gt;、&lt;code&gt;id_ed25519&lt;/code&gt;或自定义名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Host&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;github&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;UseKeychain&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentitiesOnly&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;IdentityFile&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;~/&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ssh&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id_ed25519&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开终端应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将你的密钥文件加载到&lt;code&gt;ssh-agent&lt;/code&gt;中，将&lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt;替换为你的密钥的实际文件名，然后在提示时输入你的口令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-add ~/.ssh/&amp;lt;FILE&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-add ~/.ssh/id_ed25519
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成。macOS默认启动&lt;code&gt;ssh-agent&lt;/code&gt;，所以你现在可以使用Unity包管理器通过你的受口令保护的SSH密钥从那个Git仓库获取包。&lt;/p&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论 &lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;搬砖愉快！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity中文版-Unity&#39;s Package Manager(一)(自翻译)</title>
      <link>https://www.chenqiaoqian.com/2023/07/17/2023-07-17-unity-Documents-2/</link>
      <pubDate>Mon, 17 Jul 2023 11:13:34 +0800</pubDate>
      
      <guid>https://www.chenqiaoqian.com/2023/07/17/2023-07-17-unity-Documents-2/</guid>
      <description>&lt;p&gt;翻译Unity中文版的初衷是因为官方提供的中文版存在缺陷，而且翻译的不全。现在基于Unity2023.2版本对官方文档进行翻译。&lt;/p&gt;
&lt;h1 id=&#34;unitys-package-manager一&#34;&gt;Unity’s Package Manager(一) &lt;a href=&#34;#unitys-package-manager%e4%b8%80&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;包是一个容器，存储各种类型的特征或资产，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编辑器工具和库，如文本编辑器，动画查看器或测试框架。&lt;/li&gt;
&lt;li&gt;运行时工具和库，如Physics API或图形管道。&lt;/li&gt;
&lt;li&gt;资产集合，如纹理或动画。&lt;/li&gt;
&lt;li&gt;项目模板，以与他人共享常见的项目类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过Package Manager，packages为Unity提供了广泛的增强功能。为了帮助查找和使用这些包，Package Manager的窗口提供了可以一起使用的包集合，称为&lt;em&gt;特性集&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在Editor中，你可以通过此菜单访问Package Manager窗口：&lt;strong&gt;Window&lt;/strong&gt; &amp;gt; &lt;strong&gt;Package Manager&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Package Manager还支持管理你从Unity &lt;strong&gt;Asset Store&lt;/strong&gt; 下载或导入的包。&lt;/p&gt;
&lt;p&gt;Unity提供了三个Package Manager接口：Package Manager窗口，Scripting API，和manifest文件。下表包含了对每个接口的介绍，以及更多信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Topic&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;How Unity works with packages(Unity如何与包进行协作)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;了解一下Unity的Package Manager的概览。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Concepts(概念)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;学习Package Manager的原理和特性，包括版本，manifests，注册表，状态，源，包生命周期，依赖和解析等概念。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Package Manager window(包管理器窗口)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在你的项目中查找和管理包，并解决包依赖性的冲突。Package Manager提供了一个用户界面，可以直接修改项目的manifest。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scripting API for packages(包的脚本编程接口)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用脚本API与Package Manager进行交互，使用C# &lt;strong&gt;脚本&lt;/strong&gt;。查看样本，了解如何查询包注册表，安装，嵌入和移除包，以及使用各种标准列出包。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Project manifest(项目清单)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;了解Unity Package Manager所读取的文件，以便它能够计算要检索和加载的包的列表。参见Package manifest。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Inspecting packages(查看包内容)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用专用的&lt;strong&gt;Inspector&lt;/strong&gt;窗口查看任何包manifest。使用此窗口直接编辑嵌入或本地包的包manifest。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scoped Registries(作用域注册表)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;学习如何设置或访问自定义的注册服务器。使用此注册服务器来托管和分发（或使用）自定义包，除了Unity提供的注册表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Configuration(配置)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;学习如何配置范围注册认证，解决网络问题，自定义缓存位置等等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Resolution and conflict(解析和冲突)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;学习包管理器如何确定项目的直接和&lt;strong&gt;间接依赖性&lt;/strong&gt;，并在从注册表获取最佳版本之前评估所有请求的包版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Troubleshooting(故障排查)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果你的项目的任何包，包括包管理器窗口本身，都无法加载，匹配一个可能的解决方案来解决问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;how-unity-works-with-packages&#34;&gt;How Unity works with packages &lt;a href=&#34;#how-unity-works-with-packages&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当Unity打开一个项目时，Unity包管理器会读取项目清单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;来确定在项目中需要加载哪些包。然后它发送请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到包注册服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于在清单中出现作为依赖项的每个包。然后，包注册器将请求的信息和数据发送回包管理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进而在项目中安装这些包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个项目都有自己的清单，列出了需要作为项目“依赖项”来加载的包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-15-unity-document-2/upm-overview.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Unity包管理器如何安装包&lt;/p&gt;
&lt;p&gt;向项目添加一个包需要更新项目清单，确保包管理器在依赖项列表中包含该包。尽管你可以直接修改项目清单，但使用包管理器窗口，它可以为你管理项目清单的修改，这会更安全，也更容易。&lt;/p&gt;
&lt;h1 id=&#34;concepts&#34;&gt;Concepts &lt;a href=&#34;#concepts&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;这一部分解释了许多有关Unity包管理器功能的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions(版本)&lt;/li&gt;
&lt;li&gt;Manifests(清单)&lt;/li&gt;
&lt;li&gt;Registry(注册表)&lt;/li&gt;
&lt;li&gt;Package Management(包管理)&lt;/li&gt;
&lt;li&gt;Package sources(包资源)&lt;/li&gt;
&lt;li&gt;Package states and lifecycle(包状态和生命周期)&lt;/li&gt;
&lt;li&gt;Dependency and resolution(依赖和解析)&lt;/li&gt;
&lt;li&gt;Global cache(全局缓存)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;versions&#34;&gt;Versions &lt;a href=&#34;#versions&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;每个包都有多个版本供选择，标记着该包在其生命周期中的变化。每次开发者更新包，他们都会给它一个新的版本号。包版本的变化告诉你它是否包含一种破坏性改变(主版本)，新的向后兼容功能(次版本)，或者仅有的修复错误(补丁版)，遵循语义版本控制。&lt;/p&gt;
&lt;p&gt;要查看特定包的可用版本列表，请查看查找特定版本。&lt;/p&gt;
&lt;h2 id=&#34;manifests&#34;&gt;Manifests &lt;a href=&#34;#manifests&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;有两种类型的清单文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Project manifests(项目清单)
(&lt;code&gt;manifest.json&lt;/code&gt;)储存包管理器需要找到并加载正确包的信息，包括声明为依赖项的包和版本列表。&lt;/li&gt;
&lt;li&gt;Package manifests(包清单)
(&lt;code&gt;package.json&lt;/code&gt;)储存关于特定包的信息，以及包所需的包和版本的列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种文件都使用JSON（JavaScript 对象表示法）语法。&lt;/p&gt;
&lt;h2 id=&#34;registry&#34;&gt;Registry &lt;a href=&#34;#registry&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在Unity的包管理器领域，包注册表是一个服务器，它存储包内容以及每个包版本的信息（元数据）。Unity维护一个可供分发的官方包的中心注册表。默认情况下，所有项目都使用官方的Unity包注册表，但您可以添加额外的注册表以存储和分发私人包，或者在开发自定义包时对其进行暂存。&lt;/p&gt;
&lt;h2 id=&#34;package-management&#34;&gt;Package Management &lt;a href=&#34;#package-management&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Unity包管理器是一个管理整个包系统的工具。它的主要任务包括以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它与Unity包注册表服务器以及您指定的任何其他注册表进行通信。&lt;/li&gt;
&lt;li&gt;它读取您的项目清单和获取包内容及元数据。&lt;/li&gt;
&lt;li&gt;它安装、升级及卸载包，无论它们是项目的依赖关系还是已安装包中的一种。&lt;/li&gt;
&lt;li&gt;它导入您以前下载或购买的Asset Store包。&lt;/li&gt;
&lt;li&gt;它启用和禁用Unity的内置包。&lt;/li&gt;
&lt;li&gt;它显示每个包的每个版本的信息。&lt;/li&gt;
&lt;li&gt;在项目及其包需要多个包版本时，它解决冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unity包管理器按项目安装样本、工具和资产，而不是在特定机器或设备的所有项目间安装。它使用全局缓存存储下载的包元数据和内容。一旦在项目中安装，Unity将包资产视为项目中的其他任何资产，只是这些资产存储在包文件夹内并且是&lt;strong&gt;不可变&lt;/strong&gt;的。您只能从Local和Embedded包源永久性改变内容。&lt;/p&gt;
&lt;h2 id=&#34;package-sources&#34;&gt;Package sources &lt;a href=&#34;#package-sources&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;源描述了包的来源：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Source&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Registry&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity包管理器在您请求时，会将大多数包从包注册表服务器下载到您计算机上的全局缓存中。这些包是不可变的，所以您可以在项目中使用它们，但您不能修改它们或改变它们的包清单。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Built-in&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这些包允许您启用或禁用Unity的功能（例如，Terrain Physics、Animation等）。它们是不可变的。更多信息，请参见Built-in packages。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Embedded&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存储在您的项目文件夹内的任何包都是嵌入式的。这个源对应于自定义状态，因为当您开始开发一个自定义包时，您通常会将所有需要的脚本、库、样本和其他资源放在项目文件夹下的一个文件夹中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Local&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;您可以从您的计算机上的任何文件夹中安装一个包（例如，如果您本地克隆了一个开发仓库）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Tarball (local)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;您可以从计算机上的tarball文件中安装一个包。包管理器从tarball中提取包并将其存储在缓存中。然而，这些包是不可变的，与从本地文件夹安装的方式不同。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包管理器直接从Git仓库中而不是从包注册服务器安装基于&lt;strong&gt;Git&lt;/strong&gt;的包。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要编辑包的包清单，请查看检查包。&lt;/p&gt;
&lt;p&gt;包管理器窗口会显示对应于这些源中的一些的标签。有关更多信息，请查看标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：包管理器将您从&lt;strong&gt;Asset Store&lt;/strong&gt;下载的包存储在一个与全局缓存分开的缓存中。请查看Asset Store包以获取更多信息。&lt;/p&gt;
&lt;h1 id=&#34;package-states-and-lifecycle&#34;&gt;Package states and lifecycle &lt;a href=&#34;#package-states-and-lifecycle&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;从Unity编辑器2021.1版本开始，包在其生命周期中可能会经历以下状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-15-unity-document-2/upm-lifecycle_v2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;[][]&lt;/p&gt;
&lt;p&gt;使用Unity包管理器的包生命周期&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Birth&lt;/strong&gt; &lt;strong&gt;(A)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;当包的开发者正在创建包时，它处于&amp;quot;自定义&amp;quot;状态。当它准备好让Unity用户进行测试并提供反馈时，包进入&amp;quot;实验&amp;quot;状态。Unity并不支持实验性的包，并且不保证实验性的包会被完全发布并经过验证，可在生产中安全使用，直到它们进入了发布轨道。实验性的包要么在它们版本的主要部分使用&lt;code&gt;0&lt;/code&gt;，要么在它们版本的修订部分使用&lt;code&gt;-exp.#&lt;/code&gt;后缀。例如，&lt;code&gt;mypackage@0.1.2&lt;/code&gt; 或 &lt;code&gt;mypackage@1.2.3-exp.1&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Release track&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;一旦包通过了质量测试并且不包含任何实验性特性或功能（包括对实验性包的依赖），它就进入了“预发布”状态，该状态位于发布轨道上。这意味着Unity完全支持它，并承诺在当前的LTS周期结束时（例如2021.3）将它们正式发布。要查看此版本可用的预发布包列表，可以参阅预发布包列表。Unity的发布管理只有在包通过了几个测试阶段和验证过程后，才会给予包“已发布”状态，这也包括适当的文档，更改日志和许可文件的检查。这种状态的包在Unity编辑器中以发布标签出现，并且永远不会使用非数字后缀作为版本的一部分。要查看此版本可用的已发布包列表，可以参阅已发布包。如果包开发者更新或改变一个已发布的包，那个包可能会根据严重性返回到另一个状态。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Type of change:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;New state:&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Version bump:&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(B)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;对API的重大改变导致API的失效&lt;/td&gt;
&lt;td&gt;Experimental&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.2.3&lt;/code&gt; =&amp;gt; &lt;code&gt;2.0.0-exp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(C)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;对API的小改动，没有导致API失效，但影响了使用&lt;/td&gt;
&lt;td&gt;Pre-release&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.2.3&lt;/code&gt; =&amp;gt; &lt;code&gt;1.3.0-pre&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;(D)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;修复错误，微小变更以及典型的补丁更新中的文档更新&lt;/td&gt;
&lt;td&gt;Released (same state)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.2.3&lt;/code&gt; =&amp;gt; &lt;code&gt;1.2.4&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Death&lt;/strong&gt; &lt;strong&gt;(E)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;到达生命周期末期的包在标记为“已弃用”的编辑器中不再受支持。处于该状态的包不应继续使用，因为它们可能失效或不安全。更多信息请参阅弃用包。有些实验性包无需经过发布周期轨道，直接进入已弃用状态。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;包管理器窗口显示与这些状态中的一些相对应的标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这些包状态仅适用于Unity内部开发的包。要了解他们特定的流程，请联系第三方包开发者。&lt;/p&gt;
&lt;h1 id=&#34;dependency-and-resolution&#34;&gt;Dependency and resolution &lt;a href=&#34;#dependency-and-resolution&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当你在包管理器窗口工作时，你可以从几个来源安装包（库、本地文件夹或压缩包、Git URL以及名称）。然而，当包管理器从这些来源无缝安装包时，它首先要进行一系列的计算来决定安装哪个版本。它还需要决定安装哪些其他包和版本以支持你选择的包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Direct dependencies直接依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你通过包管理器窗口选择一个包版本进行安装时，你正在向你的项目manifest添加一个“依赖”。这是一个声明，即你需要一个特定版本的某个包才能使项目正常工作。要向项目添加依赖，你需要以&lt;code&gt;包名称@包版本&lt;/code&gt;的形式在&lt;code&gt;&amp;lt;项目根目录&amp;gt;/Packages/manifest.json&lt;/code&gt;文件的依赖属性中添加对包和版本的引用。这些被称为“直接”依赖，因为你的项目直接依赖它们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Indirect dependencies间接依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包也可以需要其他包才能工作。这些被称为“间接”（或转移）依赖。包开发者在开发过程中将这些添加到包manifest文件的依赖属性（&lt;code&gt;&amp;lt;包根目录&amp;gt;/package.json&lt;/code&gt;）。例如，在下面的图表中，&lt;code&gt;alembic@1.0.7&lt;/code&gt;包依赖于&lt;code&gt;timeline@1.0.0&lt;/code&gt;包，所以timeline包是一个“间接”依赖。反过来，项目依赖于&lt;code&gt;cinemachine@2.6.0&lt;/code&gt;和&lt;code&gt;alembic@1.0.7&lt;/code&gt;包，所以它们都是“直接”依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-15-unity-document-2/upm-dependencies.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;该图展示了直接依赖和间接依赖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Version overrides版本覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你添加一个包版本作为依赖时，该版本并不一定是包管理器安装的版本。原因是包管理器必须考虑你项目中的所有依赖，无论是直接还是间接的。在以下示例中，请求的XR插件管理&lt;strong&gt;包版本是&lt;code&gt;4.0.3&lt;/code&gt;。然而，包管理器安装的版本是&lt;code&gt;4.0.6&lt;/code&gt;，因为另一个包依赖于更高的版本，如信息消息&lt;/strong&gt;(B)所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-15-unity-document-2/upm-solver-visual-cues.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当你在详情面板中点击信息按钮（A）时，会出现一个文本框（B）解释为何安装了这个版本而不是你请求的版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dependency graph依赖图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包管理器一次只能安装一个包的版本，所以它必须构建一个依赖图。这个图是项目的每个直接依赖和间接依赖的列表。依赖图决定安装每个包的哪个版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lock file锁定文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当包管理器解决所有版本冲突后，它会将解决方案保存在一个锁定文件中，原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定性，确保每次都可靠地安装相同的包。&lt;/li&gt;
&lt;li&gt;效率，减少重新计算依赖图所需的时间和资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;global-cache&#34;&gt;Global cache &lt;a href=&#34;#global-cache&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;当Unity包管理器从注册表下载包内容和元数据时，它会将它们存储在全局缓存中。这使得重用和共享包更加高效，并且允许你在离线时安装和更新存储的包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：全局缓存不包含来自&lt;strong&gt;资产商店&lt;/strong&gt;的&lt;code&gt;.unitypackage&lt;/code&gt;格式的包。包管理器将这些类型的包存储在一个单独的缓存中。更多信息，请参考资产商店包。&lt;/p&gt;
&lt;h2 id=&#34;location&#34;&gt;Location &lt;a href=&#34;#location&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;默认情况下，Unity将全局缓存存储在一个根目录中，这个目录取决于操作系统（以及Windows上的用户账户类型）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Operating system&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Default root directory&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Windows (user account)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;%LOCALAPPDATA%\Unity\cache\upm&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;C:\Users\yourname\AppData\Local\Unity\cache\upm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Windows (system user account)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;%ALLUSERSPROFILE%\Unity\cache\upm&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;C:\ProgramData\Unity\cache\upm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;macOS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;$HOME/Library/Caches/Unity/upm&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;/Users/yourname/Library/Caches/Unity/upm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Linux&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;$HOME/.cache/Unity/upm&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;/home/yourname/.cache/Unity/upm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: You can override the location of this root directory. Refer to Customize the global cache for more information.&lt;/p&gt;
&lt;h2 id=&#34;structure&#34;&gt;Structure &lt;a href=&#34;#structure&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;包管理器的全局缓存使用多个子缓存，每个子缓存都有不同的用途。包管理器将这些子缓存存储在全局缓存的文件夹下的子文件夹中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Subfolder&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;db&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于存储包内容和元数据的注册表数据缓存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;packages&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包含从注册表获取的包tarballs的未压缩内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;git-lfs&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果你启用了Git大文件存储（LFS），则包含下载的Git大文件存储（LFS）文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在这些子文件夹中，每个注册表都有自己的路径，以便不同注册表上托管的包不会混淆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：您可以重写这些文件夹的位置。有关更多信息，请参阅定制全局缓存。&lt;/p&gt;
&lt;h2 id=&#34;size&#34;&gt;Size &lt;a href=&#34;#size&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;从Unity编辑器的2023.2.0f1版本开始，注册表数据缓存（&lt;code&gt;db&lt;/code&gt;子文件夹）的大小限制为10 gigabytes (GB)。当达到该限制时，PackageManager会通过剔除最近最少使用的内容（基于最旧的一个程序包安装到项目的日期）来修剪注册表数据缓存。换句话说，PackageManager首先剔除的是您在最早时间内添加到项目中的程序包。然而，尽管PackageManager将这些程序包从缓存中剔除，但它们仍然存在于安装了它们的任何项目中。下次您将这些包添加到其他项目时，PackageManager将从适当的注册表中获取它们，而不是从您的缓存中获取。&lt;/p&gt;
&lt;p&gt;您可以重写注册表数据缓存限制的大小。有关信息，请参考定制全局缓存。&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements &lt;a href=&#34;#requirements&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;运行Unity编辑器进程的用户账户必须对根目录及其内容拥有完全的写入权限。没有这些权限，PackageManager无法在缓存中下载和保存程序包的元数据和内容。&lt;/p&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论 &lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;搬砖愉快！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unity中文版-Unity2023.2更新日志(自翻译)</title>
      <link>https://www.chenqiaoqian.com/2023/07/13/2023-07-13-unity-Documents-1/</link>
      <pubDate>Thu, 13 Jul 2023 11:13:34 +0800</pubDate>
      
      <guid>https://www.chenqiaoqian.com/2023/07/13/2023-07-13-unity-Documents-1/</guid>
      <description>&lt;p&gt;翻译Unity中文版的初衷是因为官方提供的中文版存在缺陷，而且翻译的不全。现在基于Unity2023.2版本对官方文档进行翻译。&lt;/p&gt;
&lt;h1 id=&#34;new-in-unity-20232&#34;&gt;New in Unity 2023.2 &lt;a href=&#34;#new-in-unity-20232&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&#34;release-notes&#34;&gt;Release Notes &lt;a href=&#34;#release-notes&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要了解更多关于这个Unity版本的新功能、变更和改进，可以参考2023.2版本的发布说明。&lt;/p&gt;
&lt;h2 id=&#34;upgrade-guide&#34;&gt;Upgrade Guide &lt;a href=&#34;#upgrade-guide&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如果你正在将现有的项目从2023.1版本升级，可以阅读升级到2023.2的指南，了解你的项目可能会受到哪些影响。&lt;/p&gt;
&lt;h1 id=&#34;whats-new&#34;&gt;What’s new &lt;a href=&#34;#whats-new&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;了解自2023.1以来在Unity 2023.2中有哪些变化，并查阅受影响区域的文档。&lt;/p&gt;
&lt;h2 id=&#34;accessibility&#34;&gt;Accessibility &lt;a href=&#34;#accessibility&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们新增了一个编辑器窗口，即Accessibility Hierarchy Viewer，它可以展示当前活跃的可访问性结构及其节点。如需访问Accessibility Hierarchy Viewer，你可以去主菜单的 &lt;strong&gt;Window &amp;gt; Accessibility &amp;gt; Accessibility Hierarchy viewer&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;audio&#34;&gt;Audio &lt;a href=&#34;#audio&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们新增了Audio Random Container，可以随机化音频并确保音量、音调、时间和触发器可以设置为非重复间隔，以确保你的游戏永远不会有两次相同的声音。&lt;/li&gt;
&lt;li&gt;在Audio Random Container中我们加入了一个VU表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;authoring-tools&#34;&gt;Authoring Tools &lt;a href=&#34;#authoring-tools&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;2d&#34;&gt;2D &lt;a href=&#34;#2d&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我们在&lt;strong&gt;Tile Palette&lt;/strong&gt;编辑器窗口中增加了覆盖层支持。&lt;/p&gt;
&lt;h3 id=&#34;2d-physics&#34;&gt;2D Physics &lt;a href=&#34;#2d-physics&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我们在 &lt;strong&gt;Joint Angular Limits&lt;/strong&gt; gizmo中增加了&lt;code&gt;ArticulationBody.jointPosition&lt;/code&gt;指针线，以便在Scene视图中显示关节的准确位置。&lt;/p&gt;
&lt;h3 id=&#34;editor-and-workflow&#34;&gt;Editor and Workflow &lt;a href=&#34;#editor-and-workflow&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新增了Scene视图的上下文菜单。您现在可以通过右键点击或使用自定义的键盘快捷方式在Scene视图中访问新的上下文菜单。这些菜单由UI Toolkit创建并可以在C#中扩展，提供了轻松访问常用命令的方式。&lt;/li&gt;
&lt;li&gt;在Scene视图的偏好设置中添加了&lt;strong&gt;仅在编辑器处于焦点状态时刷新Scene视图&lt;/strong&gt;的选项。启用此选项可使Scene视图仅在编辑器处于焦点状态时刷新。&lt;/li&gt;
&lt;li&gt;新增了可以用键盘快捷方式进行Animator状态之间切换的功能。&lt;/li&gt;
&lt;li&gt;增加了基本OpenType字体功能的支持。目前，只有字距调整功能是启用的。&lt;/li&gt;
&lt;li&gt;增加了一个新的Cameras覆盖层来替换Camera预览。您可以使用Cameras覆盖层进行相机的第一人称控制，并在Scene视图中管理相机。&lt;/li&gt;
&lt;li&gt;用UI Toolkit版本替换了大部分OS上下文菜单。&lt;/li&gt;
&lt;li&gt;增加了颜色检查器，这是一个用于校准光照和后处理的工具。用户可以通过&lt;strong&gt;GameObject&lt;/strong&gt; &amp;gt; &lt;strong&gt;Rendering&lt;/strong&gt; &amp;gt; &lt;strong&gt;Color Checker Tool&lt;/strong&gt;添加颜色检查器。该工具仅作为光照艺术家的生产工具，并不会在构建中保存。&lt;/li&gt;
&lt;li&gt;启用了编辑器显示不同许可证通知模态框的功能。&lt;/li&gt;
&lt;li&gt;增加了一个&lt;code&gt;PropertyCollectionAttribute&lt;/code&gt;，可以用来实现自定义抽屉的集合。&lt;/li&gt;
&lt;li&gt;使用Camera的平移、缩放和轨迹控制，添加了一个新的灯光放置工具。获取更多信息，请参阅从它的视角查看和控制灯光。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ui-toolkit&#34;&gt;UI Toolkit &lt;a href=&#34;#ui-toolkit&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;现在你可以用一个新的，灵活的运行时绑定系统在创建编辑器或运行时UI时轻松地将数据值连接到UI元素属性。您可以在UI Builder或C#代码中配置数据绑定。&lt;/li&gt;
&lt;li&gt;增加了新的控制元素，例如ToggleButtonGroup、Tab和TabViews，同时对现有的控制元素做出了改进。&lt;/li&gt;
&lt;li&gt;对Button、ListView和TreeView控件增加了图标支持。&lt;/li&gt;
&lt;li&gt;增加了新的UxmlElement和UxmlAttribute属性。在创建自定义控件时，这些属性替换了原有的UxmlFactory和UxmlTraits。这简化了自定义控件的创建，提供了通过C#属性的高效替代方案，无需编写大量的代码。此外，您现在可以像在Inspector中那样为字段创建自定义属性抽屉。&lt;/li&gt;
&lt;li&gt;对UI Builder进行了改进，改进了显示样式属性的驱动情况，优化了画布操作，并进行了其他的增强。更新的UI Builder现在也支持UXML Objects的编写，使其能够编辑MultiColumnTreeView和MultiColumnListView。&lt;/li&gt;
&lt;li&gt;在TextElement和TextField中，增加了Emojis Fallback Support字段，以控制在emoji范围内搜索字符的顺序（主字体vs全局回退）。另外，增加了对OpenType字体功能的基本支持，目前的焦点是启用字距调整功能。&lt;/li&gt;
&lt;li&gt;在UI Builder的Inspector中，为盒模型小部件增加了一个新的Spacing字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;textmeshpro&#34;&gt;TextMeshPro &lt;a href=&#34;#textmeshpro&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;增加了基本的Emoji支持。&lt;/li&gt;
&lt;li&gt;添加了基本的OpenType字体功能支持，目前只启用了字距调整功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;graphics&#34;&gt;Graphics &lt;a href=&#34;#graphics&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;批处理计算Skinning：Unity的Skinned Mesh Renderer组件使用计算调度在GPU上并行化顶点变换。Unity 2023.2在所有支持的平台上引入了对Skinned Mesh Renderers的优化。这些优化旨在批处理计算skin和blendshape调度。这可以增加并行变形的顶点数量，并提高角色和 skinned mesh 渲染的GPU性能。&lt;/li&gt;
&lt;li&gt;Progressive GPU Lightmapper现已退出预览，完全得到支持。&lt;/li&gt;
&lt;li&gt;添加了在运行时移动Light Probe位置的API。&lt;/li&gt;
&lt;li&gt;移除了Lighting窗口中的&lt;strong&gt;Auto Generate&lt;/strong&gt;设置。相关API现已废弃。为了在编辑时检查光照贴图，你现在可以选择Scene View Draw Mode，并将&lt;strong&gt;Lighting Data&lt;/strong&gt;设置为&lt;strong&gt;Preview&lt;/strong&gt;。这将展示一个烘焙光照的预览。预览光照贴图是非破坏性的，你可以在烘焙场景之后使用它们。&lt;/li&gt;
&lt;li&gt;添加了&lt;code&gt;BatchCullingContext.cullingFlags&lt;/code&gt;，用于指定是否应裁剪 lightmapped shadow casters。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;BatchRendererGroup&lt;/code&gt;添加了&lt;code&gt;rendererPriority&lt;/code&gt;支持。&lt;/li&gt;
&lt;li&gt;对构建计算队列上的异步光线追踪加速结构提供了支持。AsyncCompute CommandBuffers现在可以运行&lt;code&gt;CommandBuffer.BuildRayTracingAccelerationStructure&lt;/code&gt;命令。为RenderGraph和Render Graph Viewer添加了&lt;code&gt;RayTracingAccelerationStructure&lt;/code&gt;的支持。&lt;/li&gt;
&lt;li&gt;为Texture2DArrays添加了mipmap限制支持。&lt;/li&gt;
&lt;li&gt;为Texture2DArrays添加了mipmap剥离支持。&lt;/li&gt;
&lt;li&gt;为LoadImage添加了提供tiled EXR图像的支持。&lt;/li&gt;
&lt;li&gt;允许暴露光线追踪加速结构的构建标志，以平衡构建时间与GPU上的光线追踪速度和内存消耗。在创建和构建&lt;code&gt;RayTracingAccelerationStructure&lt;/code&gt;以及在Renderer设置的UI中，都可以从C#中自定义标志。&lt;/li&gt;
&lt;li&gt;为DX12添加了Native Render Pass支持。&lt;/li&gt;
&lt;li&gt;为D3D12（Windows和XBox平台）添加了批处理GPU skinning的支持。&lt;/li&gt;
&lt;li&gt;为粒子尾迹添加了Custom Vertex Streams功能。&lt;/li&gt;
&lt;li&gt;添加了&lt;code&gt;BakeTexture&lt;/code&gt;和&lt;code&gt;BakeTrailsTexture&lt;/code&gt;脚本方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;universal-render-pipeline-urp&#34;&gt;Universal Render Pipeline (URP) &lt;a href=&#34;#universal-render-pipeline-urp&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;要获得URP新功能和改进的完整描述，请参考URP的新功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了跨平台HDR显示支持。HDR显示器能够在更高的亮度差异范围内复制图像，接近自然光照条件。在这些设备上显示的HDR输出可以保留线性光照渲染和HDR图像的对比度和质量。编辑器和Standalone Players现在在所有的渲染管线和能力平台上，包括移动和XR，提供全面的HDR色调映射和显示支持。&lt;/li&gt;
&lt;li&gt;为Probe Volumes的间接照明添加了每个顶点质量级别，使得URP更高效地呈现照明环境。你可能需要在移动设备上进行进一步的优化，因为URP不支持Reflection Probes的Lighting Scenario混合或Lighting Normalization。&lt;/li&gt;
&lt;li&gt;在Motion Blur容量组件中添加了一个名为&lt;strong&gt;Camera And Objects&lt;/strong&gt;的新选项，该选项使用运动向量来模糊比摄像机的曝光时间移动更快的物体。&lt;/li&gt;
&lt;li&gt;添加了对额外定向光源cookies的支持。&lt;/li&gt;
&lt;li&gt;在URP Global Settings中添加了Default Volume Profile字段。&lt;/li&gt;
&lt;li&gt;在Universal Render Pipeline Asset中添加了Volume Profile字段。&lt;/li&gt;
&lt;li&gt;为URP材质添加了Alembic速度运动向量支持。&lt;/li&gt;
&lt;li&gt;为基于只有&lt;strong&gt;Time&lt;/strong&gt;节点的顶点动画的ShaderGraphs添加了自动&lt;strong&gt;TimeBased&lt;/strong&gt;运动向量生成。影响位置的所有其他数据在帧之间必须是常数。&lt;/li&gt;
&lt;li&gt;为使用正交投影的XR渲染和相机添加了对Forward+渲染路径的支持。&lt;/li&gt;
&lt;li&gt;在Forward+渲染路径中添加了对集中渲染的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;high-definition-render-pipeline-hdrp&#34;&gt;High Definition Render Pipeline (HDRP) &lt;a href=&#34;#high-definition-render-pipeline-hdrp&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;要获得HDRP新功能和改进的完整描述，请参考HDRP的新功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为Decals投影器添加了HDRP路径跟踪器支持。路径跟踪器不支持来自decals的发光。&lt;/li&gt;
&lt;li&gt;增加了在运行时从磁盘流式加载Probe Volume数据的功能。你可以为不同的质量级别启用或禁用磁盘流式加载。&lt;/li&gt;
&lt;li&gt;使HDRP Shader Graph decals兼容透明对象。这意味着你可以使用Shader Graph创建的decals影响透明对象，以构建像雨滴、涟漪、自定义雕刻、玻璃上的污垢效果等程序效果。&lt;/li&gt;
&lt;li&gt;在HDRP物理天空中添加了一个带有星星和天体的夜空。&lt;/li&gt;
&lt;li&gt;为基于物理的天空添加了Shader Graph输出，并添加了控件来创建月亮。&lt;/li&gt;
&lt;li&gt;在Render Graph Viewer中添加了对异步计算pass和同步点的可视化。&lt;/li&gt;
&lt;li&gt;为体积云添加了beer阴影图。&lt;/li&gt;
&lt;li&gt;在HD Render Pipeline Asset中添加了Volume Profile字段。&lt;/li&gt;
&lt;li&gt;为带有彩色透射的薄对象添加了材料类型。&lt;/li&gt;
&lt;li&gt;为Lit ShaderGraphs的材料添加了禁用清漆的选项。&lt;/li&gt;
&lt;li&gt;添加了Global Pass API，你可以使用它在没有任何游戏对象的场景中向渲染管线注入自定义pass。&lt;/li&gt;
&lt;li&gt;为Arbitrary Output Variables (AOV)添加了体积雾全屏调试模式输出。&lt;/li&gt;
&lt;li&gt;添加了Adaptive Probe Volumes (APV)直接从磁盘流式加载数据的能力。这个功能只在具有计算阴影兼容性的设备上可用。&lt;/li&gt;
&lt;li&gt;添加了使用烘焙API独立于光照贴图或反射探针来烘焙Adaptive Probe Volumes (APV)的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;multiplayer&#34;&gt;Multiplayer &lt;a href=&#34;#multiplayer&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;netcode-for-gameobjects&#34;&gt;Netcode for GameObjects &lt;a href=&#34;#netcode-for-gameobjects&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在网络对象组件的上下文菜单中添加了&lt;strong&gt;刷新场景中的预设实例&lt;/strong&gt;选项。使用此属性更新场景中存在的预设实例的&lt;code&gt;GlobalObjectIdHash&lt;/code&gt;值，这些预设实例在具有&lt;code&gt;NetworkObject&lt;/code&gt;组件之前就已存在。这个属性影响包含在构建列表中的所有场景。&lt;/li&gt;
&lt;li&gt;添加了&lt;code&gt;NetworkManager&lt;/code&gt;的&lt;code&gt;SetPeerMTU&lt;/code&gt;和&lt;code&gt;GetPeerMTU&lt;/code&gt;方法，以全面控制最大传输单元（MTU）大小。使用它为游戏对象的Netcode中的自定义协议。&lt;/li&gt;
&lt;li&gt;改进了网络预设标识生成（例如，&lt;code&gt;GlobalObjectIdHash&lt;/code&gt;）以修复Unity分配无效值的问题。&lt;/li&gt;
&lt;li&gt;以下方式改进了序列化API和codegen管道:
&lt;ul&gt;
&lt;li&gt;添加了&lt;code&gt;GenerateSerializationForTypeAttribute&lt;/code&gt;方法，你可以将此应用到任何类或方法，以确保特定类型包含在codegen序列化过程中。&lt;/li&gt;
&lt;li&gt;添加了&lt;code&gt;GenerateSerializationForGenericParameterAttribute&lt;/code&gt;方法，你可以使用它来将被&lt;code&gt;NetworkVariable&lt;/code&gt;类型包装的泛型类型包含在codegen过程中。&lt;/li&gt;
&lt;li&gt;暴露了额外的&lt;code&gt;NetworkVariableSerialization&lt;/code&gt;方法，以改进自定义&lt;code&gt;NetworkVariable&lt;/code&gt;的创建，没有任何装箱成本。你可以使用&lt;code&gt;NetworkVariableBase.MarkNetworkBehaviourDirty&lt;/code&gt;方法来将NetworkVariables标记为脏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;泛型&lt;code&gt;NetworkBehaviour&lt;/code&gt;类型中的RPC现在可以序列化类的泛型类型的参数。&lt;/li&gt;
&lt;li&gt;改进了Netcode对32位ARMv7的支持。&lt;/li&gt;
&lt;li&gt;添加了额外的&lt;code&gt;NetworkManager&lt;/code&gt;事件&lt;code&gt;OnServerStarted&lt;/code&gt;、&lt;code&gt;OnServerStopped&lt;/code&gt;、&lt;code&gt;OnClientStarted&lt;/code&gt;和&lt;code&gt;OnClientStopped&lt;/code&gt;，以更好地通知&lt;code&gt;NetworkManager&lt;/code&gt;初始化过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dedicated-server-platform&#34;&gt;Dedicated server platform &lt;a href=&#34;#dedicated-server-platform&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在玩家设置中添加了&lt;strong&gt;专用服务器优化&lt;/strong&gt;选项，启用后，会从服务器构建中剥离所有着色器。启用此选项可以大大减少构建时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unity-transport&#34;&gt;Unity Transport &lt;a href=&#34;#unity-transport&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Unity传输2.X现在是Unity传输的默认和推荐版本。&lt;/li&gt;
&lt;li&gt;现在可以通过在&lt;code&gt;NetworkSettings.WithNetworkConfigParameters&lt;/code&gt;中新的&lt;code&gt;maxMessageSize&lt;/code&gt;参数配置传输将发送的最大消息大小。这在网络设备处理较大数据包时出错的环境中非常有用（比如某些移动网络或VPN）。该值不包括IP和UDP头，但包括传输本身添加的头（例如，可靠性头）。默认值是1400。注意，建议客户端和服务器配置使用相同的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;package-manager&#34;&gt;Package Manager &lt;a href=&#34;#package-manager&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;changes-to-package-cache-management&#34;&gt;Changes to package cache management &lt;a href=&#34;#changes-to-package-cache-management&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;更改了全局缓存的默认位置和结构。&lt;/li&gt;
&lt;li&gt;注册数据缓存现在默认最大限制为10GB。你可以通过自定义全局缓存来覆盖默认值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;changes-to-the-package-manager-window&#34;&gt;Changes to the Package Manager window &lt;a href=&#34;#changes-to-the-package-manager-window&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;添加了一个导航面板:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了一个面板，以改进在包子集视图之间的导航。在早期版本中，这些上下文存储在&lt;strong&gt;Packages&lt;/strong&gt;下拉菜单中。&lt;/li&gt;
&lt;li&gt;在包管理器导航面板中添加了&lt;strong&gt;Services&lt;/strong&gt;作为专用条目。&lt;/li&gt;
&lt;li&gt;在导航面板中的&lt;strong&gt;In Project&lt;/strong&gt;下添加了&lt;strong&gt;Updates&lt;/strong&gt;作为嵌套条目。此嵌套视图列出了项目中所有有更新的包。&lt;/li&gt;
&lt;li&gt;在导航面板的My Registries下添加了单独的定位注册表作为嵌套条目。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对列表面板的增强:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;In Project&lt;/strong&gt;上下文的列表面板中添加了一个&lt;strong&gt;Packages - Asset Store&lt;/strong&gt;扩展器，以便你可以在&lt;strong&gt;In Project&lt;/strong&gt;视图中查看和管理Asset Store的包。&lt;/li&gt;
&lt;li&gt;搜索框的位置进行了重新调整，改变了其行为，以便在每个上下文基础上回撷你的搜索词。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对详情面板的增强:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改进了在&lt;strong&gt;My Assets&lt;/strong&gt;上下文中管理包的流程，通过优化详情面板中的操作按钮。最常见的操作作为菜单按钮中的默认操作，其他操作列在菜单中。还添加了&lt;strong&gt;In Project&lt;/strong&gt;标签，明确表示Asset Store包已经导入到你的项目并且是最新的。&lt;/li&gt;
&lt;li&gt;更新了查看Asset Store包时&lt;strong&gt;Import&lt;/strong&gt;按钮的标签。下载更新的Asset Store包后，主操作按钮的标签是&lt;strong&gt;Import update #.# to project&lt;/strong&gt;，所以你需要明确需要将更新导入到你的项目。&lt;/li&gt;
&lt;li&gt;更新了从注册表中安装的包的文档链接的行为。你现在可以右击链接并选择&lt;strong&gt;Open in browser&lt;/strong&gt;或&lt;strong&gt;Open locally&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当你登出并试图查看Asset Store包的详细信息时，添加了一个用你的Unity ID登录的按钮。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他增强:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在查看My Assets上下文时更新了Filters菜单中的值。&lt;/li&gt;
&lt;li&gt;更新了Filters控制的标签，以便显示选定的值而不是上一级别的类别。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;android&#34;&gt;Android &lt;a href=&#34;#android&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;添加了针对Android的Addressables包（&lt;code&gt;com.unity.addressables.android&lt;/code&gt;），为Addressables提供Play Asset Delivery支持。&lt;/li&gt;
&lt;li&gt;通过针对Android的Addressables包添加了纹理压缩格式定向支持，以将多种纹理压缩格式打包到Android资产包中。在安装时，只根据设备的移动GPU构建APK，使得加载和渲染纹理更快，且内存占用更少。&lt;/li&gt;
&lt;li&gt;添加了&lt;code&gt;ApplicationExitInfo&lt;/code&gt; API，提供关于应用程序崩溃和应用程序无响应（ANR）错误的信息。&lt;/li&gt;
&lt;li&gt;进行了以下改进:
&lt;ul&gt;
&lt;li&gt;设置&lt;code&gt;GameActivity&lt;/code&gt;为默认应用程序入口点，以提供对Android和你的应用程序之间交互的更多控制。&lt;/li&gt;
&lt;li&gt;将最低支持的Android版本提高到6.0（API级别23）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;profiler&#34;&gt;Profiler &lt;a href=&#34;#profiler&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在Memory Profiler中添加了对AudioClip和Shader的元数据支持。&lt;/li&gt;
&lt;li&gt;在Profiler窗口中添加了一个Highlights模块。&lt;/li&gt;
&lt;li&gt;为CPU Profiler添加了一个新的Inverted Hierarchy视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;raytracing-api&#34;&gt;Raytracing API &lt;a href=&#34;#raytracing-api&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;射线追踪加速结构构建标志：新的射线追踪加速结构构建标志被引入到Unity的渲染器和RTAS API中。这些标志让你可以控制射线追踪内存使用、RTAS构建时间和射线追踪性能之间的权衡。开发者和艺术家可以使用新的标志来优化他们的场景和渲染器中的射线追踪性能。&lt;/li&gt;
&lt;li&gt;Shader中的内联射线追踪：现在可以在光栅化和计算着色器中使用内联射线追踪，只要是面向具有DXR1.1能力的Windows平台、Xbox Series X/S和Playstation 5。开发者可以从着色器内部发送射线查询，遍历束定的射线追踪加速结构并进行交叉测试。这使他们可以实现各种硬件加速的射线追踪效果和模拟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;shader-graph&#34;&gt;Shader Graph &lt;a href=&#34;#shader-graph&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;添加了UGUI对Shader Graph的支持。Shader Graph现在在URP和HDRP中都为Canvas提供了子目标。UI艺术家可以使用Shader Graph为他们的UI元素创建自定义shader。定义UI元素的整体外观和风格，创建动画UI效果，并定义自定义按钮状态，同时使用更少的纹理内存。&lt;/li&gt;
&lt;li&gt;启用了Shader Graph Canvas主节点，以允许用户在HDRP，URP和Built-in中为Canvas创建UI shader。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;speedtree&#34;&gt;SpeedTree &lt;a href=&#34;#speedtree&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用传输遮罩在HDRP中提高SpeedTree的视觉质量，只在叶子上应用次表面散射。HDRP/Nature/SpeedTree8.shadergraph使用其次表面贴图作为传输遮罩节点，以消除树皮和小枝的非预期光传输。这也修复了过亮的广告牌照明与3D几何图形照明不匹配的问题。&lt;/p&gt;
&lt;h2 id=&#34;splines&#34;&gt;Splines &lt;a href=&#34;#splines&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;您现在可以在Spline对象上存储个性化数据。此外，编辑Inspector中点的界面已得到增强，某些API已向公众开放。当你在处理splines时，现在可以使用新的Scene视图上下文菜单。&lt;/p&gt;
&lt;h2 id=&#34;test-framework&#34;&gt;Test Framework &lt;a href=&#34;#test-framework&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据测试级别启用了重新尝试和重复测试。一旦测试完成了第一次迭代，Editor就会重新尝试或重复测试。将命令行参数传递给Editor以:
&lt;ul&gt;
&lt;li&gt;重复x次运行测试x次数或直到失败。这对测试不稳定的测试很有用。&lt;/li&gt;
&lt;li&gt;重试x，如果测试失败。这将运行测试x次数或直到成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过使用Editor命令行新参数&lt;code&gt;-randomOrderSeed x&lt;/code&gt;，你可以按随机顺序运行测试，其中&lt;code&gt;x&lt;/code&gt;是不同于0的整数。如果在项目中添加了新的测试，通过相同的种子将会保持随机顺序，新的测试将根据随机列表相应地放置。&lt;/li&gt;
&lt;li&gt;新增&lt;code&gt;TestFileReferences.json&lt;/code&gt;在播放器的构建步骤上生成，以便稍后由Test runners使用以丰富运行部分的数据。&lt;/li&gt;
&lt;li&gt;UTF版本现在会自动为SRP测试更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;version-control&#34;&gt;Version control &lt;a href=&#34;#version-control&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;添加了一个项目选项，用于支持追踪存在于项目根文件夹之外的磁盘上的包。&lt;/p&gt;
&lt;h2 id=&#34;vfx-graph&#34;&gt;VFX Graph &lt;a href=&#34;#vfx-graph&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在模板窗口中添加了具有预定义效果的VFX Graph资产。你可以将这些模板作为自己效果的起点。&lt;/li&gt;
&lt;li&gt;新增了自定义HLSL块和操作员。自定义HLSL节点让您在粒子模拟期间执行自己的代码。在VFX Graph上下文中，您可以使用操作员进行横向流动，或者使用块进行纵向流动。&lt;/li&gt;
&lt;li&gt;添加了URP Decals与VFX Graph。现在在VFX Graph中支持URP Lit decal输出，使得在URP上创建符合场景照明和材料的惊艳decal效果成为可能。&lt;/li&gt;
&lt;li&gt;在HDRP和URP中为Shader Graph烟雾效果添加照明。这意味着您可以创建使用六方向照明的lit shader的自定义烟雾shader。&lt;/li&gt;
&lt;li&gt;扩展了URP中的Camera Depth和Color buffer行为。这意味着您可以使用深度缓冲区进行基于深度的碰撞，或者采样色彩缓冲区以创建自定义效果。&lt;/li&gt;
&lt;li&gt;在URP中添加了对运动向量的支持。&lt;/li&gt;
&lt;li&gt;对Shader Graph添加了对运动向量的支持。&lt;/li&gt;
&lt;li&gt;新增了使用VFX Graph的Shade Graph集成来使用材料变体工作流覆盖VFX Output中设置的能力。&lt;/li&gt;
&lt;li&gt;启用了VFX instancing，可以公开纹理，网格或图形缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web-platform-previously-webgl&#34;&gt;Web platform (previously WebGL) &lt;a href=&#34;#web-platform-previously-webgl&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Unity网页构建现在可以利用Emscripten工具链中最新的大小和性能优化。&lt;/li&gt;
&lt;li&gt;增加了支持指定您希望应用程序在运行时启动的浏览器类型及其可执行路径。您可以通过命令行或在&amp;quot;构建设置&amp;quot;窗口中的GUI设置来指定这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xr&#34;&gt;XR &lt;a href=&#34;#xr&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新增了对Hololens自动化的支持。&lt;/li&gt;
&lt;li&gt;扩展了Unity在URP，HDRP和内建渲染管线中对色调映射和输出到HDR显示器的集成支持，以支持具有HDR显示器的XR设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论 &lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;搬砖愉快！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UGUI中文教程(自翻译)</title>
      <link>https://www.chenqiaoqian.com/2023/07/09/2023-07-09-unity-ugui/</link>
      <pubDate>Sun, 09 Jul 2023 11:13:34 +0800</pubDate>
      
      <guid>https://www.chenqiaoqian.com/2023/07/09/2023-07-09-unity-ugui/</guid>
      <description>&lt;p&gt;Unity UI 是一组用于开发游戏和应用程序用户界面的工具。它是一个基于 GameObject 的 UI 系统，使用组件和游戏视图来排列、定位和设置用户界面的样式。 您无法使用Unity UI在Unity编辑器中创建或更改用户界面。&lt;/p&gt;
&lt;h3 id=&#34;unity-ui-unity-user-interface&#34;&gt;Unity UI: Unity User Interface &lt;a href=&#34;#unity-ui-unity-user-interface&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Unity UI 是一个用于开发游戏和应用程序用户界面的 UI 工具包。它是一个基于 GameObject 的 UI 系统，使用组件和游戏视图来排列、定位和设置用户界面的样式。 您无法使用Unity UI在Unity编辑器中创建或更改用户界面。&lt;/p&gt;
&lt;p&gt;本文档介绍了 Unity UI 功能，例如创建 Canvas、定位和动画元素、定义用户交互以及自动调整布局大小。&lt;/p&gt;
&lt;h3 id=&#34;canvas&#34;&gt;Canvas &lt;a href=&#34;#canvas&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;canvas画布&#34;&gt;Canvas(画布) &lt;a href=&#34;#canvas%e7%94%bb%e5%b8%83&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;画布是所有UI元素应该所在的区域。画布是一个带有Canvas组件的游戏对象，所有的UI元素都必须是这种画布的子对象。
使用菜单 GameObject &amp;gt; UI &amp;gt; Image 创建新的UI元素，比如一个Image，如果场景中尚未存在画布，将自动创建一个Canvas。UI元素被创建为此Canvas的子对象。
画布区域在场景视图中显示为矩形。这样可以轻松定位 UI 元素，而无需始终保持游戏视图可见。
Canvas使用EventSystem对象来帮助消息系统。&lt;/p&gt;
&lt;h4 id=&#34;draw-order-of-elements元素绘制顺序&#34;&gt;Draw order of elements(元素绘制顺序) &lt;a href=&#34;#draw-order-of-elements%e5%85%83%e7%b4%a0%e7%bb%98%e5%88%b6%e9%a1%ba%e5%ba%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在Canvas中，UI元素按照它们在Hierarchy中出现的顺序进行绘制。首先绘制第一个子元素，然后是第二个子元素，依此类推。如果两个UI元素重叠，后出现的元素将会覆盖在先出现的元素之上。&lt;/p&gt;
&lt;p&gt;要改变元素覆盖的顺序，只需通过拖动它们在Hierarchy中的位置即可。也可以通过在Transform组件上使用以下方法来控制顺序：SetAsFirstSibling，SetAsLastSibling，和SetSiblingIndex。&lt;/p&gt;
&lt;h4 id=&#34;render-modes渲染模式&#34;&gt;Render Modes(渲染模式) &lt;a href=&#34;#render-modes%e6%b8%b2%e6%9f%93%e6%a8%a1%e5%bc%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Canvas具有渲染模式设置，可以用来将其设置为在屏幕空间或世界空间中渲染。&lt;/p&gt;
&lt;h5 id=&#34;screen-space---overlay屏幕空间---叠加模式&#34;&gt;Screen Space - Overlay(屏幕空间 - 叠加模式) &lt;a href=&#34;#screen-space---overlay%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4---%e5%8f%a0%e5%8a%a0%e6%a8%a1%e5%bc%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;此渲染模式将UI元素放置在场景顶部的屏幕上进行渲染。如果屏幕尺寸调整或分辨率变化，Canvas将自动改变大小以匹配这些变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_Canvas_Screenspace_Overlay.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;screen-space---camera屏幕空间-相机模式&#34;&gt;Screen Space - Camera(屏幕空间-相机模式) &lt;a href=&#34;#screen-space---camera%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4-%e7%9b%b8%e6%9c%ba%e6%a8%a1%e5%bc%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;这与屏幕空间 - 叠加相似，但在这种渲染模式下，Canvas被放置在指定相机前面的一定距离处。UI元素由这台相机渲染，这意味着相机设置会影响UI的外观。如果相机设置为透视图，UI元素将呈现透视效果，透视变形的程度可以通过相机视野调整。如果屏幕尺寸调整，分辨率变化，或相机视锥体变化，Canvas将自动改变大小以匹配这些变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_Canvas_Screenspace_Camera.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;world-space世界空间&#34;&gt;World Space(世界空间) &lt;a href=&#34;#world-space%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;在这种渲染模式下，Canvas将像场景中的任何其他对象一样运作。Canvas的大小可以通过其Rect Transform手动设置，UI元素将根据3D位置在场景中的其他对象前面或者后面进行渲染。这对于应该成为世界一部分的UI非常有用。这也被称为&amp;quot;diegetic interface&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_Canvas_Worldspace.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;basic-layout&#34;&gt;Basic Layout &lt;a href=&#34;#basic-layout&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;basic-layout基础布局&#34;&gt;Basic Layout(基础布局) &lt;a href=&#34;#basic-layout%e5%9f%ba%e7%a1%80%e5%b8%83%e5%b1%80&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在本节中，我们将介绍如何相对于Canvas和其他UI元素定位UI元素。如果你想在阅读的时候进行自我测试，你可以通过菜单GameObject -&amp;gt; UI -&amp;gt; Image来创建一个图像。&lt;/p&gt;
&lt;h4 id=&#34;the-rect-tool矩形工具&#34;&gt;The Rect Tool(矩形工具) &lt;a href=&#34;#the-rect-tool%e7%9f%a9%e5%bd%a2%e5%b7%a5%e5%85%b7&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;每个UI元素在布局时都被表示为一个矩形。这个矩形可以在场景视图中使用工具栏的矩形工具进行操作。矩形工具既可以用于Unity的2D特性，也可以用于UI，事实上，甚至可以用于3D对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_Rect_Tool_Button.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;矩形工具可以用来移动、调整大小并旋转UI元素。一旦你选中了一个UI元素，你可以通过在矩形内任何地方点击并拖动来移动它。你可以点击边缘或角落并拖动来调整其大小。可以通过将光标悬停在角落稍远的地方，直到鼠标光标看起来像一个旋转符号，然后在任一方向上点击并拖动来旋转元素。&lt;/p&gt;
&lt;p&gt;就像其他工具一样，矩形工具使用工具栏中设置的当前的轴心模式和空间。在使用UI时，通常最好将它们设定为Pivot和Local。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_Pivot_Local_Buttons.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;rect-transform矩形变换&#34;&gt;Rect Transform(矩形变换) &lt;a href=&#34;#rect-transform%e7%9f%a9%e5%bd%a2%e5%8f%98%e6%8d%a2&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;形变换是一种新的变换组件，用于所有的UI元素，而不是使用常规的变换组件。、&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_RectTransform.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;矩形变换拥有常规变换的位置、旋转和缩放，但它也有宽度和高度，用于指定矩形的尺寸。&lt;/p&gt;
&lt;h5 id=&#34;resizing-versus-scaling调整大小与缩放&#34;&gt;Resizing Versus Scaling(调整大小与缩放) &lt;a href=&#34;#resizing-versus-scaling%e8%b0%83%e6%95%b4%e5%a4%a7%e5%b0%8f%e4%b8%8e%e7%bc%a9%e6%94%be&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;当矩形工具用于改变物体的大小时，通常是针对2D系统中的Sprites和3D Objects，它将改变物体的局部尺度。然而，当它被用于带有矩形变换的物体时，它将会改变宽度和高度，而保持本地缩放不变。这种调整大小不会影响字体大小、切片图像的边框等。&lt;/p&gt;
&lt;h5 id=&#34;pivot中心点&#34;&gt;Pivot(中心点) &lt;a href=&#34;#pivot%e4%b8%ad%e5%bf%83%e7%82%b9&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;旋转，大小和比例修改都是围绕中心点进行的，因此中心点的位置影响旋转，大小调整或缩放的结果。当工具栏的&amp;quot;Pivot&amp;quot;按钮设置为&amp;quot;Pivot&amp;quot;模式时，可以在&amp;quot;Scene View&amp;quot;中移动&amp;quot;Rect Transform&amp;quot;的中心点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_PivotRotate.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;anchors锚点&#34;&gt;Anchors(锚点) &lt;a href=&#34;#anchors%e9%94%9a%e7%82%b9&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;矩形变换包括一个名为锚点的布局概念。在场景视图中，锚点显示为四个小三角形手柄，并且在检查器中也显示锚点信息。&lt;/p&gt;
&lt;p&gt;如果矩形变换的父对象也是矩形变换，那么子矩形变换可以以各种方式锚定到父矩形变换。例如，子对象可以锚定到父对象的中心，或者锚定到四个角中的一个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_Anchored1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;锚点还允许子对象随着父对象的宽度或高度一起拉伸。矩形的每个角都有一个固定的偏移量到其对应的锚点，即矩形的左上角有一个固定的偏移量到左上角的锚点等。这样，矩形的不同角落可以锚定到父矩形中的不同点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_Anchored2.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;锚点的位置是以父矩形的宽度和高度的分数（或百分比）来定义的。0.0（0%）对应于左侧或底侧，0.5（50%）对应于中间，1.0（100%）对应于右侧或顶侧。但是锚点不仅限于边缘和中间，它们可以锚定到父矩形内的任何点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_Anchored3.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;你可以单独拖动每一个锚点，或者如果它们在一起，你可以通过点击它们中间的位置并拖动来一起拖动它们。如果你在拖动锚点的同时按住Shift键，矩形的对应角将会和锚点一起移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_Anchored4.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;锚点手柄的一个有用特性是，它们会自动吸附到兄弟矩形的锚点，以便进行精确定位。&lt;/p&gt;
&lt;h5 id=&#34;anchor-presets锚点预设按钮&#34;&gt;Anchor presets(锚点预设按钮) &lt;a href=&#34;#anchor-presets%e9%94%9a%e7%82%b9%e9%a2%84%e8%ae%be%e6%8c%89%e9%92%ae&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;在Inspector中，可以在 Rect Transform 组件的左上角找到锚点预设按钮。点击该按钮会打开锚点预设下拉菜单。在这里，你可以快速选择一些最常用的锚定选项。你可以将UI元素锚定到父元素的侧边或中间，或者随着父元素的大小一起拉伸。水平和垂直的锚定是独立的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_AnchorPreset.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;锚点预设按钮如果有选中的预设选项，会显示当前选中的预设选项。如果水平或垂直轴上的锚点设置的位置与预设中的任何位置不同，将显示自定义选项。&lt;/p&gt;
&lt;h5 id=&#34;anchor-and-position-fields-in-the-inspector检查器中的锚点和位置字段&#34;&gt;Anchor and position fields in the Inspector(检查器中的锚点和位置字段) &lt;a href=&#34;#anchor-and-position-fields-in-the-inspector%e6%a3%80%e6%9f%a5%e5%99%a8%e4%b8%ad%e7%9a%84%e9%94%9a%e7%82%b9%e5%92%8c%e4%bd%8d%e7%bd%ae%e5%ad%97%e6%ae%b5&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;如果锚点数字字段还未显示，你可以点击锚点展开箭头来显示。Anchor Min 对应场景视图中的左下锚点手柄，而 Anchor Max 则对应右上手柄。&lt;/p&gt;
&lt;p&gt;根据锚点是一起（产生固定的宽度和高度）还是分开（使矩形随父矩形一起拉伸），矩形的位置字段显示方式会有所不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_RectTransform_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当所有的锚点手柄在一起时，显示的字段有Pos X、Pos Y、Width和Height。Pos X和Pos Y的值表示相对于锚点的枢轴位置。&lt;/p&gt;
&lt;p&gt;当锚点分开时，字段部分或全部变为Left、Right、Top和Bottom。这些字段定义了由锚点定义的矩形内的填充。如果锚点在水平方向上分开，则使用Left和Right字段，如果在垂直方向上分开，则使用Top和Bottom字段。&lt;/p&gt;
&lt;p&gt;注意，通常情况下，更改锚点或枢轴字段中的值会对定位值进行反向调整，以使矩形保持原位。在不需要这种情况时，可以通过在检查器中点击R键开启Raw edit模式。这将导致Anchor和Pivot的值可以更改，而其他值不会因此变化。由于矩形的位置和大小取决于锚点和枢轴的值，所以这可能会导致矩形在视觉上移动或重新调整大小。&lt;/p&gt;
&lt;h3 id=&#34;visual-components&#34;&gt;Visual Components &lt;a href=&#34;#visual-components&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;visual-components视觉组件&#34;&gt;Visual Components(视觉组件) &lt;a href=&#34;#visual-components%e8%a7%86%e8%a7%89%e7%bb%84%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;随着UI系统的引入，已经添加了新的组件，这些组件将帮助你创建特定于GUI的功能。此部分将介绍可以创建的新组件的基础知识。&lt;/p&gt;
&lt;h4 id=&#34;text&#34;&gt;Text &lt;a href=&#34;#text&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_TextInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Text组件，也被称为Label，具有一个用于输入要显示的文本的文本区域。可以设置字体、字体样式、字体大小，以及文本是否具有富文本功能。&lt;/p&gt;
&lt;p&gt;有选项可以设置文本的对齐方式，以及横向和纵向溢出的设置，这些设置可以控制如果文本的尺寸大于矩形的宽度或高度时会发生什么，还有一个Best Fit选项，使文本重新调整大小以适应可用空间。&lt;/p&gt;
&lt;h4 id=&#34;image&#34;&gt;Image &lt;a href=&#34;#image&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ImageInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Image拥有一个Rect Transform组件和一个Image组件。可以将精灵应用到Image组件上，在Target Graphic字段下，并可以在Color字段中设置其颜色。也可以将材质应用到Image组件。Image Type字段定义了应用的精灵将如何显示，选项包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Simple - 等比例缩放整个精灵。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sliced - 利用3x3的精灵分割，所以调整大小不会扭曲角落，只有中心部分会被拉伸。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tiled - 类似于Sliced，但是将中心部分平铺（重复）而不是拉伸。对于完全无边框的精灵，整个精灵都会被平铺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Filled - 以与Simple相同的方式显示精灵，除了它会从一个定义的方向、方式和量填充精灵。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择Set Native Size选项，当选择了Simple或Filled时显示，会将图像重置为原始精灵大小。&lt;/p&gt;
&lt;p&gt;可以通过从&amp;rsquo;Texture Type&amp;rsquo;设置中选择Sprite(2D / UI)来导入图片作为UI精灵。精灵具有附加的导入设置，与旧的GUI精灵相比，最大的不同是增加了精灵编辑器。精灵编辑器提供了9切分图像的选项，这可以将图像分成9个区域，这样如果精灵调整大小，角落不会拉伸或扭曲。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SpriteEditor.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;raw-image&#34;&gt;Raw Image &lt;a href=&#34;#raw-image&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Image组件需要一个精灵，而Raw Image则需要一个纹理（没有边界等）。只有在必要的情况下才应使用Raw Image，否则在大多数情况下Image将是适合的。&lt;/p&gt;
&lt;h4 id=&#34;mask&#34;&gt;Mask &lt;a href=&#34;#mask&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Mask并不是一个可见的UI控件，而是一种修改控件子元素外观的方式。掩码将子元素限制在父元素的形状内（也就是说，&amp;ldquo;掩蔽&amp;rdquo;）。所以，如果子元素大于父元素，那么只有适应父元素的子元素部分才会可见。&lt;/p&gt;
&lt;h4 id=&#34;effects&#34;&gt;Effects &lt;a href=&#34;#effects&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;视觉组件也可以应用各种简单的效果，如简单的阴影或轮廓。&lt;/p&gt;
&lt;h3 id=&#34;interaction-components&#34;&gt;Interaction Components &lt;a href=&#34;#interaction-components&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;interaction-components交互组件&#34;&gt;Interaction Components(交互组件) &lt;a href=&#34;#interaction-components%e4%ba%a4%e4%ba%92%e7%bb%84%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;这部分涵盖了UI系统中处理交互的组件，如鼠标或触摸事件以及使用键盘或控制器的交互。&lt;/p&gt;
&lt;p&gt;交互组件本身不可见，必须与一个或多个视觉组件组合起来才能正确工作。&lt;/p&gt;
&lt;h4 id=&#34;common-functionality公用功能&#34;&gt;Common Functionality(公用功能) &lt;a href=&#34;#common-functionality%e5%85%ac%e7%94%a8%e5%8a%9f%e8%83%bd&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;大部分交互组件都有一些共同点。它们都是可选择的，这意味着它们有共享的内置功能，可以用于可视化状态之间的过渡（正常、高亮、按下、禁用），并且可以使用键盘或控制器导航到其他可选择的项目。&lt;/p&gt;
&lt;p&gt;交互组件至少有一个UnityEvent，在用户以特定方式与组件交互时被触发。UI系统捕捉并记录了从附加到UnityEvent的代码传出的任何异常。&lt;/p&gt;
&lt;h4 id=&#34;button&#34;&gt;Button &lt;a href=&#34;#button&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Button有一个OnClick UnityEvent，用于定义当点击时它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ButtonExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;toggle&#34;&gt;Toggle &lt;a href=&#34;#toggle&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Toggle有一个IsOn复选框，用于确定Toggle当前是打开还是关闭状态。当用户点击Toggle时，这个值会翻转，相应地，视觉上的勾选标记也可以打开或关闭。它还有一个OnValueChanged UnityEvent，用于定义当值发生变化时它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;toggle-group&#34;&gt;Toggle Group &lt;a href=&#34;#toggle-group&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Toggle Group可以用来组合一组彼此独立的Toggle。属于同一组的Toggle被约束在一起，一次只能选择其中一个 - 选择其中一个会自动取消选择所有其他Toggle。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleGroupExample.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;slider&#34;&gt;Slider &lt;a href=&#34;#slider&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Slider具有一个十进制数值Value，用户可以在最小值和最大值之间拖动它。它可以是水平的也可以是垂直的。它还有一个OnValueChanged UnityEvent，用于定义当值发生变化时它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SliderExample.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;scrollbar&#34;&gt;Scrollbar &lt;a href=&#34;#scrollbar&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Scrollbar有一个十进制数值Value，范围在0和1之间。当用户拖动滚动条时，该值相应地进行变化。&lt;/p&gt;
&lt;p&gt;滚动条常与Scroll Rect和Mask一起使用，以创建滚动视图。Scrollbar有一个范围在0和1之间的Size值，用来确定手柄占整个滚动条长度的比例是多少。这通常是由另一个组件控制的，用来指示在滚动视图中可见的内容占总内容的比例有多大。Scroll Rect组件可以自动完成这个工作。&lt;/p&gt;
&lt;p&gt;滚动条可以是水平的，也可以是垂直的。它还有一个OnValueChanged UnityEvent，用于定义当值变化时，它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollbarExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dropdown&#34;&gt;Dropdown &lt;a href=&#34;#dropdown&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Dropdown有一个可供选择的选项列表。每个选项可以指定一个文本字符串和可选的图像，可以在检查器中设置，也可以从代码动态设置。它有一个OnValueChanged UnityEvent，用于定义当当前选择的选项发生改变时它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownExample.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;input-field&#34;&gt;Input Field &lt;a href=&#34;#input-field&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Input Field用于使用户可以编辑Text Element的文本。它有一个UnityEvent，用于定义当文本内容发生变化时它将执行什么操作，还有另一个UnityEvent，用于定义当用户完成编辑时它将执行什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_InputFieldExample.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;scroll-rect-scroll-view&#34;&gt;Scroll Rect (Scroll View) &lt;a href=&#34;#scroll-rect-scroll-view&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当需要在小区域内显示占用大量空间的内容时，可以使用Scroll Rect。Scroll Rect提供了滚动内容的功能。&lt;/p&gt;
&lt;p&gt;通常，Scroll Rect与Mask组合使用，以创建滚动视图，其中只有Scroll Rect内部的可滚动内容是可见的。它还可以额外地与一或两个Scrollbar组合使用，可以拖动它们进行水平或垂直滚动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollRectExample.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;animation-integration&#34;&gt;Animation Integration &lt;a href=&#34;#animation-integration&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Animation允许使用Unity的动画系统对控制状态间的每个过渡进行完全动画化。由于可以同时动画化的属性数量，这是过渡模式中最强大的一种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_ButtonInspectorAnimation.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要使用Animation过渡模式，需要将Animator组件附加到控制元素上。可以通过点击&amp;quot;Auto Generate Animation&amp;quot;自动完成。这也会生成一个已经设置了状态的Animator控制器，需要保存。&lt;/p&gt;
&lt;p&gt;新的Animator控制器可以立即使用。与大多数Animator控制器不同，此控制器还存储控制器过渡的动画，如果需要，可以进行定制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_ButtonAnimator.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;例如，如果选择了一个附有Animator控制器的Button元素，则可以通过打开Animation窗口（Window&amp;gt;Animation）编辑按钮每个状态的动画。&lt;/p&gt;
&lt;p&gt;有一个Animation Clip弹出菜单可以选择所需的剪辑。可从&amp;quot;Normal&amp;quot;、&amp;ldquo;Highlighted&amp;rdquo;、&amp;ldquo;Pressed&amp;quot;和&amp;quot;Disabled&amp;quot;中选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUI_ButtonAnimationWindow.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Normal状态由按钮元素本身的值设置，可以为空。在所有其他状态中，最常见的配置是时间线开始时的单个关键帧。状态之间的过渡动画将由Animator处理。&lt;/p&gt;
&lt;p&gt;例如，可以通过从Animation Clip弹出菜单中选择Highlighted状态，并将播放头放在时间线开始处，来更改Highlighted状态下按钮的宽度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择录制按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在检查器中更改按钮的宽度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出录制模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;切换到播放模式，看看在突出显示时按钮如何变大。&lt;/p&gt;
&lt;p&gt;任何数量的属性都可以在此关键帧中设置其参数。&lt;/p&gt;
&lt;p&gt;多个按钮可以通过共享Animator控制器来共享相同的行为。&lt;/p&gt;
&lt;p&gt;UI动画过渡模式与Unity的旧版动画系统不兼容。你应该仅使用Animator组件。&lt;/p&gt;
&lt;h3 id=&#34;auto-layout&#34;&gt;Auto Layout &lt;a href=&#34;#auto-layout&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;auto-layout自动布局&#34;&gt;Auto Layout(自动布局) &lt;a href=&#34;#auto-layout%e8%87%aa%e5%8a%a8%e5%b8%83%e5%b1%80&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Rect Transform布局系统具有足够的灵活性，可以处理许多不同类型的布局，并且它还允许以完全自由形式放置元素。但是，有时可能需要更加结构化的布局。&lt;/p&gt;
&lt;p&gt;自动布局系统提供了将元素放置在嵌套布局组中的方法，例如水平组，垂直组或网格。它还允许元素根据所包含的内容自动调整大小。例如，一个按钮可以动态地调整大小以精确地适应其文本内容加上一些填充。&lt;/p&gt;
&lt;p&gt;自动布局系统是基于基本的Rect Transform布局系统构建的系统。可以选择在部分或所有元素上使用。&lt;/p&gt;
&lt;h4 id=&#34;understanding-layout-elements理解布局元素&#34;&gt;Understanding Layout Elements(理解布局元素) &lt;a href=&#34;#understanding-layout-elements%e7%90%86%e8%a7%a3%e5%b8%83%e5%b1%80%e5%85%83%e7%b4%a0&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;自动布局系统基于layout elements(布局元素)和layout controllers(布局控制器)的概念。layout elements(布局元素)是具有Rect Transform和其他可选组件的游戏对象。layout elements(布局元素)不直接设置自己的大小，但作为layout controllers(布局控制器)的其他组件可以使用它们提供的信息来计算它们应使用的大小。&lt;/p&gt;
&lt;p&gt;布局元素有定义其自身的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimum width(最小宽度)&lt;/li&gt;
&lt;li&gt;Minimum height(最小高度)&lt;/li&gt;
&lt;li&gt;Preferred width(首选宽度)&lt;/li&gt;
&lt;li&gt;Preferred height(首选高度)&lt;/li&gt;
&lt;li&gt;Flexible width(灵活的宽度)&lt;/li&gt;
&lt;li&gt;Flexible height(灵活的高度)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用布局元素提供的信息的布局控制器组件示例包括Content Size Fitter和各种Layout Group组件。布局组中的布局元素大小的基本原则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先分配最小尺寸&lt;/li&gt;
&lt;li&gt;如果有足够的可用空间，则会分配首选大小&lt;/li&gt;
&lt;li&gt;如果有额外的可用空间，则分配灵活的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何带有矩形变换的游戏对象都可以用作布局元素。默认情况下，它们的最小尺寸、首选尺寸和灵活尺寸均为 0。某些组件在添加到游戏对象时将更改这些布局属性。&lt;/p&gt;
&lt;p&gt;图像和文本组件是提供布局元素属性的组件的两个示例。他们更改首选宽度和高度以匹配精灵或文本内容。&lt;/p&gt;
&lt;h4 id=&#34;layout-element-component布局元素组件&#34;&gt;Layout Element Component(布局元素组件) &lt;a href=&#34;#layout-element-component%e5%b8%83%e5%b1%80%e5%85%83%e7%b4%a0%e7%bb%84%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果你想要覆盖最小，首选，或者灵活的尺寸，你可以通过在游戏对象上添加一个布局元素组件来达到目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_LayoutElementInspector.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;布局元素组件允许你覆盖一个或多个布局属性的值。启用你想要覆盖的属性的复选框，然后指定你想要覆盖的值。&lt;/p&gt;
&lt;h4 id=&#34;understanding-layout-controllers-理解布局控制器&#34;&gt;Understanding Layout Controllers (理解布局控制器) &lt;a href=&#34;#understanding-layout-controllers-%e7%90%86%e8%a7%a3%e5%b8%83%e5%b1%80%e6%8e%a7%e5%88%b6%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;布局控制器是一类组件，它们负责控制一个或多个布局元素的大小，可能还包括位置，这里的布局元素指带有矩形变换(Rect Transforms)的游戏对象。布局控制器可能会控制其自身的布局元素（即它本身所在的游戏对象），或者控制子布局元素。&lt;/p&gt;
&lt;p&gt;充当布局控制器的组件本身也可以同时充当布局元素。&lt;/p&gt;
&lt;h4 id=&#34;content-size-fitter内容尺寸适配器&#34;&gt;Content Size Fitter(内容尺寸适配器) &lt;a href=&#34;#content-size-fitter%e5%86%85%e5%ae%b9%e5%b0%ba%e5%af%b8%e9%80%82%e9%85%8d%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Content Size Fitter 充当布局控制器，控制其自身布局元素的大小。查看自动布局系统实际运行的最简单方法是将 Content Size Fitter 组件添加到带有 Text 组件的游戏对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ContentSizeFitterInspector.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果将“Horizontal Fit”或“Vertical Fit”设置为“Preferred”，则矩形变换将调整其宽度和/或高度以适合文本内容。&lt;/p&gt;
&lt;h4 id=&#34;aspect-ratio-fitter宽高比适配器&#34;&gt;Aspect Ratio Fitter(宽高比适配器) &lt;a href=&#34;#aspect-ratio-fitter%e5%ae%bd%e9%ab%98%e6%af%94%e9%80%82%e9%85%8d%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Aspect Ratio Fitter 用作布局控制器，控制其自身布局元素的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_AspectRatioFitterInspector.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;它可以调整高度以适应宽度，反之亦然，也可以使元素适合其父级或包围其父级。 Aspect Ratio Fitter 不考虑布局信息，例如最小尺寸和首选尺寸。&lt;/p&gt;
&lt;h4 id=&#34;layout-groups布局组&#34;&gt;Layout Groups(布局组) &lt;a href=&#34;#layout-groups%e5%b8%83%e5%b1%80%e7%bb%84&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;布局组作为一个布局控制器，它控制其子布局元素的大小和位置。例如，水平将其子元素并排排列，网格布局组则将其子元素放置在网格中。
布局组并不控制它自己的大小。相反，它自身作为一个布局元素，可能会被其他布局控制器控制或者手动设置。
无论布局组被分配了什么大小，它在大多数情况下都会尝试为每一个子布局元素分配适当的空间，这基于他们报告的最小，首选和灵活的尺寸。而且，布局组还可以通过这种方式任意嵌套。&lt;/p&gt;
&lt;h4 id=&#34;driven-rect-transform-properties驱动的矩形变换属性&#34;&gt;Driven Rect Transform properties(驱动的矩形变换属性) &lt;a href=&#34;#driven-rect-transform-properties%e9%a9%b1%e5%8a%a8%e7%9a%84%e7%9f%a9%e5%bd%a2%e5%8f%98%e6%8d%a2%e5%b1%9e%e6%80%a7&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;由于自动布局系统中的布局控制器可以自动控制某些UI元素的尺寸和位置，因此，那些尺寸和位置不应同时通过检视器或场景视图手动编辑。因为这些更改的值在下一次布局计算时将被布局控制器重置。
矩形变换有一个驱动属性的概念来解决这个问题。例如，将 Horizontal Fit 属性设置为“Minimum”或“Preferred”的 Content Size Fitter 将驱动同一游戏对象上矩形变换的宽度。宽度将显示为只读，并且矩形变换顶部的一个小信息框将通知一个或多个属性由 Conten Size Fitter 驱动。
除了防止手动编辑之外，驱动的矩形变换属性还有其他原因。只需更改游戏视图的分辨率或大小即可更改布局。这反过来又可以改变布局元素的大小或位置，从而改变驱动属性的值。但仅仅因为调整了游戏视图的大小而将场景标记为具有未保存的更改是不可取的。为了防止这种情况，驱动属性的值不会保存为场景的一部分，并且对它们的更改不会将场景标记为已更改。&lt;/p&gt;
&lt;h4 id=&#34;technical-details技术细节&#34;&gt;Technical Details(技术细节) &lt;a href=&#34;#technical-details%e6%8a%80%e6%9c%af%e7%bb%86%e8%8a%82&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;自动布局系统带有一些内置的组件，但也可以创建新的组件并以自定义的方式控制布局。这是通过让一个组件实现特定的接口实现的，这些接口会被自动布局系统识别。&lt;/p&gt;
&lt;h4 id=&#34;layout-interfaces布局接口&#34;&gt;Layout Interfaces(布局接口) &lt;a href=&#34;#layout-interfaces%e5%b8%83%e5%b1%80%e6%8e%a5%e5%8f%a3&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果一个组件实现了ILayoutElement接口，那么它就会被自动布局系统视为布局元素。&lt;/p&gt;
&lt;p&gt;如果一个组件实现了ILayoutGroup接口，那么它就应该驱动其子元素的Rect Transforms。&lt;/p&gt;
&lt;p&gt;如果一个组件实现了ILayoutSelfController接口，那么它就应该驱动自己的RectTransform。&lt;/p&gt;
&lt;h4 id=&#34;layout-calculations布局算法&#34;&gt;Layout Calculations(布局算法) &lt;a href=&#34;#layout-calculations%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;自动布局系统按照以下顺序评估和执行布局：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过在ILayoutElement组件上调用CalculateLayoutInputHorizontal，计算布局元素的最小值、首选值和灵活宽度。这按照从下到上的顺序执行，即先计算子元素，父元素在自身计算中可以考虑子元素的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过在ILayoutController组件上调用SetLayoutHorizontal，计算并设置布局元素的实际宽度。这按照从上到下的顺序进行，也就是说，在父元素之后计算子元素，因为子元素的宽度分配需要基于父元素中的全部宽度。此步骤之后，布局元素的Rect Transforms有了新的宽度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过在ILayoutElement组件上调用CalculateLayoutInputVertical，计算布局元素的最小值、首选值和灵活高度。这同样按照从下到上的顺序执行，即先计算子元素，然后父元素在自身的计算中可以考虑到子元素的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过在ILayoutController组件上调用SetLayoutVertical，计算和设置布局元素的实际高度。这按照从上到下的顺序进行，也就是说，在父元素之后计算子元素，因为子元素的高度分配需要基于父元素中可用的全部高度。此步骤之后，布局元素的Rect Transforms有了新的高度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如上所述，自动布局系统先评估宽度，然后评估高度。因此，计算出的高度可能会依赖于宽度，但计算出的宽度绝不会依赖于高度。&lt;/p&gt;
&lt;h4 id=&#34;triggering-layout-rebuild触发布局重建&#34;&gt;Triggering Layout Rebuild(触发布局重建) &lt;a href=&#34;#triggering-layout-rebuild%e8%a7%a6%e5%8f%91%e5%b8%83%e5%b1%80%e9%87%8d%e5%bb%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当一个组件上的属性改变可能导致当前布局不再有效时，需要进行布局重新计算。可以使用以下调用来触发：&lt;/p&gt;
&lt;p&gt;LayoutRebuilder.MarkLayoutForRebuild (transform as RectTransform);&lt;/p&gt;
&lt;p&gt;重建不会立即发生，而是在当前帧的结束时，也就是在绘制之前。之所以不立即重建，是因为这可能会导致在同一帧中多次重建布局，这对性能来说是不好的。&lt;/p&gt;
&lt;p&gt;触发重建的指导原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在可以更改布局的属性的setter中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这些回调中：&lt;/p&gt;
&lt;p&gt;OnEnable&lt;/p&gt;
&lt;p&gt;OnDisable&lt;/p&gt;
&lt;p&gt;OnRectTransformDimensionsChange&lt;/p&gt;
&lt;p&gt;OnValidate（仅在编辑器中需要，运行时不需要）&lt;/p&gt;
&lt;p&gt;OnDidApplyAnimationProperties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rich-text&#34;&gt;Rich Text &lt;a href=&#34;#rich-text&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;rich-text富文本&#34;&gt;Rich Text(富文本) &lt;a href=&#34;#rich-text%e5%af%8c%e6%96%87%e6%9c%ac&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;UI 元素和文本网格的文本可以包含多种字体样式和大小。 UI 系统和旧版 GUI 系统都支持富文本。 Text、GUIStyle、GUIText 和 TextMesh 类具有富文本设置，指示 Unity 在文本中查找标记标签。 Debug.Log函数还可以使用这些标记来增强代码中的错误报告。标签不会显示，但指示要应用于文本的样式更改。&lt;/p&gt;
&lt;h4 id=&#34;markup-format标记格式&#34;&gt;Markup format(标记格式) &lt;a href=&#34;#markup-format%e6%a0%87%e8%ae%b0%e6%a0%bc%e5%bc%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;标记系统的设计来自于HTML，但并不意味着严格符合标准的HTML。基本思想是文本的一部分可以被包含在一对匹配的标签之间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;We are &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt;not&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt; amused.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如示例所示，标签只是“尖括号”字符&amp;lt;和内的文本片段&amp;gt;。&lt;/p&gt;
&lt;p&gt;您将开始标记放在该部分的开头。标签内的文本表示其名称（在本例中为b）。&lt;/p&gt;
&lt;p&gt;您可以在该部分的末尾放置另一个标签。这是结束标签。它与开始标记具有相同的名称，但名称前面带有斜杠/字符。每个开始标签必须有一个相应的结束标签。如果不关闭开始标记，它将呈现为常规文本。&lt;/p&gt;
&lt;p&gt;这些标签不会直接显示给用户，而是被解释为对其所包含的文本进行样式设置的说明。上例中使用的标签b将粗体应用于单词“not”，因此文本在屏幕上显示为:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;标记的文本部分（包括包围它的标签）称为元素。&lt;/p&gt;
&lt;h4 id=&#34;nested-elements嵌套元素&#34;&gt;Nested elements(嵌套元素) &lt;a href=&#34;#nested-elements%e5%b5%8c%e5%a5%97%e5%85%83%e7%b4%a0&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;通过将一个元素&amp;quot;嵌套&amp;quot;在另一个元素内，可以将多种样式应用于文本的一部分。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;We are &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;i&lt;/span&gt;&amp;gt;definitely not&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;i&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt; amused
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;标签应用斜体样式，所以这将在屏幕上呈现为:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;注意关闭标签的顺序，它与打开标签的顺序相反。当你考虑到内部标签并不需要覆盖最外层元素的所有文本时，这个原因可能会更清晰。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;We are &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt;absolutely &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;i&lt;/span&gt;&amp;gt;definitely&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;i&lt;/span&gt;&amp;gt; not&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;b&lt;/span&gt;&amp;gt; amused
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;tag-parameters标签参数&#34;&gt;Tag parameters(标签参数) &lt;a href=&#34;#tag-parameters%e6%a0%87%e7%ad%be%e5%8f%82%e6%95%b0&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一些标签对文本有简单的全有或全无效果，但其他一些标签可能允许变化。例如，颜色标签需要知道应用哪种颜色。通过参数在标签中添加这样的信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;We are &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;green&lt;/span&gt;&amp;gt;green&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt;&amp;gt; with envy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;产生的结果是：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;请注意，结束标记不包含参数值。或者，该值可以用引号引起来，但这不是必需的。&lt;/p&gt;
&lt;p&gt;标记参数不能包含空格。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;We are &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;green&lt;/span&gt;&amp;gt;green&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt;&amp;gt; with envy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于字符两侧都有空格，因此不起作用&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;supported-tags支持的标签&#34;&gt;Supported tags(支持的标签) &lt;a href=&#34;#supported-tags%e6%94%af%e6%8c%81%e7%9a%84%e6%a0%87%e7%ad%be&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;以下列表描述了Unity支持的所有样式标签。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;标签&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例子&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将文本呈现为粗体。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;We are &amp;lt;b&amp;gt;not&amp;lt;/b&amp;gt; amused.&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将文本呈现为斜体。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;We are &amp;lt;i&amp;gt;usually&amp;lt;/i&amp;gt; not amused.&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据给定的像素值参数设置文本的大小。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;We are &amp;lt;size=50&amp;gt;largely&amp;lt;/size&amp;gt; unaffected.&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虽然这个标签可以用于Debug.Log，但你会发现，如果设置的大小过大，窗口栏和控制台的行间距看起来会很奇怪。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据参数值设置文本的颜色。颜色可以采用传统的HTML格式指定，即&lt;code&gt;#rrggbbaa&lt;/code&gt;&amp;hellip;其中字母对应表示颜色的红色，绿色，蓝色和alpha（透明度）值的十六进制数字对。例如，全不透明的青色将通过&lt;code&gt;color=#00ffffff&lt;/code&gt;进行指定&amp;hellip; 你可以用大写或小写指定十六进制值；&lt;code&gt;#FF0000&lt;/code&gt;等同于&lt;code&gt;#ff0000&lt;/code&gt;。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;We are &amp;lt;color=#ff0000ff&amp;gt;colorfully&amp;lt;/color&amp;gt; amused&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;另一个选择是使用颜色的名称。这样理解起来比较容易，但自然地，颜色的范围被限制了，而且总是假设颜色是完全不透明的。 &amp;lt;color=cyan&amp;gt;一些文本&lt;!-- raw HTML omitted --&gt; 可用的颜色名称在下面的表格中给出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;material&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这只对文本网格有用，并使用参数指定的材质渲染文本的一个部分。该值是关联到检查器显示的文本网格的材质数组的索引。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;We are &amp;lt;material=2&amp;gt;texturally&amp;lt;/material&amp;gt; amused&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;quad&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这只对文本网格有用，并能在文本中内联渲染一个图像。它接受参数来指定用于图像的材质，图像的像素高度，以及进一步的四个参数，表示要显示的图像的矩形区域。不同于其他标签，quad标签并未环绕某段文本，因此没有结束标签 - 斜杠字符被放在初始标签的末尾，以表示它是&amp;quot;自关闭&amp;quot;的。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;`&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这将选择渲染器材质数组中位置的材质，并将图像的高度设置为20像素。图像的矩形区域从由x，y，宽度和高度值给出的位置开始，这些值都是以纹理未缩放的宽度和高度的分数形式给出的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;supported-colors支持的颜色&#34;&gt;Supported colors(支持的颜色) &lt;a href=&#34;#supported-colors%e6%94%af%e6%8c%81%e7%9a%84%e9%a2%9c%e8%89%b2&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;下面列出了你可以在&lt;!-- raw HTML omitted --&gt;富文本标签中使用名称替代十六进制标签的颜色。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;*&lt;strong&gt;Color name*&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;*&lt;strong&gt;Hex value*&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;*&lt;strong&gt;Swatch*&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;aqua (same as cyan)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#00ffffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/CyanSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;black&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#000000ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/BlackSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;blue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#0000ffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/BlueSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;brown&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#a52a2aff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/BrownSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cyan (same as aqua)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#00ffffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/CyanSwatch2.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;darkblue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#0000a0ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/DarkblueSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fuchsia (same as magenta)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ff00ffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MagentaSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;green&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#008000ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GreenSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;grey&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#808080ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GreySwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lightblue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#add8e6ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/LightblueSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#00ff00ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/LimeSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;magenta (same as fuchsia)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ff00ffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MagentaSwatch2.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;maroon&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#800000ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MaroonSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;navy&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#000080ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/NavySwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;olive&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#808000ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/OliveSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;orange&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ffa500ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/OrangeSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;purple&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#800080ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/PurpleSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;red&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ff0000ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/RedSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;silver&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#c0c0c0ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/SilverSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;teal&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#008080ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/TealSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;white&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ffffffff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/WhiteSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;yellow&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;#ffff00ff&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/YellowSwatch.png&#34; alt=&#34;img&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Editor GUI(编辑器 GUI)&lt;/p&gt;
&lt;p&gt;默认情况下，编辑器 GUI 系统禁用了富文本，但可以通过自定义 GUIStyle 明确启用。应设定 richText 属性为 true，并将样式传递给对应的 GUI 函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GUIStyle style = new GUIStyle ();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;style.richText = true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GUILayout.Label(&amp;#34;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;30&lt;/span&gt;&amp;gt;Some &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;yellow&lt;/span&gt;&amp;gt;RICH&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;color&lt;/span&gt;&amp;gt; text&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;size&lt;/span&gt;&amp;gt;&amp;#34;,style);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;event&#34;&gt;Event &lt;a href=&#34;#event&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Event System(事件系统)&lt;/p&gt;
&lt;p&gt;事件系统是一种基于输入（包括键盘、鼠标、触摸或自定义输入）向应用程序中的对象发送事件的方式。事件系统由几个协同工作以发送事件的组件组成。&lt;/p&gt;
&lt;p&gt;当你向GameObject添加一个事件系统组件时，你会注意到它暴露的功能不多，这是因为事件系统本身被设计为事件系统模块之间的管理器和通信协调者。&lt;/p&gt;
&lt;p&gt;事件系统的主要角色如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理被选中的GameObject&lt;/li&gt;
&lt;li&gt;管理正在使用的输入模块&lt;/li&gt;
&lt;li&gt;管理射线投射（如果需要的话）&lt;/li&gt;
&lt;li&gt;根据需要更新所有的输入模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Input Modules(输入模块)
输入模块是你如何希望事件系统行为的主要逻辑存在的地方，它们用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理输入&lt;/li&gt;
&lt;li&gt;管理事件状态&lt;/li&gt;
&lt;li&gt;向场景对象发送事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在事件系统中，一次只能有一个输入模块处于活动状态，而且它们必须是事件系统组件同一GameObject上的组件。&lt;/p&gt;
&lt;p&gt;Raycasters(射线投射器)
射线投射器用于确定指针所在的位置。输入模块通常使用在场景中配置的射线投射器来计算指向设备所在的位置。默认存在3个提供的射线投射器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形射线投射器 - 用于UI元素&lt;/li&gt;
&lt;li&gt;2D物理射线投射器 - 用于2D物理元素&lt;/li&gt;
&lt;li&gt;物理射线投射器 - 用于3D物理元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你在你的场景中配置了2d/3d射线投射器，让非UI元素从输入模块接收消息就很简单了。只需附加一个实现了事件接口之一的脚本。关于这方面的例子，可以参见IPointerEnterHandler和IPointerClickHandler脚本参考页面。&lt;/p&gt;
&lt;h4 id=&#34;messaging-system消息系统&#34;&gt;Messaging System(消息系统) &lt;a href=&#34;#messaging-system%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;新的UI系统使用了一个旨在取代SendMessage的消息系统。该系统完全基于C#，旨在解决SendMessage系统中存在的一些问题。该系统使用自定义接口，可以在MonoBehaviour上实现，以表明该组件能够从消息系统接收回调。当调用次数被指定为目标GameObject时，将在所有实现了指定接口的GameObject的组件上发出调用，这些指定的接口就是调用要针对的。消息系统允许传递自定义用户数据，以及事件应传播的GameObject层次结构的深度；也就是说，它应该仅针对指定的GameObject执行，还是也应在子对象和父对象上执行。此外，消息框架提供了辅助函数，用于搜索并找到实现给定消息接口的GameObject。&lt;/p&gt;
&lt;p&gt;消息系统是通用的，不仅设计用于UI系统，还设计用于一般的游戏代码。添加自定义消息事件相对简单，它们将使用与UI系统用于所有事件处理的相同框架。&lt;/p&gt;
&lt;h5 id=&#34;defining-a-custom-message定义自定义消息&#34;&gt;Defining A Custom Message(定义自定义消息) &lt;a href=&#34;#defining-a-custom-message%e5%ae%9a%e4%b9%89%e8%87%aa%e5%ae%9a%e4%b9%89%e6%b6%88%e6%81%af&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;如果你希望定义一个自定义消息，这相对来说很简单。在UnityEngine.EventSystems命名空间中，有一个基础接口叫做&amp;rsquo;IEventSystemHandler&amp;rsquo;。任何从此接口派生的东西都可以被视为通过消息系统接收事件的目标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ICustomMessageTarget&lt;/span&gt; : IEventSystemHandler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// functions that can be called via the messaging system&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Message1();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Message2();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦定义了这个接口，那么它就可以由MonoBehaviour实现。当实现它时，它定义了如果针对这个MonoBehaviours的GameObject发出了给定的消息，将会执行的功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CustomMessageTarget&lt;/span&gt; : MonoBehaviour, ICustomMessageTarget
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Message1()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Debug.Log (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Message 1 received&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Message2()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Debug.Log (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Message 2 received&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，我们有了一个可以接收消息的脚本，我们需要发出消息。通常，这会是对某些松散耦合的事件的响应。例如，在UI系统中，我们会发出PointerEnter和PointerExit等事件，以及用户输入应用程序时可能发生的其他各种事件。&lt;/p&gt;
&lt;p&gt;要发送消息，存在一个静态助手类来完成这件事。它需要一个消息的目标对象、一些用户特定数据、以及一个映射到你想要定位的消息接口中具体功能的算子作为参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ExecuteEvents.Execute&amp;lt;ICustomMessageTarget&amp;gt;(target, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, (x,y)=&amp;gt;x.Message1());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此代码将在实现ICustomMessageTarget接口的GameObject目标上的任何组件上执行Message1函数。ExecuteEvents类的脚本文档覆盖了Execute函数的其他形式，比如在子元素或者父元素中执行。&lt;/p&gt;
&lt;h4 id=&#34;input-modules输入模块&#34;&gt;Input Modules(输入模块) &lt;a href=&#34;#input-modules%e8%be%93%e5%85%a5%e6%a8%a1%e5%9d%97&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;输入模块是可以配置和自定义事件系统主要逻辑的地方。打开即用的有两个输入模块，一个设计用于独立设备，一个设计用于触摸输入。每个模块都会按照你在所给配置上所预期的那样接收和派发事件。&lt;/p&gt;
&lt;p&gt;输入模块是事件系统的&amp;rsquo;业务逻辑&amp;rsquo;发生的地方。当启用事件系统时，它会查看附加了哪些输入模块，并把更新处理传递给特定模块。&lt;/p&gt;
&lt;p&gt;输入模块设计为基于你希望支持的输入系统来进行扩展或修改。它们的目的是将硬件特定输入（如触摸、摇杆、鼠标、运动控制器）映射成通过消息系统发送的事件。&lt;/p&gt;
&lt;p&gt;内置的输入模块被设计为支持常见的游戏配置，例如触摸输入、控制器输入、键盘输入和鼠标输入。如果你在你的MonoBehaviours上实现了特定的接口，它们会向应用程序中的控件发送各种各样的事件。所有的UI组件都实现了对于给定组件来说有意义的接口。&lt;/p&gt;
&lt;h4 id=&#34;supported-events支持事件&#34;&gt;Supported Events(支持事件) &lt;a href=&#34;#supported-events%e6%94%af%e6%8c%81%e4%ba%8b%e4%bb%b6&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;事件系统支持多个事件，用户还可以在自定义的输入模块中进一步定制这些事件。&lt;/p&gt;
&lt;p&gt;由独立输入模块和触摸输入模块支持的事件是通过接口提供的，可以通过实现接口在MonoBehaviour上实现。如果你配置了有效的事件系统，那么这些事件将在正确的时间被调用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPointerEnterHandler - OnPointerEnter - 当指针进入对象时被调用&lt;/li&gt;
&lt;li&gt;IPointerExitHandler - OnPointerExit - 当指针退出对象时被调用&lt;/li&gt;
&lt;li&gt;IPointerDownHandler - OnPointerDown - 当在对象上按下指针时被调用&lt;/li&gt;
&lt;li&gt;IPointerUpHandler - OnPointerUp - 当指针释放时被调用(在点击指针的游戏物体上调用)&lt;/li&gt;
&lt;li&gt;IPointerClickHandler - OnPointerClick - 当在同一对象上按下并释放指针时被调用&lt;/li&gt;
&lt;li&gt;IInitializePotentialDragHandler - OnInitializePotentialDrag - 当找到拖动目标时被调用，可以用来初始化值&lt;/li&gt;
&lt;li&gt;IBeginDragHandler - OnBeginDrag - 在拖动即将开始时在拖动对象上调用&lt;/li&gt;
&lt;li&gt;IDragHandler - OnDrag - 在拖动发生时在拖动对象上被调用&lt;/li&gt;
&lt;li&gt;IEndDragHandler - OnEndDrag - 拖动结束时在拖动对象上被调用&lt;/li&gt;
&lt;li&gt;IDropHandler - OnDrop - 在拖动结束的对象上被调用&lt;/li&gt;
&lt;li&gt;IScrollHandler - OnScroll - 当鼠标滚轮滚动时被调用&lt;/li&gt;
&lt;li&gt;IUpdateSelectedHandler - OnUpdateSelected - 在每个时钟周期内选定的对象上被调用&lt;/li&gt;
&lt;li&gt;ISelectHandler - OnSelect - 当对象成为选定的对象时被调用&lt;/li&gt;
&lt;li&gt;IDeselectHandler - OnDeselect - 当选中的对象变为非选中状态时被调用&lt;/li&gt;
&lt;li&gt;IMoveHandler - OnMove - 当移动事件发生时被调用（左，右，上，下）&lt;/li&gt;
&lt;li&gt;ISubmitHandler - OnSubmit - 当提交按钮被按下时被调用&lt;/li&gt;
&lt;li&gt;ICancelHandler - OnCancel - 当取消按钮被按下时被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;raycasters射线投射器&#34;&gt;Raycasters(射线投射器) &lt;a href=&#34;#raycasters%e5%b0%84%e7%ba%bf%e6%8a%95%e5%b0%84%e5%99%a8&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;事件系统需要一种方法来检测当前的输入事件需要发送到哪里，这就是射线投射器提供的功能。给定一个屏幕空间位置，它们将收集所有潜在的目标，判断它们是否在给定位置下方，然后返回离屏幕最近的对象。有几种类型的射线投射器提供：&lt;/p&gt;
&lt;p&gt;图形射线投射器 - 用于UI元素，存在于画布上并在画布中进行搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2D物理射线投射器 - 用于2D物理元素&lt;/li&gt;
&lt;li&gt;物理射线投射器 - 用于3D物理元素&lt;/li&gt;
&lt;li&gt;当场景中存在并启用了射线投射器时，事件系统在从输入模块发出查询时将使用它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用了多个射线投射器，则他们所有人都将被投射，结果将根据元素到距离进行排序&lt;/p&gt;
&lt;h3 id=&#34;reference参考&#34;&gt;Reference(参考) &lt;a href=&#34;#reference%e5%8f%82%e8%80%83&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;rect-transform&#34;&gt;Rect Transform &lt;a href=&#34;#rect-transform&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Rect Transform组件是Transform组件的2D布局对应物。其中Transform代表单个点，Rect Transform代表UI元素可以放置其中的矩形。如果Rect Transform的父级也是一个Rect Transform，子Rect Transform也可以指定它相对于父矩形的位置和大小应如何设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_RectTransform_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pos (X, Y, Z)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;矩形的旋转中心点相对于锚点的位置。旋转中心点是矩形旋转的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Width/Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;矩形的宽度和高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Left, Top, Right, Bottom&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;矩形边缘相对于其锚点的位置。这可以被认为是在由锚点定义的矩形内部的填充。当锚点分开时（如下所示），此项将代替“位置（Pos）”和“宽度/高度（Width/Height）”。要访问这些选项，请点击RectTransform组件左上角的方形锚点预设（Anchor Presets）框。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Anchors&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;矩形左下角和右上角的锚点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Min&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义为父矩形大小的一部分的矩形左下角的锚点。0,0 对应于锚定到父矩形的左下角，而 1,1 对应于锚定到父矩形的右上角。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Max&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义为父矩形大小的一部分的矩形右上角的锚点。0,0 对应于锚定到父矩形的左下角，而 1,1 对应于锚定到父矩形的右上角。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pivot&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;矩形旋转的围绕点位置，定义为矩形本身大小的一部分。0,0 对应于左下角，而 1,1 对应于右上角。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Rotation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对象围绕其枢轴点沿X、Y和Z轴旋转的角度（以度为单位）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scale&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在X、Y和Z维度上应用于对象的缩放因子。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Blueprint Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;就像它们没有被旋转和缩放一样编辑RectTransforms。这也启用了吸附功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Raw Edit Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当启用时，编辑轴心和锚点值将不会对矩形的位置和大小进行反向调整，以使其保持在一个地方。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请注意，某些RectTransform的计算是在帧的结束时进行的，就在计算UI顶点之前，以确保它们与整个帧期间进行的所有最新变化保持同步。这意味着它们在执行Start和第一次执行Update还未首次计算。&lt;/p&gt;
&lt;p&gt;您可以通过创建一个Start()其中添加Canvas.ForceUpdateCanvases()方法来解决这个问题。这将迫使Canvas不是在帧的结束时更新，而是在调用该方法时更新。&lt;/p&gt;
&lt;h4 id=&#34;canvas-components&#34;&gt;Canvas Components &lt;a href=&#34;#canvas-components&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;canvas-1&#34;&gt;Canvas &lt;a href=&#34;#canvas-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Canvas组件代表了UI布局和渲染的抽象空间。所有的UI元素都必须是具有附加了Canvas组件的游戏对象的子对象。当你从菜单中创建一个UI元素对象(GameObject &amp;gt; Create UI)时，如果场景中还没有Canvas对象，将自动创建一个Canvas对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasScreenSpaceCameraInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasWorldSpaceInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Render Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UI呈现到屏幕上或者作为3D空间中的对象的方式。 &lt;em&gt;Screen Space - Overlay&lt;/em&gt;、&lt;em&gt;Screen Space - Camera&lt;/em&gt; 和&lt;em&gt;World Space&lt;/em&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pixel Perfect (Screen Space modes only)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否应该为了精确而无抗锯齿地渲染UI？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Render Camera (Screen Space - Camera mode only)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UI应该渲染到哪个相机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Plane Distance (Screen Space - Camera mode only)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UI平面应该放置在相机前方的距离。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Event Camera (World Space mode only)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将用于处理UI事件的相机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Receives Events&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Canvas处理UI事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对所有UI元素来说，一个Canvas就足够了，但是场景中有多个Canvas也是可能的。也可以使用嵌套Canvas，也就是将一个Canvas作为另一个Canvas的子对象用于优化。嵌套的Canvas使用与其父对象相同的渲染模式。&lt;/p&gt;
&lt;p&gt;传统上，UI被渲染得就像是直接绘制在屏幕上的简单图形设计一样。也就是说，它们没有被摄像机观察的3D空间的概念。Unity支持这种屏幕空间渲染，但也允许UI作为场景中的对象进行渲染，这取决于渲染模式属性的值。可用的模式有Screen Space - Overlay、Screen Space - Camera 和World Space。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Screen Space - Overlay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种模式下，Canvas将会调整大小以适应屏幕，然后直接渲染，无需参考场景或摄像机(即使场景中完全没有摄像机，UI也会被渲染)。如果屏幕的大小或分辨率发生变化，UI将自动重新调整大小以适应。UI将会绘制在其他任何图形（如相机视图）之上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/CanvasOverlay.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意：Screen Space - Overlay模式下的Canvas需要被存储在层级结构的顶部。如果不这样做，UI可能会从视图中消失。这是一个内置的限制。请将Screen Space - Overlay的Canvas保持在层级结构的顶层，以得到预期的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Screen Space - Camera&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种模式下，Canvas被渲染得就像它是在距离给定摄像机一定距离的平面上绘制的。UI在屏幕上的大小并不会随着距离的变化而变化，因为它总是重新调整大小以完全适应摄像机的视锥体。如果屏幕的大小、分辨率或摄像机的视锥体发生了变化，那么UI将自动重新调整大小以适应。场景中距离摄像机比UI平面更近的3D对象将会渲染在UI的前面，而平面后面的对象会被遮挡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/CanvasCamera.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;World Space&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种模式将UI渲染得就像它是场景中的一个平面对象。然而，与Screen Space - Camera模式不同，这个平面并不需要面向摄像机，可以按照你喜欢的方式进行定向。Canvas的大小可以通过它的矩形变换进行设置，但它在屏幕上的大小将取决于摄像机的观察角度和距离。其它的场景对象可以经过Canvas的后面，穿过或者在Canvas的前面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/CanvasWorldSpace.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;canvas-scaler&#34;&gt;Canvas Scaler &lt;a href=&#34;#canvas-scaler&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Canvas Scaler组件用于控制Canvas中UI元素的整体比例和像素密度。这个缩放影响Canvas下的所有内容，包括字体大小和图片边框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasScalerInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;UI Scale Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定Canvas中的UI元素如何进行缩放。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Constant Pixel Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;让UI元素保持相同的像素大小，不论屏幕大小如何。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scale With Screen Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;屏幕越大，UI元素就会越大。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Constant Physical Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;让UI元素保持相同的物理大小，不论屏幕大小和分辨率如何。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Constant Pixel Size设置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scale Factor&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通过这个因子来缩放画布中的所有UI元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reference Pixels Per Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果一个精灵设置了这个“Pixels Per Unit”，那么精灵中的一个像素将会覆盖UI中的一个单位。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Scale With Screen Size设置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reference Resolution&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这是UI布局设计的分辨率。如果屏幕分辨率更大，UI将被放大，如果分辨率更小，UI将被缩小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Screen Match Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果当前分辨率的宽高比不符合参考分辨率，则使用此模式来缩放画布区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Match Width or Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据宽度、高度或其间的某种值来缩放画布区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Expand&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;横向或纵向扩展画布区域，因此画布的大小永远不会小于参考值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Shrink&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;横向或纵向裁剪画布区域，因此画布的大小永远不会大于参考值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Match&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定缩放是否以宽度或高度为参考，或者是两者之间的混合。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reference Pixels Per Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果一个精灵有这个“Pixels Per Unit”设置，那么精灵中的一个像素将覆盖UI中的一个单位。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Constant Physical Size设置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Physical Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用来指定位置和大小的物理单位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Fallback Screen DPI&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果屏幕DPI未知，应假定的DPI值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Default Sprite DPI&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于具有“Pixels Per Unit”设置的精灵，该设置与“Reference Pixels Per Unit”设置匹配的每英寸像素数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reference Pixels Per Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果一个精灵有这个“Pixels Per Unit”设置，那么它的DPI将匹配“Default Sprite DPI”设置。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;World Space Canvas设置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Dynamic Pixels Per Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于UI中动态创建的位图，如文本的单位像素数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Reference Pixels Per Unit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果一个精灵有这个&amp;rsquo;Pixels Per Unit&amp;rsquo;设置，那么在精灵中的一个像素将覆盖世界中的一个单位。如果&amp;rsquo;Pixels Per Unit&amp;rsquo;设置为1，那么在精灵中的&amp;rsquo;单位像素&amp;rsquo;设置将完全按照原样使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于设置为“Screen Space - Overlay”或“Screen Space - Camera”的Canvas，Canvas Scaler UI缩放模式可以设置为Constant Pixel Size，Scale With Screen Size或Constant Physical Size。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constant Pixel Size&lt;/strong&gt;
使用Constant Pixel Size模式，UI元素的位置和大小以屏幕上的像素为单位。当Canvas Scaler未附加时，这也是Canvas的默认功能。然而，可以通过Canvas Scaler的缩放因子设置为Canvas中的所有UI元素提供一种恒定的缩放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scale With Screen Size&lt;/strong&gt;
使用Scale With Screen Size模式，可以根据指定的参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，Canvas将保留参考分辨率的分辨率，但将放大以适应屏幕。如果当前屏幕分辨率小于参考分辨率，Canvas将同样缩小以适应。&lt;/p&gt;
&lt;p&gt;如果当前屏幕分辨率的宽高比与参考分辨率不同，将分别缩放每个轴以适应屏幕将导致非均匀的缩放，这通常是不期望的。因此，ReferenceResolution组件会让Canvas分辨率偏离参考分辨率，以保持屏幕的宽高比。Screen Match Mode设置可以控制这种偏差的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constant Physical Size&lt;/strong&gt;
使用Constant Physical Size模式，UI元素的位置和大小以物理单位（如毫米、点或点刻）指定。这种模式依赖于设备正确报告其屏幕DPI。您可以为不报告DPI的设备指定一种备选的DPI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;World Space&lt;/strong&gt;
对于设置为&amp;rsquo;World Space&amp;rsquo;的Canvas，Canvas Scaler可以用来控制Canvas中UI元素的像素密度。&lt;/p&gt;
&lt;h5 id=&#34;canvas-group&#34;&gt;Canvas Group &lt;a href=&#34;#canvas-group&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Canvas Group可以用来从一个地方控制一整组UI元素的某些方面，无需单独处理每一个元素。Canvas Group的属性会影响它所在的GameObject以及所有的子元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasGroupInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Alpha&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;此组中UI元素的透明度。值在0和1之间，其中0表示完全透明，1表示完全不透明。注意，元素本身也保持其透明度，因此Canvas Group的alpha值和单个UI元素的alpha值会相互乘以。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定此组件是否接受输入。当设置为false时，交互功能将被禁用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Block Raycasts&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;此组件是否将充当Raycasts的碰撞器？你需要在附加到Canvas的图形射线投射器上调用RayCast函数。这不适用于Physics.Raycast。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Ignore Parent Groups&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组是否会受到游戏对象层次结构中更上层Canvas Group组件设置的影响，或者它会忽略这些设置，从而覆盖它们？&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Canvas Group的典型用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过在窗口的GameObject上添加Canvas Group，控制其Alpha属性，实现整个窗口的淡入或淡出。&lt;/li&gt;
&lt;li&gt;通过在父GameObject上添加Canvas Group，并将其Interactable属性设置为false，使一整套控件无法交互（变灰）。&lt;/li&gt;
&lt;li&gt;通过在元素或其父元素上放置Canvas Group组件，并将其Block Raycasts属性设置为false，使一个或多个UI元素不阻止鼠标事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;canvas-renderer&#34;&gt;Canvas Renderer &lt;a href=&#34;#canvas-renderer&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Canvas Renderer组件渲染包含在Canvas内的图形UI对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_CanvasRendererInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;菜单中可用的标准UI对象（GameObject &amp;gt; Create UI）在需要的地方都已附加Canvas Renderer，但您可能需要为自定义UI对象手动添加此组件。虽然检查器中没有公开的属性，但可以从脚本中访问一些属性和函数。&lt;/p&gt;
&lt;h4 id=&#34;visual-components-1&#34;&gt;Visual Components &lt;a href=&#34;#visual-components-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;text-1&#34;&gt;Text &lt;a href=&#34;#text-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Text控件向用户显示非交互式的文本。这可以用于为其他GUI控件提供标题或标签，或者展示指令或其他文本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_TextInspector2_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Text&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;控件显示的文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Character&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Font&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于显示文本的字体。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Font Style&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用于文本的样式。选项有&lt;em&gt;Normal&lt;/em&gt;（正常）、&lt;em&gt;Bold&lt;/em&gt;（粗体）、&lt;em&gt;Italic&lt;/em&gt;（斜体）和&lt;em&gt;Bold And Italic&lt;/em&gt;（粗斜体）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Font Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示文本的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Line Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文本行之间的垂直间隔。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Rich Text&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文本中的标记元素是否应被解释为富文本样式？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Paragraph&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Alignment&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文本的水平和垂直对齐。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Align by Geometry&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用字形几何的范围来执行水平对齐，而不是字形度量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal Overflow&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;处理文本过宽无法适应矩形的情况的方法。选项有 &lt;em&gt;Wrap&lt;/em&gt; 和 &lt;em&gt;Overflow&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical Overflow&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;处理折行文本过高无法适应矩形的情况的方法。选项有 &lt;em&gt;Truncate&lt;/em&gt; 和 &lt;em&gt;Overflow&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Best Fit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity是否应忽略大小属性，而只是试图使文本适应控件的矩形？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于渲染文本的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Material&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于渲染文本的材质。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些控件（如Buttons和Toggles）具有内置的文本描述。对于没有隐式文本的控件（如Sliders），你可以使用文本控件创建的标签来指示其用途。文本也适用于指令列表、故事文本、对话和法律免责声明。&lt;/p&gt;
&lt;p&gt;文本控件提供了常见的字体大小、样式等参数，以及文本对齐方式。当启用富文本选项时，文本内的标记元素将被视为样式信息，因此你可以让单个词汇或短小的部分以粗体或不同的颜色显示。&lt;/p&gt;
&lt;h5 id=&#34;image-1&#34;&gt;Image &lt;a href=&#34;#image-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Image控件向用户展示一个非交互式的图片。你可以用它来作为装饰或图标，而且你可以通过脚本改变图片以反映其他控件的变化。该控件类似于原始图像控件，但是提供了更多的选项来动态渲染图像和精确填充控件矩形。然而，图像控件需要其贴图为精灵，而原始图像可以接受任何贴图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/ImageCtrlExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ImageInspector_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Source Image&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示要显示的图像的贴图（必须导入为精灵）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用于图像的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Material&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于渲染图像的材质。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Raycast Target&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果您希望Unity将图像视为射线投射的目标，请启用“Raycast Target”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Preserve Aspect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确保图像保持其现有尺寸。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Set Native Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将图像框的尺寸设置为纹理的原始像素大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;您必须将要显示的图像导入为Sprite，才能与Image控件一起使用。&lt;/p&gt;
&lt;h5 id=&#34;raw-image-1&#34;&gt;Raw Image &lt;a href=&#34;#raw-image-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Raw Image控件向用户显示一个非互动的图像。您可以用它做装饰或图标等用途，而且可以通过脚本改变图像以反映其他控件的变化。该控件与Image控件相似，但为图像的动画提供了更多的选项，并能准确地填充控件矩形。然而，Image控件要求其Texture为Sprite，而Raw Image可以接受任何Texture。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/RawImageCtrlExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_RawImageInspector184.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Texture&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示要显示的图像的纹理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用于图像的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Material&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于渲染图像的材质。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Raycast Target&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果您希望Unity将图像视为射线投射的目标，请启用“Raycast Target”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;UV Rectangle&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;图像在控件矩形内的偏移和大小，以标准化坐标（范围0.0到1.0）给出。图像的边缘被拉伸以填充UV矩形周围的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于Raw Image不需要精灵纹理，您可以使用它来显示Unity播放器可以获取到的任何纹理。例如，您可能会显示使用WWW类从URL下载的图像，或者显示游戏中对象的纹理。&lt;/p&gt;
&lt;p&gt;UV矩形属性允许您显示较大图像的一小部分。X和Y坐标指定图像的哪个部分与控件的左下角对齐。例如，X坐标0.25 会截掉图像最左边的四分之一。W和H（也就是，宽度和高度）属性指示将要缩放以适应控件矩形的图像部分的宽度和高度。例如，宽度和高度为0.5将会将图像区域的四分之一放大到控件矩形。通过更改这些属性，您可以根据需要进行图像的缩放和调整大小（参见Scrollbar控件）。&lt;/p&gt;
&lt;h5 id=&#34;mask-1&#34;&gt;Mask &lt;a href=&#34;#mask-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Mask并不是一个可见的UI控件，而是一种修改控件子元素外观的方法。遮罩（即:“mask”）将子元素限制在父元素的形状内。因此，如果子元素大于父元素，那么只有符合父元素的子元素部分才会可见。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MaskCtrlExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MaskInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Show Graphic&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;遮罩（父对象）的图形是否应该以透明度的形式覆盖在子对象之上？&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Description (描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遮罩的一个常见用途是使用例如面板对象（menu: GameObject &amp;gt; Create UI &amp;gt; Panel）作为“框架”，来显示大图像的小部分。您可以首先将图像指定为面板对象的子对象来实现这一点。您应该将图像定位到面板区域后面应该可见的区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MaskDisabled.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后，向面板添加Mask组件。由于被面板的形状遮挡，子图像在面板外的区域将变得不可见。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/MaskEnabled.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果随后移动图像，则只有面板揭示的部分将会可见。这种移动可以通过滚动条来控制，例如创建一个可滚动的地图查看器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation(实现原理)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遮罩是使用GPU的模板缓冲器来实现的。&lt;/p&gt;
&lt;p&gt;*第一个遮罩元素将1写入模板缓冲器 *所有遮罩下面的元素在渲染时进行检查，仅在模板缓冲器中有1的区域呈现 *嵌套的遮罩会将递增的位掩码写入缓冲器，这意味着可渲染的子项需要具有模板值的逻辑与才能被渲染。&lt;/p&gt;
&lt;h5 id=&#34;rectmask2d&#34;&gt;RectMask2D &lt;a href=&#34;#rectmask2d&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;RectMask2D是一个与Mask控件类似的遮罩控制器。该遮罩将子元素限制在父元素的矩形内。与标准的遮罩控件不同，它有一些限制，但是它也有许多性能优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;
RectMask2D的一个常见用途是显示较大区域的小部分。使用RectMask2D来框定这个区域。&lt;/p&gt;
&lt;p&gt;RectMask2D控件的限制包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它只在2D空间内工作&lt;/li&gt;
&lt;li&gt;它不能正确地遮盖不在同一平面上的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RectMask2D的优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它不使用模板缓冲器&lt;/li&gt;
&lt;li&gt;没有额外的绘制调用&lt;/li&gt;
&lt;li&gt;无需改变材质&lt;/li&gt;
&lt;li&gt;性能快速&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ui-effect-components&#34;&gt;UI Effect Components &lt;a href=&#34;#ui-effect-components&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;shadow&#34;&gt;Shadow &lt;a href=&#34;#shadow&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;阴影组件对图形组件（如文字或图片）添加了简单的轮廓效果。它必须与图形组件位于同一GameObject上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_TextExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ShadowExample.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ShadowInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Effect Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;阴影的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Effect Distance&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;阴影的偏移量，表示为一个向量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Use Graphic Alpha&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将图形的颜色乘以效果的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;outline&#34;&gt;Outline &lt;a href=&#34;#outline&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;轮廓组件为诸如Text或Image的图形组件添加了一个简单的轮廓效果。它必须和图形组件在同一个游戏对象上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_TextExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_OutlineExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_OutlineInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Effect Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;轮廓的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Effect Distance&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;轮廓效果在水平和垂直方向上的距离。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Use Graphic Alpha&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将图形的颜色与效果的颜色进行乘法运算。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;position-as-uv1&#34;&gt;Position as UV1 &lt;a href=&#34;#position-as-uv1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;这为文本和图像图形添加了一个简单的位置作为UV1的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_PositionAsUV1Inspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;interaction-components-1&#34;&gt;Interaction Components &lt;a href=&#34;#interaction-components-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;selectable-base-class&#34;&gt;Selectable Base Class &lt;a href=&#34;#selectable-base-class&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Selectable类是所有交互组件的基类，它处理的是那些公共的项。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这决定了这个组件是否会接受输入。当它被设定为false时，交互会被禁用，并且转换状态会被设定为禁用状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在一个可选组件内，有几个过渡选项，具体取决于可选组件当前处于什么状态。不同的状态有：正常，高亮，按压和禁用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;还有一些导航选项，用来控制如何实现控件的键盘导航。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;transition-options&#34;&gt;Transition Options &lt;a href=&#34;#transition-options&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;在一个可选择的组件中，根据可选择组件当前所处的状态，有几个不同的过渡选项。不同的状态有：正常，高亮，按压和禁用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableTransition.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;过度选项:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;None&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个选项是让按钮完全没有状态效果。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Color Tint&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据按钮所处的状态更改按钮的颜色。可以为每个独立的状态选择颜色。也可以设置不同状态之间的淡入淡出时间。数字越高，颜色间的淡入淡出变化就越慢。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Sprite Swap&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许根据按钮当前所处的状态显示不同的精灵图像，这些精灵图像可以自定义。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Animation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许根据按钮的状态进行动画展示，为了使用动画过渡，必须存在一个动画器组件。确保禁用根运动是很重要的。要创建一个动画控制器，点击生成动画（或者创建你自己的），并确保一个动画控制器已经被添加到按钮的动画器组件中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Color Tint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableColorTint.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Target Graphic&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;交互组件所使用的图形。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Normal Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;控件的正常颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Highlighted Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被高亮时的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pressed Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被按下时的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Disabled Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被禁用时的颜色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Color Multiplier&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这会将每次过渡的色彩和它的值相乘。通过这种方式，你可以创建大于1的颜色，以增亮那些基础颜色小于白色（或者透明度小于满透明度）的图形元素上的颜色（或者透明度）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Fade Duration&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以秒为单位，从一个状态过渡到另一个状态所需的时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Sprite Swap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableSpriteSwap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Target Graphic&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;要使用的普通精灵。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Highlighted Sprite&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被高亮时使用的精灵。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pressed Sprite&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被按下时使用的精灵。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Disabled Sprite&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被禁用时使用的精灵。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Animation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableAnimation.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Normal Trigger&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用的正常动画触发器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Highlighted Trigger&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被高亮时使用的触发器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Pressed Trigger&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被按下时使用的触发器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Disabled Trigger&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当控件被禁用时使用的触发器。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h6 id=&#34;navigation-options&#34;&gt;Navigation Options &lt;a href=&#34;#navigation-options&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableNavigation.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;导航选项指的是如何控制游戏模式下UI元素的导航。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;None&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;没有键盘导航。同时确保它不会因点击/轻触而接收焦点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实现水平导航。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实现垂直导航。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Automatic&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动导航。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Explicit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在此模式下，你可以明确指定控件在按下不同方向键时的导航路径。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Visualize&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择&amp;quot;可视化&amp;quot;会在场景窗口中给你展示你已经设置的导航的可视化表示。请看下图。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SelectableNavigationExplicit.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/GUIVisualizeNavigation.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上述的可视化模式中，箭头指示了一组控件的焦点变化方式。也就是说，对于每一个独立的UI控件，你可以看到当某个控件被选中时，用户按下一个方向键后，哪个UI控件将会接下来获得焦点。所以在上面的例子中，如果&amp;quot;按钮&amp;quot;获得了焦点，用户按下了右箭头键，那么第一个（左边的）竖直滑动器将会接下来获得焦点。需要注意的是，因为竖直滑动器控制着滑动器的值，所以竖直滑动器不能通过上或下的键跳转焦点。同样，水平滑动器也不能通过左/右箭头键跳转焦点。&lt;/p&gt;
&lt;h5 id=&#34;button-1&#34;&gt;Button &lt;a href=&#34;#button-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;按钮控件响应用户的点击，用于开始或确认一个动作。熟悉的例子包括网页表单上使用的提交和取消按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ButtonExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ButtonInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果你希望这个按钮能接受输入，就启用&amp;quot;可交互&amp;rdquo;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件如何在视觉上响应用户操作的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定控件序列的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Click&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unity在用户点击按钮并释放时调用的UnityEvent。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按钮被设计为在用户点击并释放时触发一个动作。如果在释放点击之前鼠标被移出按钮控件，动作就不会发生。&lt;/p&gt;
&lt;p&gt;按钮有一个叫做点击事件(On Click)的事件，当用户完成点击时会响应。典型的用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认一个决定（例如，开始游戏或者保存游戏）&lt;/li&gt;
&lt;li&gt;在GUI中移动到子菜单&lt;/li&gt;
&lt;li&gt;取消正在进行的动作（例如，下载一个新的场景）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;toggle-1&#34;&gt;Toggle &lt;a href=&#34;#toggle-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Toggle控件是一个复选框，允许用户开启或关闭一个选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组件会接受输入吗？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件如何视觉上响应用户操作的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件序列的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Is On&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;切换按钮是否从一开始就处于开启状态？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Toggle Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;切换按钮在其值改变时的图形反应方式。选项包括无（即，勾选标记简单地出现或消失）和淡出（即，勾选标记会淡入或淡出）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Graphic&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于勾选标记的图像。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Group&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个切换按钮所属的切换按钮组（如果有的话）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Property:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Function:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Changed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当切换按钮被点击时调用的Unity事件。该事件可以将当前状态作为bool类型的动态参数发送。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;切换控制允许用户开启或关闭选项。你也可以将多个切换按钮组合到一个切换按钮组中，当一组选项中只应有一个被开启时。&lt;/p&gt;
&lt;p&gt;切换按钮有一个单一事件叫做&amp;quot;值变更时&amp;quot;，当用户改变当前值时该事件会作出响应。新的值会作为一个布尔参数传递给事件函数。切换开关的典型用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启或关闭选项（例如，游戏时播放音乐）。&lt;/li&gt;
&lt;li&gt;让用户确认他们已阅读法律免责声明。&lt;/li&gt;
&lt;li&gt;在切换按钮组中选择一组选项中的一个（例如，一周中的某一天）。&lt;/li&gt;
&lt;li&gt;注意，切换按钮是一个为子元素提供可点击区域的父元素。如果切换按钮没有子元素（或者它们被禁用），则它不可点击。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;toggle-group-1&#34;&gt;Toggle Group &lt;a href=&#34;#toggle-group-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Toggle Group并不是一个可见的UI控件，而是一种修改一组切换按钮行为的方式。属于同一组的切换按钮被约束在同一时间只能有一个被开启 - 按下其中一个以开启它会自动关闭其他的切换按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleGroupExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ToggleGroupInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Allow Switch Off&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否允许没有任何切换按钮被开启？如果启用此设置，按下当前开启的切换按钮将关闭它，使得没有切换按钮被开启。如果禁用此设置，按下当前开启的切换按钮将不会改变其状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过将Toggle Group对象拖拽到组内每个切换按钮的Group属性中来建立切换按钮组。&lt;/p&gt;
&lt;p&gt;Toggle Group在用户必须从互斥的选项集中做出选择的任何地方都很有用。常见的例子包括选择玩家角色类型，速度设置（慢，中，快等），预设颜色和一周中的某一天。你可以在场景中一次拥有多个切换按钮组对象，所以如果必要，你可以创建多个独立的组。&lt;/p&gt;
&lt;p&gt;与其他UI元素不同，带有Toggle Group组件的对象不需要是一个画布对象的子对象，尽管切换按钮自身仍然需要这样。&lt;/p&gt;
&lt;p&gt;请注意，如果场景加载或实例化组时组内多个切换按钮被开启，Toggle Group不会立刻执行约束。只有当一个新的切换按钮被开启时，其他的才会被关闭。这意味着你需要确保只有一个切换按钮从一开始就被开启。&lt;/p&gt;
&lt;h5 id=&#34;slider-1&#34;&gt;Slider &lt;a href=&#34;#slider-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Slider控件允许用户通过拖动鼠标从预设范围内选择一个数值。请注意，类似的ScrollBar控件被用于滚动，而不是选择数值。熟悉的例子包括游戏中的难度设置和图片编辑器中的亮度设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SliderExample_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_SliderInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组件会接受输入吗？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件对用户操作在视觉上响应方式的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件序列的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Fill Rect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;控件填充区域使用的图形。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Handle Rect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滑块控件的&amp;quot;handle&amp;quot;部分所使用的图形。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Direction&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当把手被拖动时，滑块值增加的方向。选项有从左到右，从右到左，从下到上和从上到下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Min Value&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当滑块把手位于最低端（由方向属性决定）时，Slider的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Max Value&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当滑块把手位于最高端（由方向属性决定）时，Slider的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Whole Numbers&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Slider的值是否应限制为整数值？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Slider的当前数值。如果在检查器中设定了值，它将被用作初始值，但是当数值变动时，该值将在运行时改变。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Changed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当Slider的当前值发生变化时，将会触发一个UnityEvent。这个事件可以将当前值作为浮点型的动态参数发送。无论是否启用了“Whole Numbers”（整数值）属性，该值都会以浮点型传递。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Slider的值是由其手柄沿其长度的位置决定的。随着手柄被拖动的距离增加，值会从最小值增加到最大值。默认的行为是让Slider从左到右增加，但也可以使用“Direction”（方向）属性来反转这种行为。你还可以通过为“Direction”属性选择“Bottom To Top”（从底部到顶部）或“Top To Bottom”（从顶部到底部）以设置滑块垂直增加。&lt;/p&gt;
&lt;p&gt;Slider有一个名为“On Value Changed”（数值改变时）的单一事件，当用户拖动手柄时会触发。滑块的当前数值会作为浮点型参数传递给这个函数。典型的使用案例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择游戏的难度级别，灯光的亮度等。&lt;/li&gt;
&lt;li&gt;设置距离、大小、时间或角度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;scrollbar-1&#34;&gt;Scrollbar &lt;a href=&#34;#scrollbar-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Scrollbar控件允许用户滚动过大以至于无法完全看见的图像或其他视图。请注意，类似的Slider控件被用于选择数值，而不是滚动。熟悉的例子包括文本编辑器侧边的垂直滚动条，以及用于查看大图像或地图的一部分的垂直和水平对的滚动条。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollbarExample_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollBarInspector_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组件会接受输入吗？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件对用户操作在视觉上反馈方式的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定控件序列的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Fill Rect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于控件的背景区域的图形。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Handle Rect&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于控件滑动&amp;quot;handle&amp;quot;部分的图形。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Direction&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当操作句柄被拖动时，滚动条值将以哪种方向增加。选项有从左到右，从右到左，从下到上和从上到下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滚动条的初始位置值，范围在0.0到1.0之间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滚动条中手柄的部分大小，范围在0.0到1.0之间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Number Of Steps&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滚动条允许的不同滚动位置的数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Property:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Function:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Changed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当滚动条的当前值发生变化时调用的UnityEvent。该事件可以将值发送为float类型的动态参数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚动条的值由手柄沿其长度的位置确定，该值被报告为极端末端之间的一部分。例如，默认的从左到右的条有一个0.0在左端，1.0在右端，0.5表示中点。可以通过为方向属性选择从上到下或从下到上来使滚动条垂直定向。&lt;/p&gt;
&lt;p&gt;滚动条与类似的滑块控件之间的一个重要区别是滚动条的手柄可以改变尺寸以表示可滚动的距离；当视图只能滚动很短的距离时，手柄会占满大部分条形，只允许稍微向任一方向移动。&lt;/p&gt;
&lt;p&gt;滚动条有一个称为“值改变时”的单一事件，该事件在用户拖动手柄时响应。当前值作为浮点参数传递给事件函数。滚动条的典型用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垂直滚动一段文本。&lt;/li&gt;
&lt;li&gt;水平滚动时间线。&lt;/li&gt;
&lt;li&gt;成对使用时，可以水平和垂直滚动大图像，以查看放大的部分。手柄的大小改变以指示缩放的程度，从而指示可滚动的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;dropdown-1&#34;&gt;Dropdown &lt;a href=&#34;#dropdown-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;下拉菜单可以用来让用户从选项列表中选择一个单一的选项。&lt;/p&gt;
&lt;p&gt;该控件显示当前选择的选项。一旦点击，它会打开选项列表，以便可以选择新的选项。选择新选项后，选项列表再次关闭，控件显示新选择的选项。如果用户点击控件本身，或者画布内的任何其他地方，列表也会关闭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownExample_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownExampleOpen.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Interactable&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组件会接受输入吗？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定控件对用户操作的视觉反应方式的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定控件序列的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Template&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;下拉列表的模板的Rect Transform。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Caption Text&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于保存当前选定选项文本的Text组件。（可选）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Caption Image&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于保存当前选定选项图片的Image组件。（可选）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Item Text&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于保存项目文本的Text组件。（可选）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Item Image&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于保存项目图片的Image组件。（可选）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当前选择选项的索引。0代表第一个选项，1代表第二个，以此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Options&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可能的选项列表。每个选项都可以指定一个文本字符串和一个图片。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Property:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Function:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Changed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当用户点击下拉列表中的一个选项时，会触发的UnityEvent事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选项列表可以在Inspector中指定，或者可以通过代码进行赋值。每个选项都可以指定一个文本字符串，如果Dropdown支持的话，还可以选择性地指定一个图片。&lt;/p&gt;
&lt;p&gt;按钮有一个名为“On Value Changed”的事件，当用户完成对列表中某个选项的点击时触发。它支持发送一个整数值，这个值是所选选项的索引。0代表第一个选项，1代表第二个，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The template system&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dropdown控件被设计为拥有一个子GameObject，该GameObject作为点击Dropdown控件时显示的下拉列表的模板。模板GameObject默认是不活跃的，但在编辑模板时可以让它活跃，以便更好地看到正在发生的事情。必须在Dropdown组件的Template属性中指定对模板对象的引用。&lt;/p&gt;
&lt;p&gt;模板必须有一个带有Toggle组件的项。当实际的下拉列表在点击Dropdown控件时被创建，这个项会被复制多次，列表中的每个选项都使用一个副本。项的父对象会自动调整大小，以便能够装下所有的项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownHierarchySimple.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_DropdownHierarchyScrolling.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;模板可以通过许多不同的方式进行设置。由GameObject &amp;gt; UI &amp;gt; Dropdown菜单项使用的设置包括一个滚动视图，这样如果一次显示的选项太多，滚动条会出现，用户可以通过滚动条浏览选项。然而，这并不是模板设置的必要部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Setup of text and image support&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下拉菜单支持每个选项有一个文本内容和一个图片内容。文本和图片都是可选的。只有当Dropdown设置支持时，才能使用它们。&lt;/p&gt;
&lt;p&gt;当Caption Text和Item Text属性都设置时，下拉菜单支持每个选项的文本。当使用GameObject &amp;gt; UI &amp;gt; Dropdown菜单项时，默认会设置这些属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caption Text是用来放置当前选定选项文本的Text组件。它通常是Dropdown GameObject的子对象。&lt;/li&gt;
&lt;li&gt;Item Text是用来放置每个选项文本的Text组件。它通常是Item GameObject的子对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当Caption Image和Item Image属性都设置时，下拉菜单支持每个选项的图片。这些属性默认情况下不设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caption Image是用来放置当前选定选项图片的Image组件。它通常是Dropdown GameObject的子对象。&lt;/li&gt;
&lt;li&gt;Item Image是用来放置每个选项图片的Image组件。它通常是Item GameObject的子对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际用于下拉菜单的文本和图片在Dropdown组件的Options属性中指定，或者可以从代码中设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Placement of the dropdown list&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下拉列表相对于下拉控件的位置由模板的Rect Transform的锚点和枢轴决定。&lt;/p&gt;
&lt;p&gt;默认情况下，列表会显示在控件下方。通过将模板锚定在控件的底部来实现这一点。模板的枢轴也需要在顶部，这样当模板扩展以适应可变数量的选项项时，它只会向下扩展。&lt;/p&gt;
&lt;p&gt;Dropdown控件有简单的逻辑来防止下拉菜单显示在Canvas的边界外，因为这会使得选择某些选项变得不可能。如果默认位置的下拉菜单在Canvas的矩形内部完全看不见，它相对于控件的位置会翻转。例如，默认情况下显示在控件下方的列表会显示在它的上方。&lt;/p&gt;
&lt;p&gt;这种逻辑非常简单，有一定的限制。下拉菜单的模板不得大于Canvas大小的一半减去下拉控件的大小，否则如果下拉控件位于Canvas的中间，两个位置可能都没有足够的空间放置列表。&lt;/p&gt;
&lt;h5 id=&#34;input-field-1&#34;&gt;Input Field &lt;a href=&#34;#input-field-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;输入字段是一种使Text控件的文本可编辑的方法。像其他交互控件一样，它本身并非可见的UI元素，必须与一个或多个可视UI元素结合使用才能看见。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_InputFieldExample_4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_InputFieldExample2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_InputFieldInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Transition&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定控件对用户操作的视觉反应方式的属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;TextComponent&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;作为Input Field内容的Text元素的引用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Text&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;编辑开始前放置在字段中的初始文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Character Limit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;输入字段中可以输入的最大字符数的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Content Type&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义您的输入字段接受的字符类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Line Type&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义在文本字段内文本的格式化方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Placeholder&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这是一个可选的“空”图形，用于显示输入字段中没有文本。请注意，即使输入字段被选中（也就是，当其被聚焦），这个“空”图形仍然会显示。例如：“Enter text&amp;hellip;”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Caret Blink Rate&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义用于指示建议插入文本的标记在行上的闪烁频率。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Selection Color&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选中文本部分的背景色。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Hide Mobile Input (iOS only)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在移动设备上隐藏与屏幕键盘关联的原生输入字段。请注意，这只在iOS设备上有效。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Change&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当输入字段的文本内容发生变化时，会调用一个UnityEvent。该事件可以将当前的文本内容作为字符串类型的动态参数发送。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;End Edit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当用户通过提交或点击某处从输入字段移除焦点以完成文本内容编辑时，会调用一个UnityEvent。该事件可以将当前的文本内容作为字符串类型的动态参数发送。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过菜单（Component &amp;gt; UI &amp;gt; Input Field），可以将输入字段脚本添加到任何已有的文本控件对象中。完成这项操作后，你还应将对象拖放到输入字段的文本属性上，以启用编辑功能。&lt;/p&gt;
&lt;p&gt;用户在输入过程中，文本控件自身的文本属性将会发生改变，编辑后可以从脚本中获取该值。请注意，富文本特意不支持可编辑的文本控件；字段在输入时会立即应用任何富文本标记，但标记基本上会“消失”，并且无法再改变或移除样式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hints(提示)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若要获取输入字段的文本，请使用InputField组件本身的text属性，而不是显示文本的Text组件的text属性。Text组件的text属性可能会被裁剪，或者对于密码，可能由星号组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;scroll-rect&#34;&gt;Scroll Rect &lt;a href=&#34;#scroll-rect&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;当需要在一个小区域里显示占据大量空间的内容时，可以使用滚动矩形。滚动矩形提供了滚动此类内容的功能。&lt;/p&gt;
&lt;p&gt;通常滚动矩形会与遮罩组合使用，以创建一个只有滚动矩形内可滚动内容可见的滚动视图。它还可以额外地与一个或两个滚动条结合使用，这些滚动条可以拖动以水平或垂直滚动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollRectExample_5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollRectInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Content&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这是对需要滚动的UI元素的矩形变换的引用，例如一个大图像。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启用水平滚动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启用垂直滚动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Movement Type&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无限制，弹性或者夹紧。使用弹性或夹紧可以强制内容保持在滚动矩形的边界内。当内容到达滚动矩形的边缘时，弹性模式会使内容反弹。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Elasticity&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这是弹性模式中使用的反弹量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Inertia&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当设置了惯性时，拖动后释放指针，内容会继续移动。当未设置惯性时，内容只有在拖动时才会移动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Deceleration Rate&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当设置了惯性，减速率决定了内容停止移动的速度。减速率为0将立即停止移动。减速率为1表示移动将永不减速。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Scroll Sensitivity&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对滚轮和触控板滚动事件的敏感度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Viewport&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指向作为内容矩形变换父级的视口矩形变换的引用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal Scrollbar&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可选的引用到一个水平滚动条元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Visibility&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当不需要滚动条时，是否应自动隐藏滚动条，并可选地扩展视口。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滚动条和视口之间的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical Scrollbar&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可选的引用到一个垂直滚动条元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Visibility&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当不需要滚动条时，是否应自动隐藏滚动条，并可选地扩大视口。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;滚动条和视口之间的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Event事件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Property:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Function:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;On Value Changed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当Scroll Rect的滚动位置发生变化时，会调用的UnityEvent。该事件可以将当前滚动位置作为Vector2类型的动态参数发送。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚动视图中的重要元素包括视口，滚动内容，以及可选的一个或两个滚动条。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根GameObject有Scroll Rect组件。&lt;/li&gt;
&lt;li&gt;视口具有Mask组件。视口可以是根GameObject，也可以是根的子GameObject。如果使用自动隐藏的滚动条，它必须是一个子元素。视口的Rect Transform需要在Scroll Rect的Viewport属性中引用。&lt;/li&gt;
&lt;li&gt;所有滚动内容必须是视口的子对象的单一内容GameObject的子对象。内容的Rect Transform需要在Scroll Rect的Content属性中引用。&lt;/li&gt;
&lt;li&gt;滚动条（如果使用）是根GameObject的子对象。请参阅滚动条页面以获取有关滚动条设置的更多详细信息，并参阅下面的滚动条设置部分以获取有关带有滚动视图的滚动条设置的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个图片显示了一个设置，其中视口是滚动视图根的子对象。这是使用GameObject &amp;gt; UI &amp;gt; Scroll View菜单选项时的默认设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScrollRectHierarchy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要滚动内容，输入必须从ScrollRect的边界内部接收，而不是在内容本身上。&lt;/p&gt;
&lt;p&gt;在使用Unrestricted滚动移动时要小心，因为可能会以无法检索的方式失去对内容的控制。当使用Elastic或Constrained移动时，最好将内容定位到开始在ScrollRect的边界内，否则当RectTransform试图将内容带回其边界时，可能会出现不良行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scrollbar setup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可选地，Scroll Rect可以链接到水平和/或垂直滚动条。这些通常被放置在视口的兄弟层级中，存在时，应分别拖入到Scroll Rect的Horizontal Scrollbar和Vertical Scrollbar属性中。请注意，这样的水平滚动条上的Direction属性应设置为Left To Right，垂直滚动条设置为Bottom To Top。&lt;/p&gt;
&lt;p&gt;滚动条可以选择具有自动隐藏行为，如果内容不需要滚动，因为它没有大于视口，那么它会隐藏滚动条。请注意，自动隐藏只在Play Mode中发生。在Edit Mode中，滚动条始终显示。这可以防止在不应标记场景为dirty的情况下标记它，并且也有助于创建内容，即使显示滚动条，也有足够的空间。&lt;/p&gt;
&lt;p&gt;如果一个或两个滚动条的可见性行为设置为Auto Hide And Expand View，那么当滚动条隐藏时，视口会自动扩大以占据滚动条原本所在的多余空间。在这种设置中，视图的位置和大小由Scroll Rect驱动，水平滚动条的宽度以及垂直滚动条的高度也被驱动。在此设置中，视口以及滚动条必须是Scroll Rect根GameObject的子对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hints(提示)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内容的RectTransform的轴心和锚点可以用来决定如果内容增长或收缩时，内容如何在滚动视图内对齐。如果内容应该保持与顶部对齐，将锚点设置在父对象的顶部，并将轴心设置到顶部位置。&lt;/p&gt;
&lt;h4 id=&#34;auto-layout-1&#34;&gt;Auto Layout &lt;a href=&#34;#auto-layout-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;自动布局系统提供了将元素放置在嵌套布局组（如水平组、垂直组或网格）中的方式。它还允许元素根据包含的内容自动调整大小。&lt;/p&gt;
&lt;h5 id=&#34;layout-element&#34;&gt;Layout Element &lt;a href=&#34;#layout-element&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;如果你想覆盖布局元素的最小、首选或弹性大小，你可以通过在GameObject中添加一个Layout Element组件来实现。&lt;/p&gt;
&lt;p&gt;布局控制器按以下顺序分配宽度或高度给布局元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，布局控制器分配最小尺寸属性（Min Width, Min Height）。&lt;/li&gt;
&lt;li&gt;如果有足够的可用空间，布局控制器分配首选尺寸属性（Preferred Width, Preferred Height）。&lt;/li&gt;
&lt;li&gt;如果还有额外的可用空间，布局控制器分配弹性尺寸属性（Flexible Width, Flexible Height）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_LayoutElementInspector_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当你启用宽度或高度属性时，旁边会出现一个值字段。使用这个值字段输入宽度或高度的确切值。最小和首选尺寸是以常规单位表示，而弹性尺寸则是以相对单位表示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Ignore Layout&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当启用时，布局系统会忽略这个布局元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Min Width&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个布局元素应该具有的最小宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Min Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个布局元素应该具有的最小高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Preferred Width&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在分配额外可用宽度之前，这个布局元素应该具有的首选宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Preferred Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在分配额外可用高度之前，这个布局元素应该具有的首选高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Flexible Width&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;此布局元素应相对于其同级元素填充的可用额外宽度的相对数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Flexible Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个布局元素相对于它的同级元素应填充的额外可用高度的相对数值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Layout Priority&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个组件的布局优先级。如果一个游戏对象有多个具有布局属性的组件（例如，一个Image组件和一个LayoutElement组件），布局系统会使用具有最高布局优先级的组件的属性值。如果组件有相同的布局优先级，布局系统使用每个属性的最高值，无论它来自哪个组件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Layout Element组件允许你覆盖一个或多个布局属性的值。如果你想要覆盖一个属性的值，启用该属性的复选框，然后指定你想要覆盖的值。&lt;/p&gt;
&lt;p&gt;最小和优先大小以常规单位定义，而灵活的大小以相对单位定义。如果任何布局元素有大于零的灵活大小，意味着所有可用的空间将被填充满。兄弟元素的相对灵活大小值确定了每个兄弟元素填充可用空间的大小比例。最常见的是，灵活的宽度和高度设置为0或1。&lt;/p&gt;
&lt;p&gt;在某些情况下，同时指定优先大小和灵活大小是有意义的。灵活的大小只有在所有的优先大小都已完全分配后才被分配。因此，一个布局元素如果指定了灵活大小，但没有指定优先大小，将会保持其最小大小，直到其他布局元素已经增长到它们的全优先大小，然后基于额外的可用空间开始增长。通过也指定一个灵活的大小，这可以被避免，并且该元素可以与其他具有优先大小的布局元素一起增长到其优选大小，然后在所有的灵活大小都已分配后进一步增长。&lt;/p&gt;
&lt;h5 id=&#34;content-size-fitter&#34;&gt;Content Size Fitter &lt;a href=&#34;#content-size-fitter&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ContentSizeFitterInspector22.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal Fit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如何控制宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unconstrained&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要基于布局元素来驱动宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Min Size&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据布局元素的最小宽度来驱动宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Preferred Size&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据布局元素的首选宽度来驱动宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical Fit&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;高度是如何被控制的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unconstrained&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要根据布局元素来驱动高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Min Size&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据布局元素的最小高度来驱动高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Preferred Size&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据布局元素的优选高度来驱动高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Content Size Fitter充当一个布局控制器，控制其自身布局元素的大小。大小由Game Object上的布局元素组件提供的最小或优选大小决定。这类布局元素可以是Image或Text组件，布局组，或者是一个Layout Element组件。&lt;/p&gt;
&lt;p&gt;值得记住的是，当一个Rect Transform被调整大小 - 无论是由Content Size Fitter还是其他东西 - 调整大小是围绕枢轴进行的。这意味着可以使用枢轴来控制调整大小的方向。&lt;/p&gt;
&lt;p&gt;例如，当枢轴在中心时，Content Size Fitter将等同于所有方向来扩展Rect Transform。而当枢轴在左上角时，Content Size Fitter将向下和向右扩展Rect Transform。&lt;/p&gt;
&lt;h5 id=&#34;aspect-ratio-fitter&#34;&gt;Aspect Ratio Fitter &lt;a href=&#34;#aspect-ratio-fitter&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_AspectRatioFitterInspector_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Aspect Mode&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如何调整矩形的大小以强制执行宽高比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;None&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要使矩形适应宽高比。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Width Controls Height&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据宽度自动调整高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Height Controls Width&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据高度自动调整宽度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Fit In Parent&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;宽度、高度、位置和锚点都会自动调整，使矩形在保持宽高比的同时适应其父级矩形。可能会有一些空间在父级矩形内部，但未被此矩形覆盖。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Envelope Parent&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;宽度、高度、位置和锚点会自动调整，使得矩形在保持宽高比的情况下覆盖父级矩形的全部区域。此矩形可能会超出父级矩形的范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Aspect Ratio&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;要强制执行的宽高比。这是宽度除以高度的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;宽高比适配器作为一个布局控制器，控制其自身布局元素的大小。它可以调整高度以适应宽度，反之亦然，或者它可以使元素适应其父元素的大小或者包裹其父元素。宽高比适配器并不会考虑像最小尺寸和首选尺寸这样的布局信息。&lt;/p&gt;
&lt;p&gt;值得记住的是，当一个矩形变换被调整大小 - 无论是由宽高比适配器还是别的什么调整的 - 调整是围绕枢轴进行的。这意味着，可以用枢轴来控制矩形的对齐方式。例如，一个放在顶部中心的枢轴会使矩形等量向两侧增长，仅向下增长，而顶边则保持在原位。&lt;/p&gt;
&lt;h5 id=&#34;horizontal-layout-group&#34;&gt;Horizontal Layout Group &lt;a href=&#34;#horizontal-layout-group&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Horizontal Layout Group组件将其子布局元素并排放置。这些元素的宽度由各自的最小、优选和灵活宽度按照下述模型确定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有子布局元素的最小宽度相加，以及它们之间的间距也被加入。得出的结果就是Horizontal Layout Group的最小宽度。&lt;/li&gt;
&lt;li&gt;所有子布局元素的优选宽度相加，和它们之间的间距也被加入。得出的结果就是Horizontal Layout Group的优选宽度。&lt;/li&gt;
&lt;li&gt;如果Horizontal Layout Group的宽度等于其最小宽度或者更小，那么所有子布局元素的宽度也将是它们各自的最小宽度。&lt;/li&gt;
&lt;li&gt;越接近Horizontal Layout Group的优选宽度，每个子布局元素的宽度也将越接近它们的优选宽度。&lt;/li&gt;
&lt;li&gt;如果Horizontal Layout Group的宽度超过其优选宽度，它将按照各自的灵活宽度比例向子布局元素分配额外的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_HorizontalLayoutGroupInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Padding&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在布局组的边缘之间的填充。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局元素之间的间距。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Child Alignment&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果子布局元素没有填满所有可用空间，使用何种对齐方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Control Child Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组是否控制其子布局元素的宽度和高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Use Child Scale&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组在计算元素的大小和布局时，是否考虑其子布局元素的比例。&lt;!-- raw HTML omitted --&gt;宽度和高度分别对应每个子布局元素的Rect Transform组件中的Scale &amp;gt; X和Scale &amp;gt; Y值。&lt;!-- raw HTML omitted --&gt;你无法使用Animator Controller来动画化Scale值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Child Force Expand&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否强制子布局元素扩展以填充额外的可用空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;vertical-layout-group&#34;&gt;Vertical Layout Group &lt;a href=&#34;#vertical-layout-group&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Vertical Layout Group组件将其子布局元素置于彼此顶部。他们的高度由相应的最小，首选和灵活高度决定，根据以下模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有子布局元素的最小高度被相加，之间的空间也被添加。结果就是Vertical Layout Group的最小高度。&lt;/li&gt;
&lt;li&gt;所有子布局元素的首选高度被相加，之间的空间也被添加。结果就是Vertical Layout Group的首选高度。&lt;/li&gt;
&lt;li&gt;如果Vertical Layout Group处于其最小高度或更小的状态，所有子布局元素也将具有它们的最小高度。&lt;/li&gt;
&lt;li&gt;Vertical Layout Group越接近其首选高度，每个子布局元素也越接近他们的首选高度。&lt;/li&gt;
&lt;li&gt;如果Vertical Layout Group高于其首选高度，它会将额外的空间按照各自的灵活高度的比例分配给子布局元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_VerticalLayoutGroupInspector23.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Padding&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组边缘内部的填充。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局元素之间的间距。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Child Alignment&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果子布局元素没有填充所有可用空间，将使用的对齐方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Control Child Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组是否控制其子布局元素的宽度和高度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Use Child Scale&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组在尺寸和布局元素时，是否考虑其子布局元素的缩放。&lt;!-- raw HTML omitted --&gt;宽度和高度对应于每个子布局元素的Rect Transform组件中的Scale &amp;gt; X和Scale &amp;gt; Y值。&lt;!-- raw HTML omitted --&gt;你无法使用Animator Controller来动画这些Scale值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Child Force Expand&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否强制子布局元素扩展以填充额外可用的空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;grid-layout-group&#34;&gt;Grid Layout Group &lt;a href=&#34;#grid-layout-group&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Grid Layout Group组件将其子布局元素置于一个格子中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_GridLayoutGroupInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Padding&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局组边缘内部的填充。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Cell Size&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每个组中布局元素的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Spacing&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;布局元素之间的间距。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Start Corner&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;首个元素所在的角落。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Start Axis&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;沿哪个主轴放置元素。横向会填满整行后才开始新的行。纵向会填满整列后才开始新的列。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Child Alignment&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果布局元素没有填满所有可用空间，应使用的对齐方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将网格约束为固定数目的行或列，以帮助自动布局系统。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其他布局组不同，Grid Layout Group忽视其包含的布局元素的最小、优选和灵活尺寸属性，而是为所有元素分配固定尺寸，该尺寸由Grid Layout Group自身的Cell Size属性定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grid Layout Group and auto layout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用Grid Layout Group作为自动布局设置的一部分时，需要注意一些特殊考虑，例如与Content Size Fitter一起使用。&lt;/p&gt;
&lt;p&gt;自动布局系统独立计算水平和垂直大小。这可能与Grid Layout Group存在冲突，因为行数取决于列数，反之亦然。&lt;/p&gt;
&lt;p&gt;对于任何给定数量的单元格，都有不同组合的行数和列数可以使网格适应其内容。为了帮助布局系统，你可以指定你希望表格具有固定数量的列或行，通过使用Constraint属性。&lt;/p&gt;
&lt;p&gt;以下是一些使用Content Size Fitter搭配布局系统的建议方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flexible width and fixed height&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您想设置一个具有灵活宽度和固定高度的网格，当添加更多元素时，网格会水平扩展，您可以按如下方式设置这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grid Layout Group Constraint：Fixed Row Count&lt;/li&gt;
&lt;li&gt;Content Size Fitter Horizontal Fit：Preferred Size&lt;/li&gt;
&lt;li&gt;Content Size Fitter Vertical Fit：Preferred Size 或 Unconstrained&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用不受约束的Vertical Fit，那么您需要给网格设定一个足够大的高度，以适应指定的单元格行数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fixed width and flexible height&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您想设置一个具有固定宽度和灵活高度的网格，当添加更多元素时，网格会垂直扩展，您可以按如下方式设置这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grid Layout Group Constraint：Fixed Column Count&lt;/li&gt;
&lt;li&gt;Content Size Fitter Horizontal Fit：Preferred Size 或 Unconstrained&lt;/li&gt;
&lt;li&gt;Content Size Fitter Vertical Fit：Preferred Size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用不受约束的Horizontal Fit，那么您需要给网格设定一个足够大的宽度，以适应指定的单元格列数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Both flexible width and height&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您想设置一个宽度和高度都灵活的网格，您可以实现，但是您将无法控制行和列的具体数量。网格将尝试使行和列的数量大致相同。您可以按如下方式设置这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grid Layout Group Constraint：Flexible&lt;/li&gt;
&lt;li&gt;Content Size Fitter Horizontal Fit：Preferred Size&lt;/li&gt;
&lt;li&gt;Content Size Fitter Vertical Fit：Preferred Size&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;event-1&#34;&gt;Event &lt;a href=&#34;#event-1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;h5 id=&#34;script---event-system-manager&#34;&gt;Script - Event System Manager &lt;a href=&#34;#script---event-system-manager&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;这个子系统负责控制构成事件的所有其他元素。它协调哪个输入模块当前处于活动状态，哪个GameObject当前被视为&amp;quot;selected&amp;quot;，以及其他一系列高级事件系统概念。&lt;/p&gt;
&lt;p&gt;每次&amp;rsquo;Update&amp;rsquo;，事件系统都会接收到调用，查看其输入模块，并找出应当用于此次更新的输入模块。然后，它将处理工作委派给这些模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;First Selected&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被首先选定的GameObject。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Send Navigation Events&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;事件系统是否应允许导航事件（移动/提交/取消）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Drag Threshold&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以像素为单位的拖拽软区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;script---graphic-raycaster&#34;&gt;Script - Graphic Raycaster &lt;a href=&#34;#script---graphic-raycaster&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Graphic Raycaster 用于对 Canvas 进行射线检测。Raycaster 查看 Canvas 上的所有图像，并确定是否有任何图像被击中。&lt;/p&gt;
&lt;p&gt;Graphic Raycaster 可以配置为忽略背面的图形，也可以被存在于其前面的2D或3D对象阻挡。如果您希望强制将此元素的处理置于射线检测的前端或后端，也可以应用手动优先级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Ignore Reversed Graphics&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是否应考虑面向远离Graphic Raycaster的图形？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Blocked Objects&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将阻挡图形射线检测的对象类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Blocking Mask&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;阻挡Graphic Raycast的对象类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;script---physics-raycaster&#34;&gt;Script - Physics Raycaster &lt;a href=&#34;#script---physics-raycaster&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Physics Raycaster在场景中对3D对象执行射线投射。这允许将消息发送给实现了事件接口的3D物理对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Depth&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取配置相机的深度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Event Camera&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取此模块使用的相机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Event Mask&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;相机遮罩和事件遮罩的逻辑与运算。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Final Event Mask&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;相机遮罩和事件遮罩的逻辑与运算。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;script---physics-2d-raycaster&#34;&gt;Script - Physics 2D Raycaster &lt;a href=&#34;#script---physics-2d-raycaster&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Physics 2D Raycaster是针对场景中的2D对象进行射线投射的。这允许向实现事件接口的2D物理对象发送消息。需要使用相机游戏对象，并且如果Physics 3D Raycaster没有添加到相机游戏对象中，它将会被添加到游戏对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Event Camera&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将为这个射线投射器生成射线的相机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Priority&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;相对于其他投射器的优先级。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Sort Order Priority&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基于排序顺序的射线投射器的优先级。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Render Order Priority&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基于渲染顺序的射线投射器的优先级。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;script---standalone-input-module&#34;&gt;Script - Standalone Input Module &lt;a href=&#34;#script---standalone-input-module&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;这个模块旨在使控制器/鼠标输入按预期工作。按钮按压、拖拽等类似的事件会对输入作出响应。&lt;/p&gt;
&lt;p&gt;随着鼠标/输入设备的移动，模块会向组件发送指针事件，并使用Graphics Raycaster和Physics Raycaster来计算当前指针设备指向的元素。你可以根据你的需求配置这些射线投射器以检测或忽略你的场景的某些部分。&lt;/p&gt;
&lt;p&gt;该模块会对通过Input窗口跟踪的输入做出动作事件以及提交/取消事件的响应。该方法适用于键盘和控制器输入。可以在模块的检查器中配置被跟踪的轴和键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Horizontal Axis&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;为水平轴按钮输入所需的管理器名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Vertical Axis&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;为垂直轴输入所需的管理器名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Submit Button&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;为Submit按钮输入所需的管理器名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Cancel Button&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;为Cancel按钮输入所需的管理器名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Input Actions Per Second&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每秒允许的键盘/控制器输入数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Repeat Delay&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在每秒输入动作重复率生效前的延迟秒数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Force Module Active&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启用此属性以强制使此Standalone Input Module处于活动状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垂直/水平轴进行键盘和控制器导航&lt;/li&gt;
&lt;li&gt;提交/取消按钮用于发送提交和取消事件&lt;/li&gt;
&lt;li&gt;存在事件间的超时限制，只允许每秒钟达到最大事件数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果从输入窗口输入了有效的轴，则向选定的对象发送移动事件&lt;/li&gt;
&lt;li&gt;如果按下提交或取消按钮，则向选定的对象发送提交或取消事件&lt;/li&gt;
&lt;li&gt;处理鼠标输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​			如果是新的按压操作：
​					发送PointerEnter事件（发送给沿层次结构向上可以处理的所有对象）
​					发送PointerPress事件
​					缓存拖动处理器（层次结构中可以处理它的第一个元素）
​					向拖动处理器发送BeginDrag事件
​					在事件系统中设定&amp;rsquo;Pressed&amp;rsquo;对象为选定
​			如果这是一个持续的按压：
​					处理移动
​					向缓存的拖动处理器发送DragEvent
​					如果触摸在对象之间移动，处理PointerEnter和PointerExit事件
​			如果这是一个释放：
​					向接收到PointerPress的对象发送PointerUp事件
​					如果当前的悬停对象与PointerPress对象相同，则发送PointerClick事件
​					如果缓存了拖动处理器，则发送一个Drop事件
​					向缓存的拖动处理器发送EndDrag事件
​			处理滚轮事件&lt;/p&gt;
&lt;h5 id=&#34;script---touch-input-module&#34;&gt;Script - Touch Input Module &lt;a href=&#34;#script---touch-input-module&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;注意：TouchInputModule已过时。现在，触摸输入在StandaloneInputModule中处理。&lt;/p&gt;
&lt;p&gt;此模块设计用于处理触摸设备。它会根据用户输入发送触摸和拖动的指针事件。此模块支持多点触控。&lt;/p&gt;
&lt;p&gt;该模块使用场景配置的Raycasters来计算当前正在触摸哪个元素。每一个当前的触摸都会发出一个射线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Properties(属性)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;属性:&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;功能:&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Force Module Active&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强制使此模块处于活动状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Details(详情)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块的流程如下：&lt;/p&gt;
&lt;p&gt;对于每一个触摸事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这是一个新的按压
&lt;ul&gt;
&lt;li&gt;发送PointerEnter事件（发送给层次结构中每一个能处理它的对象）&lt;/li&gt;
&lt;li&gt;发送PointerPress事件&lt;/li&gt;
&lt;li&gt;缓存拖动处理器（在层次结构中能处理它的第一个元素）&lt;/li&gt;
&lt;li&gt;向拖动处理器发送BeginDrag事件&lt;/li&gt;
&lt;li&gt;在事件系统中设置&amp;rsquo;Pressed&amp;rsquo;对象为Selected&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果这是一个持续的按压
&lt;ul&gt;
&lt;li&gt;处理移动&lt;/li&gt;
&lt;li&gt;向缓存的拖动处理器发送DragEvent事件&lt;/li&gt;
&lt;li&gt;如果触摸在对象之间移动，处理PointerEnter和PointerExit事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果这是一个释放
&lt;ul&gt;
&lt;li&gt;向接收到PointerPress的对象发送PointerUp事件&lt;/li&gt;
&lt;li&gt;如果当前悬停对象与PointerPress对象相同，则发送一个PointerClick事件&lt;/li&gt;
&lt;li&gt;如果有拖动处理器缓存，发送一个Drop事件&lt;/li&gt;
&lt;li&gt;向缓存的拖动处理器发送EndDrag事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;script---event-trigger&#34;&gt;Script - Event Trigger &lt;a href=&#34;#script---event-trigger&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Event Trigger从事件系统接收事件，并为每个事件调用已注册的函数。&lt;/p&gt;
&lt;p&gt;你可以使用Event Trigger为每个事件系统事件指定希望调用的函数。你可以将多个函数分配给单个事件，每当Event Trigger接收到该事件，它就会调用这些函数。&lt;/p&gt;
&lt;p&gt;请注意，将Event Trigger组件附加到GameObject上会使该对象拦截所有事件，且此对象不会发生事件冒泡！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Event&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以通过点击添加新事件类型按钮，选择性地将每个受支持的事件包含在Event Trigger中。&lt;/p&gt;
&lt;h3 id=&#34;ui-how-tosui操作指南&#34;&gt;UI How Tos(UI操作指南) &lt;a href=&#34;#ui-how-tosui%e6%93%8d%e4%bd%9c%e6%8c%87%e5%8d%97&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在这一部分，你可以学习到常见UI任务的解决方案。&lt;/p&gt;
&lt;h4 id=&#34;designing-ui-for-multiple-resolutions为多种分辨率设计ui&#34;&gt;Designing UI for Multiple Resolutions(为多种分辨率设计UI) &lt;a href=&#34;#designing-ui-for-multiple-resolutions%e4%b8%ba%e5%a4%9a%e7%a7%8d%e5%88%86%e8%be%a8%e7%8e%87%e8%ae%be%e8%ae%a1ui&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;现代游戏和应用程序通常需要支持各种不同的屏幕分辨率，特别是UI布局需要能够适应这一点。Unity的UI系统包括了许多用于此目的的工具，可以以各种方式结合使用。&lt;/p&gt;
&lt;p&gt;在这个操作指南中，我们将使用一个简单的案例研究，并在这个背景下查看并比较不同的工具。在我们的案例研究中，我们在屏幕角落有三个按钮，如下图所示，目标是将这种布局适应到各种分辨率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResBase.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在本操作指南中，我们将考虑四种屏幕分辨率：手机HD的纵向（640 x 960）和横向（960 x 640），以及手机SD的纵向（320 x 480）和横向（480 x 320）。该布局最初是在手机HD纵向分辨率下设置的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using anchors to adapt to different aspect ratios(使用锚点适应不同的纵横比)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，UI元素被锚定在父矩形的中心。这意味着它们与中心保持固定的偏移。&lt;/p&gt;
&lt;p&gt;如果将分辨率更改为横向纵横比，那么这种设置下的按钮可能不再位于屏幕的矩形内。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResCenter.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;让按钮保持在屏幕内的一种方法是改变布局，使得按钮的位置与屏幕的各自角落相对应。左上角按钮的锚点可以通过检查器中的锚点预设下拉菜单设置为左上角，或者通过在场景视图中拖动三角形的锚点句柄来设置。最好在游戏视图中设置的当前屏幕分辨率是布局最初设计的那个，其中按钮的放置看起来是正确的。同样，左下角和右下角按钮的锚点可以分别设置为左下角和右下角。&lt;/p&gt;
&lt;p&gt;一旦按钮被锚定到各自的角落，当将分辨率改变为不同的纵横比时，它们会坚持在那里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResCorners.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当屏幕大小改变为更大或更小的分辨率时，按钮也会保持在它们各自的角落。但是，由于它们保持以像素指定的原始大小，它们可能占据屏幕的更大或更小的比例。这可能是你想要的，也可能不是，这取决于你希望你的布局在不同分辨率的屏幕上表现如何。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResSizeChange.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这个指南中，我们知道，手机SD竖屏和横屏的较小分辨率并不对应于物理上较小的屏幕，而是对应于像素密度较低的屏幕。在这些低密度的屏幕上，按钮不应该比在高密度屏幕上看起来更大 - 它们应该以相同的大小出现。&lt;/p&gt;
&lt;p&gt;这意味着按钮应该以与屏幕缩小的百分比相同的百分比变小。换句话说，按钮的缩放应该跟随屏幕大小。这就是Canvas Scaler组件能够帮助的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scaling with Screen Size(随屏幕大小缩放)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Canvas Scaler组件可以添加到根Canvas - 一个带有Canvas组件的游戏对象，所有的UI元素都是它的子对象。当通过GameObject菜单创建一个新的Canvas时，它也会默认被添加。&lt;/p&gt;
&lt;p&gt;在Canvas Scaler组件中，你可以将其UI Scale Mode设置为Scale With Screen Size。使用这种缩放模式，你可以指定一个分辨率作为参考。如果当前屏幕分辨率小于或大于这个参考分辨率，Canvas的缩放因子就会相应地设置，所以所有的UI元素都会随着屏幕分辨率一起放大或缩小。&lt;/p&gt;
&lt;p&gt;在我们的案例中，我们将Canvas Scaler设置为Phone HD竖屏分辨率640 x 960。现在，当将屏幕分辨率设置为Phone SD竖屏分辨率320 x 480时，整个布局缩小了，所以它看起来比例相同，就像在全分辨率下一样。所有的东西都缩小了：按钮的大小，它们到屏幕边缘的距离，按钮的图形，和文本元素。这就意味着布局在Phone SD竖屏分辨率下看起来与Phone HD竖屏分辨率下一样，只是像素密度更低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResReferenceResolution.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要注意的一点是：添加了Canvas Scaler组件后，也很重要的是要检查布局在其它纵横比下的样子。通过将分辨率回调到Phone HD横屏，我们可以看到按钮现在看起来比它们应该的（和曾经的）更大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResLandscapeWrongScaling.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;造成横屏纵横比下按钮更大的原因归结于Canvas Scaler设置的工作方式。默认情况下，它比较当前分辨率的宽度与Canvas Scaler的宽度，结果用作缩放所有内容的缩放因子。由于当前的横屏分辨率960 x 640的宽度比竖屏Canvas Scaler的640 x 960大1.5倍，因此布局放大了1.5倍。&lt;/p&gt;
&lt;p&gt;该组件有一个名为Match的属性，可以是0（宽度），1（高度）或者介于两者之间的值。默认设置为0，如前所述，它比较当前屏幕宽度与Canvas Scaler宽度。&lt;/p&gt;
&lt;p&gt;如果Match属性设置为0.5，那么它将同时比较当前宽度与参考宽度以及当前高度与参考高度，并选择一个介于两者之间的缩放因子。由于在这种情况下，横屏分辨率宽度大1.5倍，但也短1.5倍，这两个因素相互抵消，产生最终的缩放因子1，这意味着按钮保持原大小。&lt;/p&gt;
&lt;p&gt;至此，布局使用适当的锚定组合和Canvas上的Canvas Scaler组件，支持了所有四种屏幕分辨率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_MultiResAllResolutions.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;making-ui-elements-fit-the-size-of-their-content让ui元素适应其内容的大小&#34;&gt;Making UI elements fit the size of their content(让UI元素适应其内容的大小) &lt;a href=&#34;#making-ui-elements-fit-the-size-of-their-content%e8%ae%a9ui%e5%85%83%e7%b4%a0%e9%80%82%e5%ba%94%e5%85%b6%e5%86%85%e5%ae%b9%e7%9a%84%e5%a4%a7%e5%b0%8f&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;通常在用Rect Transform定位一个UI元素时，它的位置和大小是手动指定的（可选的，包括与父Rect Transform一同拉伸的行为）。&lt;/p&gt;
&lt;p&gt;然而，有时你可能希望这个矩形能自动调整大小以适应UI元素的内容。这可以通过添加一个名为Content Size Fitter的组件来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fit to size of Text(调整以适应文本大小)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了让带有Text组件的Rect Transform适应文本内容，将Content Size Fitter组件添加到同一个拥有Text组件的游戏对象上。然后将Horizontal Fit和Vertical Fit下拉框都设置为Preferred。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How does it work? (它是如何工作的?)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里发生的是，Text组件作为一个Layout Element，可以提供有关其最小和最佳大小的信息。在手动布局中，这些信息不会被使用。Content Size Fitter是一种Layout Controller，它会监听由Layout Elements提供的布局信息，并根据这些信息控制Rect Transform的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remember the pivot(轴心点的重要)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当UI元素自动调整大小以适应其内容时，你应该特别注意Rect Transform的轴心点。当元素大小改变时，轴心点位置会保持不变，因此通过设置轴心点位置，你可以控制元素是向哪个方向扩大或缩小。例如，如果轴心点在中心，那么元素将会均等地向所有方向扩展；如果轴心点在左上角，那么元素会向右边和下方扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fit to size of UI element with child Text(适应带有子Text的UI元素尺寸)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你有一个UI元素，如Button，它有一个背景图像和一个带有Text组件的子游戏对象，你可能希望整个UI元素适应文本的大小 - 可能还有一些填充。&lt;/p&gt;
&lt;p&gt;要做到这一点，首先在UI元素上添加一个Horizontal Layout Group，然后添加一个Content Size Fitter。将Horizontal Fit、Vertical Fit或两者设置为Preferred。你可以使用Horizontal Layout Group中的padding属性添加和调整填充。&lt;/p&gt;
&lt;p&gt;为什么要使用Horizontal Layout Group呢？其实也可以是Vertical Layout Group - 只要只有一个子元素，它们产生的效果是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How does it work? (它是如何工作的？)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Horizontal（或Vertical）Layout Group既充当Layout Controller也充当Layout Element。首先，它会监听组中子元素提供的布局信息 - 在这种情况下监听的是子Text。然后，它会确定组必须要有多大（最小值和优选大小），才能包含所有子元素，并作为提供这些有关最小值和优选大小信息的Layout Element。&lt;/p&gt;
&lt;p&gt;Content Size Fitter会侦听同一个Game Object上任何Layout Element（在这种情况下由Horizontal或Vertical Layout Group提供）的布局信息。根据它的设置，它会基于这些信息控制Rect Transform的大小。&lt;/p&gt;
&lt;p&gt;一旦设置了Rect Transform的大小，Horizontal（或Vertical）Layout Group就会确保根据可用的空间对其子元素进行定位和大小设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Make children of a Layout Group fit their respective sizes(使Layout Group的子元素适应其各自的尺寸)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你有一个Layout Group（水平或垂直）并希望组中的每一个UI元素适应其各自的内容，你该怎么做呢？&lt;/p&gt;
&lt;p&gt;你不能在每个子元素上都放一个Content Size Fitter。原因是Content Size Fitter想要控制其自身的Rect Transform，但父Layout Group也想要控制子Rect Transform。这会造成冲突，结果是不确定的行为。&lt;/p&gt;
&lt;p&gt;然而，这也并非必要。父Layout Group已经可以使每个子元素适应内容的大小。你需要做的是在Layout Group中禁用Child Force Expand选项。如果子元素本身也是Layout Group，你可能需要在这些子Layout Group中也禁用Child Force Expand选项。&lt;/p&gt;
&lt;p&gt;一旦子元素不再以灵活的宽度扩展，它们的对齐方式可以在Layout Group中通过Child Alignment设置来指定。&lt;/p&gt;
&lt;p&gt;如果你希望一些子元素扩展以填充额外的可用空间，但不是其他子元素呢？你可以通过在你想要扩展的子元素中添加一个Layout Element组件并启用这些Layout Element上的Flexible Width或Flexible Height属性来轻松控制这一点。父Layout Group应该仍然禁用Child Force Expand选项，否则所有的子元素都将灵活地扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How does it work? (它是如何工作的？)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个游戏对象可以有多个组件，每个组件都提供关于最小、优选和灵活大小的布局信息。一个优先级系统决定哪些值优先于其他值生效。Layout Element组件的优先级高于Text、Image和Layout Group组件，因此可以用来覆盖它们提供的任何布局信息值。&lt;/p&gt;
&lt;p&gt;当Layout Group监听子元素提供的布局信息时，它会考虑到被重新定义的灵活大小。然后，当控制子元素的大小时，它不会让它们大于其优选大小。然而，如果Layout Group启用了Child Force Expand选项，它将始终使所有子元素的灵活大小至少为1。&lt;/p&gt;
&lt;h4 id=&#34;creating-a-world-space-ui创建一个世界空间ui&#34;&gt;Creating a World Space UI(创建一个世界空间UI) &lt;a href=&#34;#creating-a-world-space-ui%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4ui&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;UI系统使得在场景中的其他2D或3D对象之间创建位于世界中的UI变得非常容易。&lt;/p&gt;
&lt;p&gt;开始时，通过使用GameObject &amp;gt; UI &amp;gt; Image创建一个UI元素（例如一个Image），如果你的场景中还没有的话。这同时也会为你创建一个Canvas。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set the Canvas to World Space(设置Canvas为世界空间)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中你的Canvas并将渲染模式更改为World Space。&lt;/p&gt;
&lt;p&gt;现在你的Canvas已经位于世界中，只要相机对准它，所有的相机都可以看到它，但是它可能与你场景中的其他对象相比很大。我们稍后再处理这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decide on a resolution(确定一个分辨率)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，你需要决定Canvas的分辨率应该是多少。如果它是一张图片，那么这张图片的像素分辨率应该是多少呢？像800x600这样的分辨率可能是一个好的起点。你可以在Canvas的Rect Transform的宽度和高度值中输入分辨率。同时设置位置为0,0可能是一个好主意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Specify the size of the Canvas in the world(指定Canvas在世界中的大小)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，你应该考虑Canvas在世界中应该有多大。你可以使用缩放工具简单地缩小它，直到它有一个看起来不错的大小，或者你可以决定它应该有多少米。&lt;/p&gt;
&lt;p&gt;如果你希望它有特定的宽度（以米为单位），你可以通过使用 meter_size / canvas_width 来计算需要的缩放。例如，如果你希望它宽2米，Canvas的宽度是800，你就会得到2 / 800 = 0.0025。然后，你将Canvas的Rect Transform的Scale属性设置为0.0025，对X、Y和Z都进行设置，以确保它均匀地缩放。&lt;/p&gt;
&lt;p&gt;另一种思考的方式是，你正在控制Canvas中每个像素的大小。如果Canvas的缩放为0.0025，那么这也是Canvas中每个像素在世界中的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Position the Canvas(定位Canvas)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与设为屏幕空间的Canvas不同，世界空间的Canvas可以在场景中自由定位和旋转。你可以将Canvas放置在任何墙壁、地板、天花板或倾斜的表面（当然，也可以自由地悬挂在空气中）。只需在工具栏中使用常规的翻译和旋转工具即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Creating UI elements from scripting(通过脚本创建UI元素)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你正在创建一个动态的UI，其中的UI元素基于用户操作或游戏中的其他操作出现、消失或改变，你可能需要编写一个根据自定义逻辑实例化新UI元素的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Creating a prefab of the UI element(创建UI元素的预制体)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能够轻松地动态实例化UI元素，第一步是为你想要实例化的UI元素类型创建一个预制体。在场景中设置UI元素的外观，然后将元素拖入项目视图以将其转换为预制体。&lt;/p&gt;
&lt;p&gt;例如，一个按钮的预制体可以是一个带有Image组件和Button组件的游戏对象，和一个带有Text组件的子游戏对象。你的设置可能会根据你的需要而有所不同。&lt;/p&gt;
&lt;p&gt;你可能会想知道为什么我们没有API方法来创建各种类型的控制，包括视觉效果和所有其他元素。原因是有无数种方式可以设置一个按钮。它是使用图像、文本还是同时使用两者？甚至可能是多个图像？文本的字体、颜色、字体大小和对齐是什么样的？图像应该使用什么精灵或精灵？通过让你制作一个预制体并实例化它，你可以按照你想要的方式设置它。如果你以后想要改变UI的外观和感觉，你只需要改变预制体，然后它就会体现在你的UI中，包括动态创建的UI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Instantiating the UI element(实例化UI元素)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;像通常一样使用Instantiate方法实例化UI元素的预制体。在设置实例化UI元素的父级时，建议使用Transform.SetParent方法，并将worldPositionStays参数设置为false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Positioning the UI element(定位UI元素)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UI元素通常使用其Rect Transform进行定位。如果UI元素是Layout Group的子元素，那么它将被自动定位，可以跳过定位步骤。&lt;/p&gt;
&lt;p&gt;在定位Rect Transform时，首先确定它是否具有或应具有任何拉伸行为。当anchorMin和anchorMax属性不相同时，会发生拉伸行为。&lt;/p&gt;
&lt;p&gt;对于非拉伸的Rect Transform，通过设置anchoredPosition和sizeDelta属性最容易设置位置。anchoredPosition指定了枢轴相对于锚点的位置。sizeDelta在没有拉伸时就和大小一样。&lt;/p&gt;
&lt;p&gt;对于拉伸的Rect Transform，使用offsetMin和offsetMax属性设置位置可能更简单。offsetMin属性指定了rect的左下角相对于左下锚点的角。offsetMax属性指定了rect的右上角相对于右上锚点的角。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Customizing the UI Element(自定义UI元素)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你要动态实例化多个UI元素，那么你可能不希望它们看起来和做的事情都一样。无论是在菜单中的按钮，库存中的物品，还是其他东西，你可能希望各个项目有不同的文本或图像，当与之交互时，做不同的事情。&lt;/p&gt;
&lt;p&gt;这是通过获取各种组件并更改其属性来完成的。参见Image和Text组件的脚本引用，以及如何从脚本中使用UnityEvents。&lt;/p&gt;
&lt;h4 id=&#34;creating-screen-transitions创建屏幕过渡&#34;&gt;Creating Screen Transitions(创建屏幕过渡) &lt;a href=&#34;#creating-screen-transitions%e5%88%9b%e5%bb%ba%e5%b1%8f%e5%b9%95%e8%bf%87%e6%b8%a1&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;需要在多个UI屏幕之间进行转换是相当常见的。在这个页面中，我们将探讨一种使用动画和状态机来驱动和控制每个屏幕的简单方式来创建和管理这些过渡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overview(概述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级思想是我们的每个屏幕都将有一个动画控制器，包含两个状态（打开和关闭）和一个布尔参数（打开）。要在屏幕之间进行转换，你只需要关闭当前打开的屏幕并打开所需的屏幕。为了简化这个过程，我们将创建一个小型的类ScreenManager，它将跟踪并处理关闭任何已经打开的屏幕。触发转换的按钮只需请求ScreenManager打开所需的屏幕。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thinking about Navigation(关于导航)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你计划支持控制器/键盘导航的UI元素，那么有几件事情是需要注意的。避免在屏幕外部有Selectable元素是很重要的，因为那会让玩家能够选择到屏幕外的元素，我们可以通过停用任何屏幕外的层次结构来做到这一点。我们还需要确保当显示新屏幕时，我们设置其作为选定的元素，否则玩家将无法导航到新的屏幕。我们将在下面的ScreenManager类中处理所有这些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Setting up the Animator Controller(设置动画控制器)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们来看看为动画控制器做屏幕过渡的最常见和最小的设置。控制器将需要一个布尔参数（打开）和两个状态（打开和关闭），每个状态都应该有只有一个关键帧的动画，这样我们就让状态机为我们做过渡混合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScreenTransitionAnimatorOpen.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScreenTransitionAnimatorClosed.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在我们需要创建两种状态之间的转换，让我们从Open到Closed的转换开始，并正确设置条件，我们希望当参数Open设置为false时，从Open转换到Closed。现在我们创建从Closed到Open的转换，并设置条件为当参数Open为true时，从Closed转换到Open。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScreenTransitionAnimatorTransitionToOpen.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScreenTransitionAnimatorTransitionToClosed.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Managing the screens(管理屏幕)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了上述所有设置，我们唯一缺少的就是在我们想要过渡的屏幕的Animator上把参数Open设置为true，并在当前打开的屏幕的Animator上把Open设置为false。为了做到这一点，我们将创建一个小脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; UnityEngine;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; UnityEngine.UI;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; UnityEngine.EventSystems;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; System.Collections;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScreenManager&lt;/span&gt; : MonoBehaviour {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Screen to open automatically at the start of the Scene&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Animator initiallyOpen;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Currently Open Screen&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; Animator m_Open;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Hash of the parameter we use to control the transitions.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_OpenParameterId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//The GameObject Selected before we opened the current Screen.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Used when closing a Screen, so we can go back to the button that opened it.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; GameObject m_PreviouslySelected;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Animator State and Transition names we need to check against.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; k_OpenTransitionName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Open&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; k_ClosedStateName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Closed&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; OnEnable()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//We cache the Hash to the &amp;#34;Open&amp;#34; Parameter, so we can feed to Animator.SetBool.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_OpenParameterId = Animator.StringToHash (k_OpenTransitionName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//If set, open the initial Screen now.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (initiallyOpen == &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        OpenPanel(initiallyOpen);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Closes the currently open panel and opens the provided one.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//It also takes care of handling the navigation, setting the new Selected element.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; OpenPanel (Animator anim)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (m_Open == anim)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Activate the new Screen hierarchy so we can animate it.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        anim.gameObject.SetActive(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Save the currently selected button that was used to open this Screen. (CloseCurrent will modify it)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; newPreviouslySelected = EventSystem.current.currentSelectedGameObject;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Move the Screen to front.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        anim.transform.SetAsLastSibling();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CloseCurrent();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_PreviouslySelected = newPreviouslySelected;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Set the new Screen as then open one.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_Open = anim;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Start the open animation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_Open.SetBool(m_OpenParameterId, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Set an element in the new screen as the new Selected one.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        GameObject go = FindFirstEnabledSelectable(anim.gameObject);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SetSelected(go);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Finds the first Selectable element in the providade hierarchy.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; GameObject FindFirstEnabledSelectable (GameObject gameObject)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        GameObject go = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; selectables = gameObject.GetComponentsInChildren&amp;lt;Selectable&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; selectable &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; selectables) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (selectable.IsActive () &amp;amp;&amp;amp; selectable.IsInteractable ()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                go = selectable.gameObject;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; go;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Closes the currently open Screen&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//It also takes care of navigation.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Reverting selection to the Selectable used before opening the current screen.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; CloseCurrent()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (m_Open == &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Start the close animation.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_Open.SetBool(m_OpenParameterId, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Reverting selection to the Selectable used before opening the current screen.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SetSelected(m_PreviouslySelected);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Start Coroutine to disable the hierarchy when closing animation finishes.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        StartCoroutine(DisablePanelDeleyed(m_Open));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//No screen open.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_Open = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Coroutine that will detect when the Closing animation is finished and it will deactivate the&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//hierarchy.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IEnumerator DisablePanelDeleyed(Animator anim)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; closedStateReached = &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; wantToClose = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (!closedStateReached &amp;amp;&amp;amp; wantToClose)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (!anim.IsInTransition(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                closedStateReached = anim.GetCurrentAnimatorStateInfo(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;).IsName(k_ClosedStateName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            wantToClose = !anim.GetBool(m_OpenParameterId);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;yield&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; WaitForEndOfFrame();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wantToClose)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            anim.gameObject.SetActive(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Make the provided GameObject selected&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//When using the mouse/touch we actually want to set it as the previously selected and&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//set nothing as selected for now.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; SetSelected(GameObject go)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Select the GameObject.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EventSystem.current.SetSelectedGameObject(go);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//If we are using the keyboard right now, that&amp;#39;s all we need to do.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; standaloneInputModule = EventSystem.current.currentInputModule &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; StandaloneInputModule;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (standaloneInputModule != &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//Since we are using a pointer device, we don&amp;#39;t want anything selected.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//But if the user switches to the keyboard, we want to start the navigation from the provided game object.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//So here we set the current Selected to null, so the provided gameObject becomes the Last Selected in the EventSystem.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EventSystem.current.SetSelectedGameObject(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;让我们把这个脚本挂起来，我们通过创建一个新的GameObject来实现这一点，我们可以把它重命名为&amp;quot;ScreenManager&amp;quot;，并添加上面的组件到它上面。你可以给它分配一个初始屏幕，这个屏幕在你的场景开始时会被打开。&lt;/p&gt;
&lt;p&gt;现在，让我们来做最后的部分，让UI按钮工作起来。选择应该触发屏幕过渡的按钮，并在检视器中的On Click()列表下添加一个新的动作。把我们刚创建的ScreenManager GameObject拖到ObjectField上，在下拉菜单中选择ScreenManager-&amp;gt;OpenPanel (Animator)，并把你希望用户点击按钮时打开的面板拖拽到最后的ObjectField上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.chenqiaoqian.com/2023-07-09-unity-ugui/UI_ScreenTransitionButtonInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notes(备注)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种技术只需要每个屏幕都有一个带有Open参数和Closed状态的AnimatorController就可以工作&amp;ndash;你的屏幕或状态机器是如何构造的并不重要。这种技术也非常适用于嵌套屏幕，这意味着你只需要每个嵌套层级一个ScreenManager。&lt;/p&gt;
&lt;p&gt;我们在上面设置的状态机器的默认状态是Closed，所以所有使用这个控制器的屏幕都开始为关闭状态。ScreenManager提供了一个initiallyOpen属性，所以你可以指定哪个屏幕首先显示。&lt;/p&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论 &lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;搬砖愉快！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
